parse: instruction: assume-keyboard
parse:   ingredient: {name: "abc", properties: [_: "literal-string"]}
parse: instruction: run
parse:   ingredient: {name: "\n    1:character, 2:boolean, keyboard:address <- read-key keyboard:address\n    3:character, 4:boolean, keyboard:address <- read-key keyboard:address\n    5:character, 6:boolean, keyboard:address <- read-key keyboard:address\n    7:character, 8:boolean, keyboard:address <- read-key keyboard:address\n  ", properties: [_: "literal-string"]}
parse: instruction: memory-should-contain
parse:   ingredient: {name: "\n    1 <- 97  # 'a'\n    2 <- 1\n    3 <- 98  # 'b'\n    4 <- 1\n    5 <- 99  # 'c'\n    6 <- 1\n    7 <- 0  # eof\n    8 <- 1\n  ", properties: [_: "literal-string"]}
after-brace: recipe keyboard-in-scenario
after-brace: new ...
after-brace: new-fake-keyboard ...
after-brace: run ...
after-brace: memory-should-contain ...
9999 new: routine allocated memory from 1000 to 101000
schedule: keyboard-in-scenario
 101 run: keyboard:address <- new [abc]
9999 mem: storing 1000 in location 901
 101 run: keyboard:address <- new-fake-keyboard keyboard:address
9999 mem: location 901 is 1000
 102 run: default-space:address:array:location <- new location:type, 30:literal
9999 mem: array size is 30
9999 mem: new alloc: 1004
 102 run: result:address:keyboard <- new keyboard:type
9999 mem: new alloc: 1035
9999 mem: storing 1035 in location 1006
 102 run: buf:address:address:array:character <- get-address result:address:keyboard/deref, data:offset
9999 mem: location 1006 is 1035
9999 mem: location 1035 is 0
9999 mem: location 1036 is 0
9999 mem: location 1006 is 1035
9999 run: address to copy is 1036
9999 mem: storing 1036 in location 1007
 102 run: buf:address:address:array:character/deref <- next-ingredient 
9999 mem: location 1007 is 1036
9999 mem: storing 1000 in location 1036
 102 run: idx:address:number <- get-address result:address:keyboard/deref, index:offset
9999 mem: location 1006 is 1035
9999 mem: location 1035 is 0
9999 mem: location 1036 is 1000
9999 mem: location 1006 is 1035
9999 run: address to copy is 1035
9999 mem: storing 1035 in location 1008
 102 run: idx:address:number/deref <- copy 0:literal
9999 mem: location 1008 is 1035
9999 mem: storing 0 in location 1035
 102 run: reply result:address:keyboard
9999 mem: location 1006 is 1035
9999 run: result 0 is 1035
9999 mem: storing 1035 in location 901
 101 run: run [
    1:character, 2:boolean, keyboard:address <- read-key keyboard:address
    3:character, 4:boolean, keyboard:address <- read-key keyboard:address
    5:character, 6:boolean, keyboard:address <- read-key keyboard:address
    7:character, 8:boolean, keyboard:address <- read-key keyboard:address
  ]
parse: instruction: read-key
parse:   ingredient: {name: "keyboard", properties: ["keyboard": "address"]}
parse:   product: {name: "1", properties: ["1": "character"]}
parse:   product: {name: "2", properties: ["2": "boolean"]}
parse:   product: {name: "keyboard", properties: ["keyboard": "address"]}
parse: instruction: read-key
parse:   ingredient: {name: "keyboard", properties: ["keyboard": "address"]}
parse:   product: {name: "3", properties: ["3": "character"]}
parse:   product: {name: "4", properties: ["4": "boolean"]}
parse:   product: {name: "keyboard", properties: ["keyboard": "address"]}
parse: instruction: read-key
parse:   ingredient: {name: "keyboard", properties: ["keyboard": "address"]}
parse:   product: {name: "5", properties: ["5": "character"]}
parse:   product: {name: "6", properties: ["6": "boolean"]}
parse:   product: {name: "keyboard", properties: ["keyboard": "address"]}
parse: instruction: read-key
parse:   ingredient: {name: "keyboard", properties: ["keyboard": "address"]}
parse:   product: {name: "7", properties: ["7": "character"]}
parse:   product: {name: "8", properties: ["8": "boolean"]}
parse:   product: {name: "keyboard", properties: ["keyboard": "address"]}
after-brace: recipe run1002
after-brace: read-key ...
after-brace: read-key ...
after-brace: read-key ...
after-brace: read-key ...
 101 run: 1:character, 2:boolean, keyboard:address <- read-key keyboard:address
9999 mem: location 901 is 1035
 102 run: default-space:address:array:location <- new location:type, 30:literal
9999 mem: array size is 30
9999 mem: new alloc: 1037
 102 run: x:address:keyboard <- next-ingredient 
9999 mem: storing 1035 in location 1039
 102 run: break-unless x:address:keyboard, 
9999 mem: location 1039 is 1035
9999 run: jump-unless fell through
 102 run: idx:address:number <- get-address x:address:keyboard/deref, index:offset
9999 mem: location 1039 is 1035
9999 mem: location 1035 is 0
9999 mem: location 1036 is 1000
9999 mem: location 1039 is 1035
9999 run: address to copy is 1035
9999 mem: storing 1035 in location 1040
 102 run: buf:address:array:character <- get x:address:keyboard/deref, data:offset
9999 mem: location 1039 is 1035
9999 mem: location 1035 is 0
9999 mem: location 1036 is 1000
9999 mem: location 1039 is 1035
9999 run: address to copy is 1036
9999 run: its type is address
9999 mem: location 1036 is 1000
9999 mem: storing 1000 in location 1041
 102 run: max:number <- length buf:address:array:character/deref
9999 mem: location 1041 is 1000
9999 mem: location 1000 is 3
9999 mem: location 1001 is 97
9999 mem: location 1002 is 98
9999 mem: location 1003 is 99
9999 mem: location 1041 is 1000
9999 mem: storing 3 in location 1042
 102 run: done?:boolean <- greater-or-equal idx:address:number/deref, max:number
9999 mem: location 1040 is 1035
9999 mem: location 1035 is 0
9999 mem: location 1042 is 3
9999 mem: storing 0 in location 1043
 102 run: break-unless done?:boolean, 
9999 mem: location 1043 is 0
9999 run: jumping to instruction 11
 102 run: c:character <- index buf:address:array:character/deref, idx:address:number/deref
9999 mem: location 1041 is 1000
9999 mem: location 1000 is 3
9999 mem: location 1001 is 97
9999 mem: location 1002 is 98
9999 mem: location 1003 is 99
9999 mem: location 1040 is 1035
9999 mem: location 1035 is 0
9999 mem: location 1041 is 1000
9999 mem: location 1040 is 1035
9999 mem: location 1035 is 0
9999 run: address to copy is 1001
9999 run: its type is character
9999 mem: location 1001 is 97
9999 mem: storing 97 in location 1044
 102 run: idx:address:number/deref <- add idx:address:number/deref, 1:literal
9999 mem: location 1040 is 1035
9999 mem: location 1035 is 0
9999 mem: location 1040 is 1035
9999 mem: storing 1 in location 1035
 102 run: reply c:character, 1:literal/found, x:address:keyboard/same-as-ingredient:0
9999 mem: location 1044 is 97
9999 mem: location 1039 is 1035
9999 run: result 0 is 97
9999 run: result 1 is 1
9999 run: result 2 is 1035
9999 mem: storing 97 in location 1
9999 mem: storing 1 in location 2
9999 mem: storing 1035 in location 901
 101 run: 3:character, 4:boolean, keyboard:address <- read-key keyboard:address
9999 mem: location 901 is 1035
 102 run: default-space:address:array:location <- new location:type, 30:literal
9999 mem: array size is 30
9999 mem: new alloc: 1068
 102 run: x:address:keyboard <- next-ingredient 
9999 mem: storing 1035 in location 1070
 102 run: break-unless x:address:keyboard, 
9999 mem: location 1070 is 1035
9999 run: jump-unless fell through
 102 run: idx:address:number <- get-address x:address:keyboard/deref, index:offset
9999 mem: location 1070 is 1035
9999 mem: location 1035 is 1
9999 mem: location 1036 is 1000
9999 mem: location 1070 is 1035
9999 run: address to copy is 1035
9999 mem: storing 1035 in location 1071
 102 run: buf:address:array:character <- get x:address:keyboard/deref, data:offset
9999 mem: location 1070 is 1035
9999 mem: location 1035 is 1
9999 mem: location 1036 is 1000
9999 mem: location 1070 is 1035
9999 run: address to copy is 1036
9999 run: its type is address
9999 mem: location 1036 is 1000
9999 mem: storing 1000 in location 1072
 102 run: max:number <- length buf:address:array:character/deref
9999 mem: location 1072 is 1000
9999 mem: location 1000 is 3
9999 mem: location 1001 is 97
9999 mem: location 1002 is 98
9999 mem: location 1003 is 99
9999 mem: location 1072 is 1000
9999 mem: storing 3 in location 1073
 102 run: done?:boolean <- greater-or-equal idx:address:number/deref, max:number
9999 mem: location 1071 is 1035
9999 mem: location 1035 is 1
9999 mem: location 1073 is 3
9999 mem: storing 0 in location 1074
 102 run: break-unless done?:boolean, 
9999 mem: location 1074 is 0
9999 run: jumping to instruction 11
 102 run: c:character <- index buf:address:array:character/deref, idx:address:number/deref
9999 mem: location 1072 is 1000
9999 mem: location 1000 is 3
9999 mem: location 1001 is 97
9999 mem: location 1002 is 98
9999 mem: location 1003 is 99
9999 mem: location 1071 is 1035
9999 mem: location 1035 is 1
9999 mem: location 1072 is 1000
9999 mem: location 1071 is 1035
9999 mem: location 1035 is 1
9999 run: address to copy is 1002
9999 run: its type is character
9999 mem: location 1002 is 98
9999 mem: storing 98 in location 1075
 102 run: idx:address:number/deref <- add idx:address:number/deref, 1:literal
9999 mem: location 1071 is 1035
9999 mem: location 1035 is 1
9999 mem: location 1071 is 1035
9999 mem: storing 2 in location 1035
 102 run: reply c:character, 1:literal/found, x:address:keyboard/same-as-ingredient:0
9999 mem: location 1075 is 98
9999 mem: location 1070 is 1035
9999 run: result 0 is 98
9999 run: result 1 is 1
9999 run: result 2 is 1035
9999 mem: storing 98 in location 3
9999 mem: storing 1 in location 4
9999 mem: storing 1035 in location 901
 101 run: 5:character, 6:boolean, keyboard:address <- read-key keyboard:address
9999 mem: location 901 is 1035
 102 run: default-space:address:array:location <- new location:type, 30:literal
9999 mem: array size is 30
9999 mem: new alloc: 1099
 102 run: x:address:keyboard <- next-ingredient 
9999 mem: storing 1035 in location 1101
 102 run: break-unless x:address:keyboard, 
9999 mem: location 1101 is 1035
9999 run: jump-unless fell through
 102 run: idx:address:number <- get-address x:address:keyboard/deref, index:offset
9999 mem: location 1101 is 1035
9999 mem: location 1035 is 2
9999 mem: location 1036 is 1000
9999 mem: location 1101 is 1035
9999 run: address to copy is 1035
9999 mem: storing 1035 in location 1102
 102 run: buf:address:array:character <- get x:address:keyboard/deref, data:offset
9999 mem: location 1101 is 1035
9999 mem: location 1035 is 2
9999 mem: location 1036 is 1000
9999 mem: location 1101 is 1035
9999 run: address to copy is 1036
9999 run: its type is address
9999 mem: location 1036 is 1000
9999 mem: storing 1000 in location 1103
 102 run: max:number <- length buf:address:array:character/deref
9999 mem: location 1103 is 1000
9999 mem: location 1000 is 3
9999 mem: location 1001 is 97
9999 mem: location 1002 is 98
9999 mem: location 1003 is 99
9999 mem: location 1103 is 1000
9999 mem: storing 3 in location 1104
 102 run: done?:boolean <- greater-or-equal idx:address:number/deref, max:number
9999 mem: location 1102 is 1035
9999 mem: location 1035 is 2
9999 mem: location 1104 is 3
9999 mem: storing 0 in location 1105
 102 run: break-unless done?:boolean, 
9999 mem: location 1105 is 0
9999 run: jumping to instruction 11
 102 run: c:character <- index buf:address:array:character/deref, idx:address:number/deref
9999 mem: location 1103 is 1000
9999 mem: location 1000 is 3
9999 mem: location 1001 is 97
9999 mem: location 1002 is 98
9999 mem: location 1003 is 99
9999 mem: location 1102 is 1035
9999 mem: location 1035 is 2
9999 mem: location 1103 is 1000
9999 mem: location 1102 is 1035
9999 mem: location 1035 is 2
9999 run: address to copy is 1003
9999 run: its type is character
9999 mem: location 1003 is 99
9999 mem: storing 99 in location 1106
 102 run: idx:address:number/deref <- add idx:address:number/deref, 1:literal
9999 mem: location 1102 is 1035
9999 mem: location 1035 is 2
9999 mem: location 1102 is 1035
9999 mem: storing 3 in location 1035
 102 run: reply c:character, 1:literal/found, x:address:keyboard/same-as-ingredient:0
9999 mem: location 1106 is 99
9999 mem: location 1101 is 1035
9999 run: result 0 is 99
9999 run: result 1 is 1
9999 run: result 2 is 1035
9999 mem: storing 99 in location 5
9999 mem: storing 1 in location 6
9999 mem: storing 1035 in location 901
 101 run: 7:character, 8:boolean, keyboard:address <- read-key keyboard:address
9999 mem: location 901 is 1035
 102 run: default-space:address:array:location <- new location:type, 30:literal
9999 mem: array size is 30
9999 mem: new alloc: 1130
 102 run: x:address:keyboard <- next-ingredient 
9999 mem: storing 1035 in location 1132
 102 run: break-unless x:address:keyboard, 
9999 mem: location 1132 is 1035
9999 run: jump-unless fell through
 102 run: idx:address:number <- get-address x:address:keyboard/deref, index:offset
9999 mem: location 1132 is 1035
9999 mem: location 1035 is 3
9999 mem: location 1036 is 1000
9999 mem: location 1132 is 1035
9999 run: address to copy is 1035
9999 mem: storing 1035 in location 1133
 102 run: buf:address:array:character <- get x:address:keyboard/deref, data:offset
9999 mem: location 1132 is 1035
9999 mem: location 1035 is 3
9999 mem: location 1036 is 1000
9999 mem: location 1132 is 1035
9999 run: address to copy is 1036
9999 run: its type is address
9999 mem: location 1036 is 1000
9999 mem: storing 1000 in location 1134
 102 run: max:number <- length buf:address:array:character/deref
9999 mem: location 1134 is 1000
9999 mem: location 1000 is 3
9999 mem: location 1001 is 97
9999 mem: location 1002 is 98
9999 mem: location 1003 is 99
9999 mem: location 1134 is 1000
9999 mem: storing 3 in location 1135
 102 run: done?:boolean <- greater-or-equal idx:address:number/deref, max:number
9999 mem: location 1133 is 1035
9999 mem: location 1035 is 3
9999 mem: location 1135 is 3
9999 mem: storing 1 in location 1136
 102 run: break-unless done?:boolean, 
9999 mem: location 1136 is 1
9999 run: jump-unless fell through
 102 run: reply 0:literal/eof, 1:literal/found, x:address:keyboard/same-as-ingredient:0
9999 mem: location 1132 is 1035
9999 run: result 0 is 0
9999 run: result 1 is 1
9999 run: result 2 is 1035
9999 mem: storing 0 in location 7
9999 mem: storing 1 in location 8
9999 mem: storing 1035 in location 901
 100 run: memory-should-contain [
    1 <- 97  # 'a'
    2 <- 1
    3 <- 98  # 'b'
    4 <- 1
    5 <- 99  # 'c'
    6 <- 1
    7 <- 0  # eof
    8 <- 1
  ]
9999 run: checking location 1
9999 run: checking location 2
9999 run: checking location 3
9999 run: checking location 4
9999 run: checking location 5
9999 run: checking location 6
9999 run: checking location 7
9999 run: checking location 8
