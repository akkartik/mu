parse: instruction: assume-keyboard
parse:   ingredient: {name: "abc", properties: ["abc": "literal-string"]}
parse: instruction: run
parse:   ingredient: {name: "
    1:character, 2:boolean, keyboard:address <- read-key keyboard:address
    3:character, 4:boolean, keyboard:address <- read-key keyboard:address
    5:character, 6:boolean, keyboard:address <- read-key keyboard:address
    7:character, 8:boolean, keyboard:address <- read-key keyboard:address
  ", properties: ["
    1:character, 2:boolean, keyboard:address <- read-key keyboard:address
    3:character, 4:boolean, keyboard:address <- read-key keyboard:address
    5:character, 6:boolean, keyboard:address <- read-key keyboard:address
    7:character, 8:boolean, keyboard:address <- read-key keyboard:address
  ": "literal-string"]}
parse: instruction: memory-should-contain
parse:   ingredient: {name: "
    1 <- 97  # 'a'
    2 <- 1
    3 <- 98  # 'b'
    4 <- 1
    5 <- 99  # 'c'
    6 <- 1
    7 <- 0  # eof
    8 <- 1
  ", properties: ["
    1 <- 97  # 'a'
    2 <- 1
    3 <- 98  # 'b'
    4 <- 1
    5 <- 99  # 'c'
    6 <- 1
    7 <- 0  # eof
    8 <- 1
  ": "literal-string"]}
new: abc -> 0
after-brace: recipe read-key-in-mu
after-brace: assume-keyboard ...
after-brace: assume-keyboard ...
after-brace: run ...
after-brace: memory-should-contain ...
new: routine allocated memory from 1000 to 101000
schedule: read-key-in-mu
run: keyboard:address <- assume-keyboard [abc]
mem: storing 1000 in location 901
run: keyboard:address <- assume-keyboard keyboard:address
mem: location 901 is 1000
run: default-space:address:array:location <- new location:type, 30:literal
mem: array size is 30
mem: new alloc: 1004
run: result:address:keyboard <- new keyboard:type
mem: new alloc: 1035
mem: storing 1035 in location 1006
run: buf:address:address:array:character <- get-address result:address:keyboard/deref, data:offset
mem: location 1006 is 1035
mem: location 1035 is 0
mem: location 1036 is 0
mem: location 1006 is 1035
run: address to copy is 1036
mem: storing 1036 in location 1007
run: buf:address:address:array:character/deref <- next-ingredient 
mem: location 1007 is 1036
mem: storing 1000 in location 1036
run: idx:address:number <- get-address result:address:keyboard/deref, index:offset
mem: location 1006 is 1035
mem: location 1035 is 0
mem: location 1036 is 1000
mem: location 1006 is 1035
run: address to copy is 1035
mem: storing 1035 in location 1008
run: idx:address:number/deref <- copy 0:literal
mem: location 1008 is 1035
mem: storing 0 in location 1035
run: reply result:address:keyboard
mem: location 1006 is 1035
run: result 0 is 1035
mem: storing 1035 in location 901
run: run [
    1:character, 2:boolean, keyboard:address <- read-key keyboard:address
    3:character, 4:boolean, keyboard:address <- read-key keyboard:address
    5:character, 6:boolean, keyboard:address <- read-key keyboard:address
    7:character, 8:boolean, keyboard:address <- read-key keyboard:address
  ]
parse: instruction: read-key
parse:   ingredient: {name: "keyboard", properties: ["keyboard": "address"]}
parse:   product: {name: "1", properties: ["1": "character"]}
parse:   product: {name: "2", properties: ["2": "boolean"]}
parse:   product: {name: "keyboard", properties: ["keyboard": "address"]}
parse: instruction: read-key
parse:   ingredient: {name: "keyboard", properties: ["keyboard": "address"]}
parse:   product: {name: "3", properties: ["3": "character"]}
parse:   product: {name: "4", properties: ["4": "boolean"]}
parse:   product: {name: "keyboard", properties: ["keyboard": "address"]}
parse: instruction: read-key
parse:   ingredient: {name: "keyboard", properties: ["keyboard": "address"]}
parse:   product: {name: "5", properties: ["5": "character"]}
parse:   product: {name: "6", properties: ["6": "boolean"]}
parse:   product: {name: "keyboard", properties: ["keyboard": "address"]}
parse: instruction: read-key
parse:   ingredient: {name: "keyboard", properties: ["keyboard": "address"]}
parse:   product: {name: "7", properties: ["7": "character"]}
parse:   product: {name: "8", properties: ["8": "boolean"]}
parse:   product: {name: "keyboard", properties: ["keyboard": "address"]}
after-brace: recipe run1001
after-brace: read-key ...
after-brace: read-key ...
after-brace: read-key ...
after-brace: read-key ...
run: 1:character, 2:boolean, keyboard:address <- read-key keyboard:address
mem: location 901 is 1035
run: default-space:address:array:location <- new location:type, 30:literal
mem: array size is 30
mem: new alloc: 1037
run: x:address:keyboard <- next-ingredient 
mem: storing 1035 in location 1039
run: break-unless x:address:keyboard, 
mem: location 1039 is 1035
run: jump-unless fell through
run: idx:address:number <- get-address x:address:keyboard/deref, index:offset
mem: location 1039 is 1035
mem: location 1035 is 0
mem: location 1036 is 1000
mem: location 1039 is 1035
run: address to copy is 1035
mem: storing 1035 in location 1040
run: buf:address:array:character <- get x:address:keyboard/deref, data:offset
mem: location 1039 is 1035
mem: location 1035 is 0
mem: location 1036 is 1000
mem: location 1039 is 1035
run: address to copy is 1036
run: its type is 2
mem: location 1036 is 1000
mem: storing 1000 in location 1041
run: max:number <- length buf:address:array:character/deref
mem: location 1041 is 1000
mem: location 1000 is 3
mem: location 1001 is 97
mem: location 1002 is 98
mem: location 1003 is 99
mem: location 1041 is 1000
mem: storing 3 in location 1042
run: done?:boolean <- greater-or-equal idx:address:number/deref, max:number
mem: location 1040 is 1035
mem: location 1035 is 0
mem: location 1042 is 3
mem: storing 0 in location 1043
run: break-unless done?:boolean, 
mem: location 1043 is 0
run: jumping to instruction 11
run: c:character <- index buf:address:array:character/deref, idx:address:number/deref
mem: location 1041 is 1000
mem: location 1000 is 3
mem: location 1001 is 97
mem: location 1002 is 98
mem: location 1003 is 99
mem: location 1040 is 1035
mem: location 1035 is 0
mem: location 1041 is 1000
mem: location 1040 is 1035
mem: location 1035 is 0
run: address to copy is 1001
run: its type is 4
mem: location 1001 is 97
mem: storing 97 in location 1044
run: idx:address:number/deref <- add idx:address:number/deref, 1:literal
mem: location 1040 is 1035
mem: location 1035 is 0
mem: location 1040 is 1035
mem: storing 1 in location 1035
run: reply c:character, 1:literal/found, x:address:keyboard/same-as-ingredient:0
mem: location 1044 is 97
mem: location 1039 is 1035
run: result 0 is 97
run: result 1 is 1
run: result 2 is 1035
mem: storing 97 in location 1
mem: storing 1 in location 2
mem: storing 1035 in location 901
run: 3:character, 4:boolean, keyboard:address <- read-key keyboard:address
mem: location 901 is 1035
run: default-space:address:array:location <- new location:type, 30:literal
mem: array size is 30
mem: new alloc: 1068
run: x:address:keyboard <- next-ingredient 
mem: storing 1035 in location 1070
run: break-unless x:address:keyboard, 
mem: location 1070 is 1035
run: jump-unless fell through
run: idx:address:number <- get-address x:address:keyboard/deref, index:offset
mem: location 1070 is 1035
mem: location 1035 is 1
mem: location 1036 is 1000
mem: location 1070 is 1035
run: address to copy is 1035
mem: storing 1035 in location 1071
run: buf:address:array:character <- get x:address:keyboard/deref, data:offset
mem: location 1070 is 1035
mem: location 1035 is 1
mem: location 1036 is 1000
mem: location 1070 is 1035
run: address to copy is 1036
run: its type is 2
mem: location 1036 is 1000
mem: storing 1000 in location 1072
run: max:number <- length buf:address:array:character/deref
mem: location 1072 is 1000
mem: location 1000 is 3
mem: location 1001 is 97
mem: location 1002 is 98
mem: location 1003 is 99
mem: location 1072 is 1000
mem: storing 3 in location 1073
run: done?:boolean <- greater-or-equal idx:address:number/deref, max:number
mem: location 1071 is 1035
mem: location 1035 is 1
mem: location 1073 is 3
mem: storing 0 in location 1074
run: break-unless done?:boolean, 
mem: location 1074 is 0
run: jumping to instruction 11
run: c:character <- index buf:address:array:character/deref, idx:address:number/deref
mem: location 1072 is 1000
mem: location 1000 is 3
mem: location 1001 is 97
mem: location 1002 is 98
mem: location 1003 is 99
mem: location 1071 is 1035
mem: location 1035 is 1
mem: location 1072 is 1000
mem: location 1071 is 1035
mem: location 1035 is 1
run: address to copy is 1002
run: its type is 4
mem: location 1002 is 98
mem: storing 98 in location 1075
run: idx:address:number/deref <- add idx:address:number/deref, 1:literal
mem: location 1071 is 1035
mem: location 1035 is 1
mem: location 1071 is 1035
mem: storing 2 in location 1035
run: reply c:character, 1:literal/found, x:address:keyboard/same-as-ingredient:0
mem: location 1075 is 98
mem: location 1070 is 1035
run: result 0 is 98
run: result 1 is 1
run: result 2 is 1035
mem: storing 98 in location 3
mem: storing 1 in location 4
mem: storing 1035 in location 901
run: 5:character, 6:boolean, keyboard:address <- read-key keyboard:address
mem: location 901 is 1035
run: default-space:address:array:location <- new location:type, 30:literal
mem: array size is 30
mem: new alloc: 1099
run: x:address:keyboard <- next-ingredient 
mem: storing 1035 in location 1101
run: break-unless x:address:keyboard, 
mem: location 1101 is 1035
run: jump-unless fell through
run: idx:address:number <- get-address x:address:keyboard/deref, index:offset
mem: location 1101 is 1035
mem: location 1035 is 2
mem: location 1036 is 1000
mem: location 1101 is 1035
run: address to copy is 1035
mem: storing 1035 in location 1102
run: buf:address:array:character <- get x:address:keyboard/deref, data:offset
mem: location 1101 is 1035
mem: location 1035 is 2
mem: location 1036 is 1000
mem: location 1101 is 1035
run: address to copy is 1036
run: its type is 2
mem: location 1036 is 1000
mem: storing 1000 in location 1103
run: max:number <- length buf:address:array:character/deref
mem: location 1103 is 1000
mem: location 1000 is 3
mem: location 1001 is 97
mem: location 1002 is 98
mem: location 1003 is 99
mem: location 1103 is 1000
mem: storing 3 in location 1104
run: done?:boolean <- greater-or-equal idx:address:number/deref, max:number
mem: location 1102 is 1035
mem: location 1035 is 2
mem: location 1104 is 3
mem: storing 0 in location 1105
run: break-unless done?:boolean, 
mem: location 1105 is 0
run: jumping to instruction 11
run: c:character <- index buf:address:array:character/deref, idx:address:number/deref
mem: location 1103 is 1000
mem: location 1000 is 3
mem: location 1001 is 97
mem: location 1002 is 98
mem: location 1003 is 99
mem: location 1102 is 1035
mem: location 1035 is 2
mem: location 1103 is 1000
mem: location 1102 is 1035
mem: location 1035 is 2
run: address to copy is 1003
run: its type is 4
mem: location 1003 is 99
mem: storing 99 in location 1106
run: idx:address:number/deref <- add idx:address:number/deref, 1:literal
mem: location 1102 is 1035
mem: location 1035 is 2
mem: location 1102 is 1035
mem: storing 3 in location 1035
run: reply c:character, 1:literal/found, x:address:keyboard/same-as-ingredient:0
mem: location 1106 is 99
mem: location 1101 is 1035
run: result 0 is 99
run: result 1 is 1
run: result 2 is 1035
mem: storing 99 in location 5
mem: storing 1 in location 6
mem: storing 1035 in location 901
run: 7:character, 8:boolean, keyboard:address <- read-key keyboard:address
mem: location 901 is 1035
run: default-space:address:array:location <- new location:type, 30:literal
mem: array size is 30
mem: new alloc: 1130
run: x:address:keyboard <- next-ingredient 
mem: storing 1035 in location 1132
run: break-unless x:address:keyboard, 
mem: location 1132 is 1035
run: jump-unless fell through
run: idx:address:number <- get-address x:address:keyboard/deref, index:offset
mem: location 1132 is 1035
mem: location 1035 is 3
mem: location 1036 is 1000
mem: location 1132 is 1035
run: address to copy is 1035
mem: storing 1035 in location 1133
run: buf:address:array:character <- get x:address:keyboard/deref, data:offset
mem: location 1132 is 1035
mem: location 1035 is 3
mem: location 1036 is 1000
mem: location 1132 is 1035
run: address to copy is 1036
run: its type is 2
mem: location 1036 is 1000
mem: storing 1000 in location 1134
run: max:number <- length buf:address:array:character/deref
mem: location 1134 is 1000
mem: location 1000 is 3
mem: location 1001 is 97
mem: location 1002 is 98
mem: location 1003 is 99
mem: location 1134 is 1000
mem: storing 3 in location 1135
run: done?:boolean <- greater-or-equal idx:address:number/deref, max:number
mem: location 1133 is 1035
mem: location 1035 is 3
mem: location 1135 is 3
mem: storing 1 in location 1136
run: break-unless done?:boolean, 
mem: location 1136 is 1
run: jump-unless fell through
run: reply 0:literal/eof, 1:literal/found, x:address:keyboard/same-as-ingredient:0
mem: location 1132 is 1035
run: result 0 is 0
run: result 1 is 1
run: result 2 is 1035
mem: storing 0 in location 7
mem: storing 1 in location 8
mem: storing 1035 in location 901
run: memory-should-contain [
    1 <- 97  # 'a'
    2 <- 1
    3 <- 98  # 'b'
    4 <- 1
    5 <- 99  # 'c'
    6 <- 1
    7 <- 0  # eof
    8 <- 1
  ]
run: checking location 1
run: checking location 2
run: checking location 3
run: checking location 4
run: checking location 5
run: checking location 6
run: checking location 7
run: checking location 8
