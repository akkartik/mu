:(scenarios run)
:(scenario copy_literal)
recipe main [
  1:integer <- copy 23:literal
]
+run: instruction 0
+run: ingredient 0 is 23
+mem: storing in location 1

:(scenario copy)
recipe main [
  1:integer <- copy 23:literal
  2:integer <- copy 1:integer
]
+run: instruction 1
+run: ingredient 0 is 1
+mem: location 1 is 23
+mem: storing in location 2

:(code)
void run(string form) {
  run(add_recipe(form));
}

void run(recipe_number r) {
  vector<instruction>& instructions(Recipe[r].steps);
  for (size_t pc = 0; pc < instructions.size(); ++pc) {
    trace("run") << "instruction " << pc;
    switch (instructions[pc].operation) {
    // Primitive Recipe Implementations.
    case COPY: {
      trace("run") << "ingredient 0 is " << instructions[pc].ingredients[0].name;
      vector<int> data = read_memory(instructions[pc].ingredients[0]);
      write_memory(instructions[pc].products[0], data);
      break;
    }
    // End Primitive Recipe Implementations.
    default:
      raise << "undefined operation " << instructions[pc].operation;
    }
  }
}

vector<int> read_memory(reagent x) {
  vector<int> result;
  if (x.types[0] == 0) {  // literal
    result.push_back(to_int(x.name));
    return result;
  }
  int val = Memory[to_int(x.name)];
  trace("mem") << "location " << x.name << " is " << val;
  result.push_back(val);
  return result;
}

void write_memory(reagent x, vector<int> data) {
  int dest = to_int(x.name);
  trace("mem") << "storing in location " << dest;
  Memory[dest] = data[0];
}

:(code)
int to_int(string n) {
  char* end = NULL;
  int result = strtol(n.c_str(), &end, /*any base*/0);
  assert(*end == '\0');
  return result;
}
