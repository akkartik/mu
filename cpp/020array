//: Arrays contain a variable number of elements of the same type.
:(scenario copy_array)
# Arrays can be copied around with a single instruction just like integers,
# no matter how large they are.
recipe main [
  1:integer <- copy 3:literal
  2:integer <- copy 14:literal
  3:integer <- copy 15:literal
  4:integer <- copy 16:literal
  5:array:integer <- copy 1:array:integer
]
+run: instruction main/4
+run: ingredient 0 is 1
+mem: location 1 is 3
+mem: location 2 is 14
+mem: location 3 is 15
+mem: location 4 is 16
+mem: storing 3 in location 5
+mem: storing 14 in location 6
+mem: storing 15 in location 7
+mem: storing 16 in location 8

//: disable the size mismatch check since the destination array need not be initialized
:(replace "if (size_of(x) != data.size())" following "void write_memory(reagent x, vector<int> data)")
if (x.types[0] != Type_number["array"] && size_of(x) != data.size())
:(after "size_t size_of(const reagent& r)")
  static const int ARRAY = Type_number["array"];
  if (r.types[0] == ARRAY) {
    assert(r.types.size() > 1);
    // skip the 'array' type to get at the element type
    return 1 + Memory[r.value]*size_of(array_element(r.types));
  }

//: array elements are accessed using 'index'
:(scenario "index")
recipe main [
  1:integer <- copy 3:literal
  2:integer <- copy 14:literal
  3:integer <- copy 15:literal
  4:integer <- copy 16:literal
  5:integer <- index 1:array:integer, 0:literal
]
+run: instruction main/4
+run: ingredient 0 is 1
+run: ingredient 1 is 0
+run: address to copy is 2
+run: its type is 1
+mem: location 2 is 14
+run: product 0 is 14
+mem: storing 14 in location 5

:(before "End Globals")
// Operator to look at elements of arrays.
const int INDEX = 20;
:(before "End Primitive Recipe Numbers")
Recipe_number["index"] = INDEX;
assert(Next_recipe_number == INDEX);
Next_recipe_number++;
:(before "End Primitive Recipe Implementations")
case INDEX: {
  static const int ARRAY = Type_number["array"];
  trace("run") << "ingredient 0 is " << instructions[pc].ingredients[0].name;
  reagent base = canonize(instructions[pc].ingredients[0]);
  int base_address = base.value;
  assert(base.types[0] == ARRAY);
  trace("run") << "ingredient 1 is " << instructions[pc].ingredients[1].name;
  size_t offset = instructions[pc].ingredients[1].value;
  vector<type_number> element_type = array_element(base.types);
  int src = base_address + 1 + offset*size_of(element_type);
  trace("run") << "address to copy is " << src;
  trace("run") << "its type is " << element_type[0];
  reagent tmp;
  tmp.set_value(src);
  copy(element_type.begin(), element_type.end(), inserter(tmp.types, tmp.types.begin()));
  vector<int> result(read_memory(tmp));
  trace("run") << "product 0 is " << result[0];
  write_memory(instructions[pc].products[0], result);
  break;
}

:(code)
vector<type_number> array_element(const vector<type_number>& types) {
  return vector<type_number>(++types.begin(), types.end());
}

:(scenario "index_address")
recipe main [
  1:integer <- copy 3:literal
  2:integer <- copy 14:literal
  3:integer <- copy 15:literal
  4:integer <- copy 16:literal
  5:integer <- index-address 1:array:integer, 0:literal
]
+run: instruction main/4
+run: ingredient 0 is 1
+run: ingredient 1 is 0
+run: address to copy is 2
+mem: storing 2 in location 5

:(before "End Globals")
// To write to fields of records, you need their address.
const int INDEX_ADDRESS = 21;
:(before "End Primitive Recipe Numbers")
Recipe_number["index-address"] = INDEX_ADDRESS;
assert(Next_recipe_number == INDEX_ADDRESS);
Next_recipe_number++;
:(before "End Primitive Recipe Implementations")
case INDEX_ADDRESS: {
  static const int ARRAY = Type_number["array"];
  trace("run") << "ingredient 0 is " << instructions[pc].ingredients[0].name;
  reagent base = canonize(instructions[pc].ingredients[0]);
  int base_address = base.value;
  assert(base.types[0] == ARRAY);
  trace("run") << "ingredient 1 is " << instructions[pc].ingredients[1].name;
  size_t offset = instructions[pc].ingredients[1].value;
  vector<type_number> element_type = array_element(base.types);
  int src = base_address + 1 + offset*size_of(element_type);
  trace("run") << "address to copy is " << src;
  vector<int> result;
  result.push_back(src);
  trace("run") << "product 0 is " << result[0];
  write_memory(instructions[pc].products[0], result);
  break;
}
