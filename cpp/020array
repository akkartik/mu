//: Support for arrays.
:(before "End Mu Types Initialization")
//: We'll use this array as a running example:
int integer_array = Type_number["integer-array"] = Next_type_number++;
Type[integer_array].is_array = true;
Type[integer_array].element.push_back(integer);
Type[integer_array].name = "integer-array";

//: Arrays can be copied around with a single instruction just like integers,
//: no matter how large they are.

:(scenario copy_array)
recipe main [
  1:integer <- copy 3:literal
  2:integer <- copy 14:literal
  3:integer <- copy 15:literal
  4:integer <- copy 16:literal
  5:integer-array <- copy 1:integer-array
]
+run: instruction main/4
+run: ingredient 0 is 1
+mem: location 1 is 3
+mem: location 2 is 14
+mem: location 3 is 15
+mem: location 4 is 16
+mem: storing in location 5
+mem: storing in location 6
+mem: storing in location 7
+mem: storing in location 8

:(before "End size_of Cases")
if (t.is_array) {
  int base = r.value;
  if (Memory[base] == 0) return 0;
  reagent x(t.element[0]);
  x.value = base+1;
  return 1 + Memory[base]*size_of(x);
}

:(before "End Globals")
// Operator to look at elements of arrays.
const int INDEX = 20;
:(before "End Primitive Recipe Numbers")
Recipe_number["index"] = INDEX;
assert(Next_recipe_number == INDEX);
Next_recipe_number++;
:(before "End Primitive Recipe Implementations")
case INDEX: {
  trace("run") << "ingredient 0 is " << instructions[pc].ingredients[0].name;
  reagent base = canonize(instructions[pc].ingredients[0]);
  int base_address = base.value;
  int base_type = base.types[0];
  assert(Type[base_type].is_array);
  trace("run") << "ingredient 1 is " << instructions[pc].ingredients[1].name;
  size_t offset = instructions[pc].ingredients[1].value;
  int src = base_address + 1 + offset*size_of(reagent(Type[base_type].element[0]));
  trace("run") << "address to copy is " << src;
  int src_type = Type[base_type].element[0];
  trace("run") << "its type is " << src_type;
  reagent tmp(src_type);
  tmp.value = src;
  vector<int> result(read_memory(tmp));
  trace("run") << "product 0 is " << result[0];
  write_memory(instructions[pc].products[0], result);
  break;
}

:(scenario "index")
recipe main [
  1:integer <- copy 3:literal
  2:integer <- copy 14:literal
  3:integer <- copy 15:literal
  4:integer <- copy 16:literal
  5:integer <- index 1:integer-array, 0:literal
]
+run: instruction main/4
+run: ingredient 0 is 1
+run: ingredient 1 is 0
+run: address to copy is 2
+run: its type is 1
+mem: location 2 is 14
+run: product 0 is 14
+mem: storing in location 5

:(before "End Globals")
// To write to fields of records, you need their address.
const int INDEX_ADDRESS = 21;
:(before "End Primitive Recipe Numbers")
Recipe_number["index-address"] = INDEX_ADDRESS;
assert(Next_recipe_number == INDEX_ADDRESS);
Next_recipe_number++;
:(before "End Primitive Recipe Implementations")
case INDEX_ADDRESS: {
  trace("run") << "ingredient 0 is " << instructions[pc].ingredients[0].name;
  reagent base = canonize(instructions[pc].ingredients[0]);
  int base_address = base.value;
  int base_type = base.types[0];
  assert(Type[base_type].is_array);
  trace("run") << "ingredient 1 is " << instructions[pc].ingredients[1].name;
  size_t offset = instructions[pc].ingredients[1].value;
  int src = base_address + 1 + offset*size_of(reagent(Type[base_type].element[0]));
  trace("run") << "address to copy is " << src;
  vector<int> result;
  result.push_back(src);
  trace("run") << "product 0 is " << result[0];
  write_memory(instructions[pc].products[0], result);
  break;
}

:(scenario "index_address")
recipe main [
  1:integer <- copy 3:literal
  2:integer <- copy 14:literal
  3:integer <- copy 15:literal
  4:integer <- copy 16:literal
  5:integer <- index-address 1:integer-array, 0:literal
]
+run: instruction main/4
+run: ingredient 0 is 1
+run: ingredient 1 is 0
+run: address to copy is 2
+mem: storing in location 5
