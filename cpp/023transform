//: Let's start making mu more ergonomic to use. We'll create a list of tools
//: that each transform a recipe. Anybody can add to the list.
//:
//: The hope is that this framework of transform tools will provide a
//: deconstructed alternative to conventional compilers.

:(replace{} "void run(string form)")
void run(string form) {
  vector<recipe_number> tmp = add_recipes(form);
  recipes_added_by_test.insert(recipes_added_by_test.end(), tmp.begin(), tmp.end());
  transform_all();
  run(recipes_added_by_test.front());
}

:(before "End Recipe Fields")
size_t transformed_until;
  recipe() :transformed_until(-1) {}

:(before "End Types")
typedef void (*transform_fn)(recipe_number);

:(before "End Globals")
vector<transform_fn> Transform;

:(code)
void transform_all() {
  for (size_t t = 0; t < Transform.size(); ++t) {
    for (unordered_map<recipe_number, recipe>::iterator p = Recipe.begin(); p != Recipe.end(); ++p) {
      recipe& r = p->second;
      if (r.steps.empty()) continue;
      if (r.transformed_until != t-1) continue;
      (*Transform[t])(/*recipe_number*/p->first);
      r.transformed_until = t;
    }
  }
}
