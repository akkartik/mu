:(scenario "calling_recipe")
recipe main [
  f
]
recipe f [
  3:integer <- add 2:literal, 2:literal
]
+mem: storing in location 3

:(scenario "next_ingredient")
recipe main [
  f 2:literal
]
recipe f [
  12:integer <- next_ingredient
  13:integer <- add 1:literal, 12:integer
]
+run: instruction f/1
+mem: location 12 is 2
+mem: storing in location 13

:(before "End Globals")
const int NEXT_INGREDIENT = 22;
:(before "End Primitive Recipe Numbers")
Recipe_number["next_ingredient"] = NEXT_INGREDIENT;
assert(Next_recipe_number == NEXT_INGREDIENT);
Next_recipe_number++;
:(before "End Primitive Recipe Implementations")
case NEXT_INGREDIENT: {
  if (rr.calls.top().next_ingredient_to_process < rr.calls.top().incoming_atoms.size()) {
    trace("run") << "product 0 is "
        << rr.calls.top().incoming_atoms[rr.calls.top().next_ingredient_to_process][0];
    write_memory(instructions[pc].products[0],
        rr.calls.top().incoming_atoms[rr.calls.top().next_ingredient_to_process]);
    ++rr.calls.top().next_ingredient_to_process;
  }
  break;
}
