:(scenario "calling_recipe")
recipe main [
  f
]
recipe f [
  3:integer <- add 2:literal, 2:literal
]
+mem: storing in location 3

:(replace{} "End Primitive Recipe Implementations." then "default:")
default: {
  // unknown op = try to call a defined recipe
  if (Recipe.find(instructions[pc].operation) == Recipe.end()) {
    raise << "undefined operation " << instructions[pc].operation << '\n';
    break;
  }
//?   cout << "calling " << instructions[pc].operation << '\n'; //? 2
  call callee(instructions[pc].operation);
  for (vector<reagent>::iterator p = instructions[pc].ingredients.begin(); p != instructions[pc].ingredients.end(); ++p) {
//?     cout << "push back: " << p->to_string() << '\n'; //? 1
    callee.incoming_atoms.push_back(read_memory(*p));
  }
  rr.calls.push(callee);
  continue;  // not done with caller; don't increment pc
}

:(scenario "next_ingredient")
recipe main [
  f 2:literal
]
recipe f [
  12:integer <- next_ingredient
  13:integer <- add 1:literal, 12:integer
]
+run: instruction f/1
+mem: location 12 is 2
+mem: storing in location 13

:(before "End Globals")
const int NEXT_INGREDIENT = 22;
:(before "End Primitive Recipe Numbers")
Recipe_number["next_ingredient"] = NEXT_INGREDIENT;
assert(Next_recipe_number == NEXT_INGREDIENT);
Next_recipe_number++;
:(before "End Primitive Recipe Implementations")
case NEXT_INGREDIENT: {
  if (rr.calls.top().next_ingredient_to_process < rr.calls.top().incoming_atoms.size()) {
    trace("run") << "product 0 is "
        << rr.calls.top().incoming_atoms[rr.calls.top().next_ingredient_to_process][0];
    write_memory(instructions[pc].products[0],
        rr.calls.top().incoming_atoms[rr.calls.top().next_ingredient_to_process]);
    ++rr.calls.top().next_ingredient_to_process;
  }
  break;
}

:(scenario "reply")
recipe main [
  3:integer, 4:integer <- f 2:literal
]
recipe f [
  12:integer <- next_ingredient
  13:integer <- add 1:literal, 12:integer
  reply 12:integer, 13:integer
]
+run: instruction main/0
+run: result 0 is 1[2...]
+mem: storing in location 3
+run: result 1 is 1[3...]
+mem: storing in location 4

:(before "End Globals")
const int REPLY = 23;
:(before "End Primitive Recipe Numbers")
Recipe_number["reply"] = REPLY;
assert(Next_recipe_number == REPLY);
Next_recipe_number++;
:(before "End Primitive Recipe Implementations")
case REPLY: {
  vector<vector<int> > callee_results;
  for (size_t i = 0; i < instructions[pc].ingredients.size(); ++i) {
    callee_results.push_back(read_memory(instructions[pc].ingredients[i]));
  }
  rr.calls.pop();
  size_t& caller_pc = rr.calls.top().pc;
//?   cout << caller_pc << ": " << instructions[caller_pc].products.size() << " <=> " << callee_results.size(); //? 2
  assert(instructions[caller_pc].products.size() <= callee_results.size());
  for (size_t i = 0; i < instructions[caller_pc].products.size(); ++i) {
//?     cout << "AAA " << i << '\n'; //? 1
    trace("run") << "result " << i << " is " << callee_results[i].size() << "[" << callee_results[i][0] << "...]";
    write_memory(instructions[caller_pc].products[i], callee_results[i]);
  }
  ++caller_pc;
  break;
}
