//: Once a set of recipes is loaded, it can be filtered through an extensible
//: list of 'transforms'.
//:
//: The hope is that this framework of transform tools will provide a
//: deconstructed alternative to conventional compilers.

:(before "End Recipe Fields")
size_t transformed_until;
  recipe() :transformed_until(-1) {}

:(before "End Types")
typedef void (*transform_fn)(recipe_number);

:(before "End Globals")
vector<transform_fn> Transform;

:(code)
void transform_all() {
  for (size_t t = 0; t < Transform.size(); ++t) {
    for (unordered_map<recipe_number, recipe>::iterator p = Recipe.begin(); p != Recipe.end(); ++p) {
      recipe& r = p->second;
      if (r.steps.empty()) continue;
      if (r.transformed_until != t-1) continue;
      (*Transform[t])(/*recipe_number*/p->first);
      r.transformed_until = t;
    }
  }
  parse_int_reagents();  // do this after all other transforms have run
}

void parse_int_reagents() {
//?   cout << "parse_int_reagents\n"; //? 1
  for (unordered_map<recipe_number, recipe>::iterator p = Recipe.begin(); p != Recipe.end(); ++p) {
    recipe& r = p->second;
    if (r.steps.empty()) continue;
    for (size_t index = 0; index < r.steps.size(); ++index) {
      instruction& inst = r.steps[index];
      for (size_t i = 0; i < inst.ingredients.size(); ++i) {
        populate_value(inst.ingredients[i]);
      }
      for (size_t i = 0; i < inst.products.size(); ++i) {
        populate_value(inst.products[i]);
      }
    }
  }
}

void populate_value(reagent& r) {
  if (r.initialized) return;
  char* end = NULL;
  int result = strtol(r.name.c_str(), &end, /*any base*/0);
  if (*end != '\0') return;
//?   cout << "setting value\n"; //? 1
  r.value = result;
}
