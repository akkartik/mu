//: Some instructions can take string literals for convenience.
//:
//: Instead of quotes, we'll use [] to delimit strings. That'll reduce the
//: need for escaping since we can support nested brackets. And we can also
//: imagine that 'recipe' might one day itself be defined in mu, doing its own
//: parsing.

//: First extend the mu parser to support string literals.
:(scenario "string_literal")
recipe main [
  1:address:array:character <- new [abc def]
]
+parse:   ingredient: {name: "abc def", value: 0, type: 0, properties: ["abc def": "literal-string"]}

:(scenario "string_literal_with_colons")
recipe main [
  1:address:array:character <- new [abc:def/ghi]
]
+parse:   ingredient: {name: "abc:def/ghi", value: 0, type: 0, properties: ["abc:def/ghi": "literal-string"]}

:(before "End Mu Types Initialization")
Type_number["literal-string"] = 0;

:(after "string next_word(istream& in)")
if (in.peek() == '[') return slurp_quoted(in);

:(code)
string slurp_quoted(istream& in) {
  assert(!in.eof());
  assert(in.peek() == '[');
  ostringstream out;
  int size = 0;
  while (!in.eof()) {
    char c = in.get();
//?     cout << c << '\n'; //? 1
    out << c;
//?     cout << out.str() << "$\n"; //? 1
    if (c == '[') ++size;
    if (c == ']') --size;
    if (size == 0) break;
  }
  return out.str();
}

:(after "reagent::reagent(string s)")
//?   cout << s[0] << '\n'; //? 1
  if (s[0] == '[') {
    assert(s[s.size()-1] == ']');
    // delete [] delimiters
    s.erase(0, 1);
    s.erase(s.size()-1, s.size());
    name = s;
    types.push_back(0);
    properties.push_back(pair<string, vector<string> >(name, vector<string>()));
    properties.back().second.push_back("literal-string");
    return;
  }

:(scenario "string_literal_nested")
recipe main [
  1:address:array:character <- new [abc [def]]
]
+parse:   ingredient: {name: "abc [def]", value: 0, type: 0, properties: ["abc [def]": "literal-string"]}

//: Next, extend 'new' to handle a string literal argument.
:(scenario "new_string")
recipe main [
  1:address:array:character <- new [abc def]
  2:character <- index 1:address:array:character/deref, 5:literal
]
# integer code for 'e'
+mem: storing 101 in location 2

:(before "End Mu Types Initialization")
Type_number["character"] = Next_type_number++;

:(after "case NEW" following "Primitive Recipe Implementations")
if (instructions[pc].ingredients[0].properties[0].second[0] == "literal-string") {
  // allocate an array just large enough for it
  vector<int> result;
  result.push_back(Current_routine->alloc);
  write_memory(instructions[pc].products[0], result);
  // assume that all characters fit in a single location
//?   cout << "new string literal: " << instructions[pc].ingredients[0].name << '\n'; //? 1
  Memory[Current_routine->alloc++] = instructions[pc].ingredients[0].name.size();
  for (size_t i = 0; i < instructions[pc].ingredients[0].name.size(); ++i) {
    Memory[Current_routine->alloc++] = instructions[pc].ingredients[0].name[i];
  }
  // mu strings are not null-terminated in memory
  break;
}
