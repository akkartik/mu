//: Spaces help isolate functions from each other. You can create them at will,
//: and all addresses in arguments are implicitly based on the 'default-space'
//: (unless they have the /raw property)

:(scenarios run)
:(scenario "set_default_space")
# if default-space is 10, and if an array of 5 locals lies from location 11 to 15 (inclusive),
# then location 0 is really location 11, location 1 is really location 12, and so on.
recipe main [
  10:integer <- copy 5:literal  # pretend array; in practice we'll use new
  default-space:address:space <- copy 10:literal
  1:integer <- copy 23:literal
]
+mem: storing 23 in location 12

:(scenario "deref_sidesteps_default_space")
recipe main [
  # pretend pointer from outside
  7:integer <- copy 34:literal
  # pretend array
  10:integer <- copy 5:literal
  # actual start of this function
  default-space:address:space <- copy 10:literal
  1:address:integer <- copy 7:literal
  8:integer/raw <- copy 1:address:integer/deref
]
+mem: storing 34 in location 8

:(before "End call Fields")
size_t default_space;
:(replace "call(recipe_number r) :running_recipe(r)")
call(recipe_number r) :running_recipe(r), pc(0), next_ingredient_to_process(0), default_space(0) {}

:(replace "reagent r = x" following "reagent canonize(reagent x)")
reagent r = absolutize(x);
:(code)
reagent absolutize(reagent x) {
//?   cout << "absolutize " << x.to_string() << '\n'; //? 2
//?   cout << is_raw(x) << '\n'; //? 1
  if (is_raw(x) || is_dummy(x)) return x;
//?   cout << "not raw: " << x.to_string() << '\n'; //? 1
  assert(x.initialized);
  reagent r = x;
  r.set_value(address(r.value, space(r)));
//?   cout << "after absolutize: " << r.value << '\n'; //? 1
  r.properties.push_back(pair<string, vector<string> >("raw", vector<string>()));
  assert(is_raw(r));
  return r;
}
:(before "return result" following "reagent deref(reagent x)")
result.properties.push_back(pair<string, vector<string> >("raw", vector<string>()));

:(code)
int space(const reagent& x) {
  return Current_routine.calls.top().default_space;
}

int address(int offset, int base) {
  if (base == 0) return offset;  // raw
  if (offset >= Memory[base]) {
    // todo: test
    raise << "location " << offset << " is out of bounds " << Memory[base] << '\n';
  }
  return base+1 + offset;
}

:(after "void write_memory(reagent x, vector<int> data)")
  if (x.name == "default-space") {
    assert(data.size() == 1);
    Current_routine.calls.top().default_space = data[0];
//?     cout << "AAA " << Current_routine.calls.top().default_space << '\n'; //? 1
    return;
  }

:(scenario "get_default_space")
recipe main [
  default-space:address:space <- copy 10:literal
  1:integer/raw <- copy default-space:address:space
]
+mem: storing 10 in location 1

:(after "vector<int> read_memory(reagent x)")
  if (x.name == "default-space") {
    vector<int> result;
    result.push_back(Current_routine.calls.top().default_space);
    return result;
  }
