// Support for records.
:(before "End Mu Types")
// We'll use this record as a running example, with two integer fields
int point = Type_number["point"] = Next_type_number++;
Type[point].size = 2;
Type[point].is_record = true;
vector<type_number> i;
i.push_back(integer);
Type[point].elements.push_back(i);
Type[point].elements.push_back(i);

:(scenario copy_multiple_locations)
# Records can be copied around with a single instruction just like integers,
# no matter how large they are.
recipe main [
  1:integer <- copy 34:literal
  2:integer <- copy 35:literal
  3:point <- copy 1:point
]
+run: ingredient 0 is 1
+mem: location 1 is 34
+mem: location 2 is 35
+mem: storing in location 3
+mem: storing in location 4

:(before "End Globals")
// Operator to look at fields of records.
const int GET = 18;
:(before "End Primitive Recipe Numbers")
Recipe_number["get"] = GET;
Next_recipe_number++;
:(before "End Primitive Recipe Implementations")
case GET: {
  trace("run") << "ingredient 0 is " << instructions[pc].ingredients[0].name;
  int base_address = to_int(instructions[pc].ingredients[0].name);
  int base_type = instructions[pc].ingredients[0].types[0];
  trace("run") << "ingredient 1 is " << instructions[pc].ingredients[1].name;
  assert(instructions[pc].ingredients[1].types.size() == 1);
  assert(instructions[pc].ingredients[1].types[0] == 0);  // must be literal
  size_t offset = to_int(instructions[pc].ingredients[1].name);
  int src = base_address;
  for (size_t i = 0; i < offset; ++i) {
    src += size_of(reagent(Type[base_type].elements[i][0]));
  }
  trace("run") << "address to copy is " << src;
  assert(Type[base_type].is_record);
  assert(Type[base_type].elements.size() > offset);
  int src_type = Type[base_type].elements[offset][0];
  trace("run") << "its type is " << src_type;
  ostringstream s;
  s << src;
  reagent tmp(s.str());
  tmp.types.push_back(src_type);
  vector<int> result(read_memory(tmp));
  trace("run") << "product 0 is " << result[0];
  write_memory(instructions[pc].products[0], result);
  break;
}

:(scenario "get")
recipe main [
  12:integer <- copy 34:literal
  13:integer <- copy 35:literal
  15:integer <- get 12:point, 1:offset
]
+run: instruction 2
+run: ingredient 0 is 12
+run: ingredient 1 is 1
+run: address to copy is 13
+run: its type is 1
+mem: location 13 is 35
+run: product 0 is 35
+mem: storing in location 15

:(before "End Mu Types")
// A more complex record, containing another record.
int point_integer = Type_number["point-integer"] = Next_type_number++;
Type[point_integer].size = 2;
Type[point_integer].is_record = true;
vector<type_number> p2;
p2.push_back(point);
Type[point_integer].elements.push_back(p2);
vector<type_number> i2;
i2.push_back(integer);
Type[point_integer].elements.push_back(i2);
:(scenario "get_handles_record_fields")
recipe main [
  12:integer <- copy 34:literal
  13:integer <- copy 35:literal
  14:integer <- copy 36:literal
  15:integer <- get 12:point-integer, 1:offset
]
+run: instruction 2
+run: ingredient 0 is 12
+run: ingredient 1 is 1
+run: address to copy is 14
+run: its type is 1
+mem: location 14 is 36
+run: product 0 is 36
+mem: storing in location 15

:(before "End Globals")
// To write to fields of records, you need their address.
const int GET_ADDRESS = 19;
:(before "End Primitive Recipe Numbers")
Recipe_number["get-address"] = GET_ADDRESS;
Next_recipe_number++;
:(before "End Primitive Recipe Implementations")
case GET_ADDRESS: {
  trace("run") << "ingredient 0 is " << instructions[pc].ingredients[0].name;
  int base_address = to_int(instructions[pc].ingredients[0].name);
  trace("run") << "ingredient 1 is " << instructions[pc].ingredients[1].name;
  assert(instructions[pc].ingredients[1].types.size() == 1);
  assert(instructions[pc].ingredients[1].types[0] == 0);  // must be literal
  size_t offset = to_int(instructions[pc].ingredients[1].name);
  int src = base_address+offset;
  trace("run") << "address to copy is " << src;
  vector<int> result;
  result.push_back(src);
  trace("run") << "product 0 is " << result[0];
  write_memory(instructions[pc].products[0], result);
  break;
}

:(scenario "get_address")
recipe main [
  12:integer <- copy 34:literal
  13:integer <- copy 35:literal
  15:address:integer <- get-address 12:point, 1:offset
]
+run: instruction 2
+run: ingredient 0 is 12
+run: ingredient 1 is 1
+run: address to copy is 13
+mem: storing in location 15
