<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>Mu - 078run_interactive.cc</title>
<meta name="Generator" content="Vim/7.4">
<meta name="plugin-version" content="vim7.4_v1">
<meta name="syntax" content="cpp">
<meta name="settings" content="use_css,pre_wrap,no_foldcolumn,expand_tabs,prevent_copy=">
<meta name="colorscheme" content="minimal">
<style type="text/css">
<!--
pre { white-space: pre-wrap; font-family: monospace; color: #eeeeee; background-color: #080808; }
body { font-family: monospace; color: #eeeeee; background-color: #080808; }
* { font-size: 1.05em; }
.cSpecial { color: #008000; }
.Constant { color: #00a0a0; }
.Comment { color: #9090ff; }
.Delimiter { color: #a04060; }
.SalientComment { color: #00ffff; }
.Comment { color: #9090ff; }
.Identifier { color: #008080; }
-->
</style>

<script type='text/javascript'>
<!--

-->
</script>
</head>
<body>
<pre id='vimCodeElement'>
<span class="Comment">//: Helper for the repl.</span>

<span class="Delimiter">:(before &quot;End Primitive Recipe Declarations&quot;)</span>
RUN_INTERACTIVE<span class="Delimiter">,</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Numbers&quot;)</span>
Recipe_number[<span class="Constant">&quot;run-interactive&quot;</span>] = RUN_INTERACTIVE<span class="Delimiter">;</span>
<span class="CommentedCode">//? cerr &lt;&lt; &quot;run-interactive: &quot; &lt;&lt; RUN_INTERACTIVE &lt;&lt; '\n'; //? 1</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Implementations&quot;)</span>
case RUN_INTERACTIVE: <span class="Delimiter">{</span>
  assert<span class="Delimiter">(</span>scalar<span class="Delimiter">(</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">)));</span>
<span class="CommentedCode">//?   cerr &lt;&lt; &quot;AAA 0\n&quot;; //? 1</span>
  run_interactive<span class="Delimiter">(</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">));</span>
<span class="CommentedCode">//?   cerr &lt;&lt; &quot;ZZZ\n&quot;; //? 1</span>
  <span class="Identifier">continue</span><span class="Delimiter">;</span>  <span class="Comment">// not done with caller; don't increment current_step_index()</span>
<span class="Delimiter">}</span>

<span class="Delimiter">:(code)</span>
<span class="Comment">// manual tests:</span>
<span class="Comment">//  empty string (excluding whitespace and comments) does nothing</span>
<span class="Comment">//  ctrl-d</span>
<span class="Comment">//  just an integer (excluding whitespace and comments) prints value of that location in memory</span>
<span class="Comment">//  instruction executes</span>
<span class="Comment">//  backspace at start begins new attempt</span>
void run_interactive<span class="Delimiter">(</span>long long int address<span class="Delimiter">)</span> <span class="Delimiter">{</span>
<span class="CommentedCode">//?   tb_shutdown(); //? 1</span>
  long long int size = Memory[address]<span class="Delimiter">;</span>
  if <span class="Delimiter">(</span>size == <span class="Constant">0</span><span class="Delimiter">)</span> <span class="Delimiter">{</span>
    ++current_step_index<span class="Delimiter">();</span>
    <span class="Identifier">return</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  ostringstream tmp<span class="Delimiter">;</span>
  for <span class="Delimiter">(</span>long long int curr = address+<span class="Constant">1</span><span class="Delimiter">;</span> curr &lt; address+size<span class="Delimiter">;</span> ++curr<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Comment">// todo: unicode</span>
    tmp &lt;&lt; <span class="Delimiter">(</span>char<span class="Delimiter">)(</span>int<span class="Delimiter">)</span>Memory[curr]<span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
<span class="CommentedCode">//?   cerr &lt;&lt; size &lt;&lt; ' ' &lt;&lt; Memory[address+size] &lt;&lt; '\n'; //? 1</span>
  assert<span class="Delimiter">(</span>Memory[address+size] == <span class="Constant">10</span><span class="Delimiter">);</span>  <span class="Comment">// skip the newline</span>
  if <span class="Delimiter">(</span>Recipe_number<span class="Delimiter">.</span>find<span class="Delimiter">(</span><span class="Constant">&quot;interactive&quot;</span><span class="Delimiter">)</span> == Recipe_number<span class="Delimiter">.</span>end<span class="Delimiter">())</span>
    Recipe_number[<span class="Constant">&quot;interactive&quot;</span>] = Next_recipe_number++<span class="Delimiter">;</span>
  string command = trim<span class="Delimiter">(</span>strip_comments<span class="Delimiter">(</span>tmp<span class="Delimiter">.</span>str<span class="Delimiter">()));</span>
  if <span class="Delimiter">(</span>command<span class="Delimiter">.</span>empty<span class="Delimiter">())</span> <span class="Delimiter">{</span>
    ++current_step_index<span class="Delimiter">();</span>
    <span class="Identifier">return</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  if <span class="Delimiter">(</span>is_integer<span class="Delimiter">(</span>command<span class="Delimiter">))</span> <span class="Delimiter">{</span>
    print_value_of_location_as_response<span class="Delimiter">(</span>to_integer<span class="Delimiter">(</span>command<span class="Delimiter">));</span>
    ++current_step_index<span class="Delimiter">();</span>
    <span class="Identifier">return</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
<span class="CommentedCode">//?   exit(0); //? 1</span>
  if <span class="Delimiter">(</span>Name[Recipe_number[<span class="Constant">&quot;interactive&quot;</span>]]<span class="Delimiter">.</span>find<span class="Delimiter">(</span>command<span class="Delimiter">)</span> != Name[Recipe_number[<span class="Constant">&quot;interactive&quot;</span>]]<span class="Delimiter">.</span>end<span class="Delimiter">())</span> <span class="Delimiter">{</span>
    print_value_of_location_as_response<span class="Delimiter">(</span>Name[Recipe_number[<span class="Constant">&quot;interactive&quot;</span>]][command]<span class="Delimiter">);</span>
    ++current_step_index<span class="Delimiter">();</span>
    <span class="Identifier">return</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
<span class="CommentedCode">//?   tb_shutdown(); //? 1</span>
<span class="CommentedCode">//?   cerr &lt;&lt; command; //? 1</span>
<span class="CommentedCode">//?   exit(0); //? 1</span>
<span class="CommentedCode">//?   cerr &lt;&lt; &quot;AAA 1\n&quot;; //? 1</span>
  Recipe<span class="Delimiter">.</span>erase<span class="Delimiter">(</span>Recipe_number[<span class="Constant">&quot;interactive&quot;</span>]<span class="Delimiter">);</span>
  <span class="Comment">// call run(string) but without the scheduling</span>
<span class="CommentedCode">//?   cerr &lt;&lt; (&quot;recipe interactive [\n&quot;+command+&quot;\n]\n&quot;); //? 1</span>
  load<span class="Delimiter">(</span><span class="Constant">&quot;recipe interactive [</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>+command+<span class="Constant">&quot;</span><span class="cSpecial">\n</span><span class="Constant">]</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span><span class="Delimiter">);</span>
  transform_all<span class="Delimiter">();</span>
<span class="CommentedCode">//?   cerr &lt;&lt; &quot;names: &quot; &lt;&lt; Name[Recipe_number[&quot;interactive&quot;]].size() &lt;&lt; &quot;; &quot;; //? 1</span>
<span class="CommentedCode">//?   cerr &lt;&lt; &quot;steps: &quot; &lt;&lt; Recipe[Recipe_number[&quot;interactive&quot;]].steps.size() &lt;&lt; &quot;; &quot;; //? 1</span>
<span class="CommentedCode">//?   cerr &lt;&lt; &quot;interactive transformed_until: &quot; &lt;&lt; Recipe[Recipe_number[&quot;interactive&quot;]].transformed_until &lt;&lt; '\n'; //? 1</span>
  Current_routine<span class="Delimiter">-&gt;</span>calls<span class="Delimiter">.</span>push_front<span class="Delimiter">(</span>call<span class="Delimiter">(</span>Recipe_number[<span class="Constant">&quot;interactive&quot;</span>]<span class="Delimiter">));</span>
<span class="Delimiter">}</span>

string strip_comments<span class="Delimiter">(</span>string in<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  ostringstream result<span class="Delimiter">;</span>
<span class="CommentedCode">//?   cerr &lt;&lt; in; //? 1</span>
  for <span class="Delimiter">(</span>long long int i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; SIZE<span class="Delimiter">(</span>in<span class="Delimiter">);</span> ++i<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    if <span class="Delimiter">(</span>in<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">)</span> != <span class="Constant">'#'</span><span class="Delimiter">)</span> <span class="Delimiter">{</span>
      result &lt;&lt; in<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">);</span>
    <span class="Delimiter">}</span>
    else <span class="Delimiter">{</span>
      while <span class="Delimiter">(</span>i &lt; SIZE<span class="Delimiter">(</span>in<span class="Delimiter">)</span> &amp;&amp; in<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">)</span> != <span class="cSpecial">'\n'</span><span class="Delimiter">)</span>
        ++i<span class="Delimiter">;</span>
      if <span class="Delimiter">(</span>i &lt; SIZE<span class="Delimiter">(</span>in<span class="Delimiter">)</span> &amp;&amp; in<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">)</span> == <span class="cSpecial">'\n'</span><span class="Delimiter">)</span> ++i<span class="Delimiter">;</span>
    <span class="Delimiter">}</span>
  <span class="Delimiter">}</span>
<span class="CommentedCode">//?   cerr &lt;&lt; &quot;ZZZ&quot;; //? 1</span>
  <span class="Identifier">return</span> result<span class="Delimiter">.</span>str<span class="Delimiter">();</span>
<span class="Delimiter">}</span>

void print_value_of_location_as_response<span class="Delimiter">(</span>long long int address<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Comment">// convert to string</span>
  ostringstream out<span class="Delimiter">;</span>
  out &lt;&lt; <span class="Constant">&quot;=&gt; &quot;</span> &lt;&lt; Memory[address]<span class="Delimiter">;</span>
  string result = out<span class="Delimiter">.</span>str<span class="Delimiter">();</span>
  <span class="Comment">// handle regular I/O</span>
  if <span class="Delimiter">(</span>!tb_is_active<span class="Delimiter">())</span> <span class="Delimiter">{</span>
    cerr &lt;&lt; result &lt;&lt; <span class="cSpecial">'\n'</span><span class="Delimiter">;</span>
    <span class="Identifier">return</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Comment">// raw I/O; use termbox to print</span>
  long long int bound = SIZE<span class="Delimiter">(</span>result<span class="Delimiter">);</span>
  if <span class="Delimiter">(</span>bound &gt; tb_width<span class="Delimiter">())</span> bound = tb_width<span class="Delimiter">();</span>
  for <span class="Delimiter">(</span>long long int i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; bound<span class="Delimiter">;</span> ++i<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    tb_change_cell<span class="Delimiter">(</span>i<span class="Delimiter">,</span> Display_row<span class="Delimiter">,</span> result<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">),</span> <span class="Comment">/*</span><span class="Comment">computer's color</span><span class="Comment">*/</span><span class="Constant">245</span><span class="Delimiter">,</span> TB_BLACK<span class="Delimiter">);</span>
  <span class="Delimiter">}</span>
  <span class="Comment">// newline</span>
  if <span class="Delimiter">(</span>Display_row &lt; tb_height<span class="Delimiter">()</span>-<span class="Constant">1</span><span class="Delimiter">)</span>
    ++Display_row<span class="Delimiter">;</span>
  Display_column = <span class="Constant">0</span><span class="Delimiter">;</span>
  tb_set_cursor<span class="Delimiter">(</span>Display_column<span class="Delimiter">,</span> Display_row<span class="Delimiter">);</span>
  tb_present<span class="Delimiter">();</span>
<span class="Delimiter">}</span>

<span class="SalientComment">//:: debugging tool</span>

<span class="Delimiter">:(before &quot;End Primitive Recipe Declarations&quot;)</span>
_RUN_DEPTH<span class="Delimiter">,</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Numbers&quot;)</span>
Recipe_number[<span class="Constant">&quot;$run-depth&quot;</span>] = _RUN_DEPTH<span class="Delimiter">;</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Implementations&quot;)</span>
case _RUN_DEPTH: <span class="Delimiter">{</span>
  cerr &lt;&lt; Current_routine<span class="Delimiter">-&gt;</span>calls<span class="Delimiter">.</span>size<span class="Delimiter">();</span>
  <span class="Identifier">break</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
