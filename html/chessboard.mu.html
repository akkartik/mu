<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>Mu - chessboard.mu</title>
<meta name="Generator" content="Vim/7.4">
<meta name="plugin-version" content="vim7.4_v1">
<meta name="syntax" content="none">
<meta name="settings" content="use_css,pre_wrap,no_foldcolumn,expand_tabs,prevent_copy=">
<meta name="colorscheme" content="minimal">
<style type="text/css">
<!--
pre { white-space: pre-wrap; font-family: monospace; color: #eeeeee; background-color: #080808; }
body { font-family: monospace; color: #eeeeee; background-color: #080808; }
* { font-size: 1.05em; }
.SalientComment { color: #00ffff; }
.CommentedCode { color: #6c6c6c; }
.Underlined { color: #c000c0; text-decoration: underline; }
.Comment { color: #9090ff; }
.Special { color: #ff6060; }
.Identifier { color: #804000; }
-->
</style>

<script type='text/javascript'>
<!--

-->
</script>
</head>
<body>
<pre id='vimCodeElement'>
<span class="Comment"># Chessboard program: you type in moves in algebraic notation, and it'll</span>
<span class="Comment"># display the position after each move.</span>

<span class="Comment"># recipes are mu's names for functions</span>
recipe main [
  open-console  <span class="Comment"># take control of screen, keyboard and mouse</span>

  <span class="Comment"># The chessboard recipe takes keyboard and screen objects as 'ingredients'.</span>
  #
  <span class="Comment"># In mu it is good form (though not required) to explicitly show the</span>
  <span class="Comment"># hardware you rely on.</span>
  #
  <span class="Comment"># The chessboard also returns the same keyboard and screen objects. In mu it</span>
  <span class="Comment"># is good form to not modify ingredients of a recipe unless they are also</span>
  <span class="Comment"># results. Here we clearly modify both keyboard and screen, so we return</span>
  <span class="Comment"># both.</span>
  #
  <span class="Comment"># Here the console and screen are both 0, which usually indicates real</span>
  <span class="Comment"># hardware rather than a fake for testing as you'll see below.</span>
  0/screen, 0/console<span class="Special"> &lt;- </span>chessboard 0/screen, 0/console

  close-console  <span class="Comment"># cleanup screen, keyboard and mouse</span>
]

<span class="SalientComment">## But enough about mu. Here's what it looks like to run the chessboard program.</span>

scenario <span class="Identifier">print</span>-board-and-<span class="Identifier">read</span>-move [
  $close-trace  <span class="Comment"># administrivia: most scenarios save and check traces, but this one gets too large/slow</span>
  <span class="Comment"># we'll make the screen really wide because the program currently prints out a long line</span>
  <span class="Identifier">assume</span>-screen 120/width, 20/height
  <span class="Comment"># initialize keyboard to type in a move</span>
  <span class="Identifier">assume</span>-console [
    <span class="Identifier">type</span> [a2-a4
]
  ]
  run [
    screen:address, console:address<span class="Special"> &lt;- </span>chessboard screen:address, console:address
    <span class="Comment"># icon for the cursor</span>
    screen<span class="Special"> &lt;- </span><span class="Identifier">print</span>-character screen, 9251/␣
  ]
  screen-should-contain [
  <span class="Comment">#            1         2         3         4         5         6         7         8         9         10        11</span>
  <span class="Comment">#  012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789</span>
    .Stupid text-mode chessboard. White pieces <span class="Identifier">in</span> uppercase; black pieces <span class="Identifier">in</span> lowercase. No checking for legal moves.         .
    .                                                                                                                        .
    .8 | r n b q k b n r                                                                                                     .
    .7 | p p p p p p p p                                                                                                     .
    .6 |                                                                                                                     .
    .5 |                                                                                                                     .
    .4 | P                                                                                                                   .
    .3 |                                                                                                                     .
    .2 |   P P P P P P P                                                                                                     .
    .1 | R N B Q K B N R                                                                                                     .
    .  +----------------                                                                                                     .
    .    a b c d e f g h                                                                                                     .
    .                                                                                                                        .
    .Type <span class="Identifier">in</span> your move as &lt;from square&gt;-&lt;to square&gt;. For example: 'a2-a4'. Then press &lt;enter&gt;.                               .
    .                                                                                                                        .
    .Hit 'q' to exit.                                                                                                        .
    .                                                                                                                        .
    .move: ␣                                                                                                                 .
    .                                                                                                                        .
    .                                                                                                                        .
  ]
]

<span class="SalientComment">## Here's how 'chessboard' is implemented.</span>

recipe chessboard [
  <span class="Underlined">local</span>-scope
  screen:address<span class="Special"> &lt;- </span>next-ingredient
  console:address<span class="Special"> &lt;- </span>next-ingredient
  board:address:<span class="Identifier">array</span>:address:<span class="Identifier">array</span>:character<span class="Special"> &lt;- </span>initial-position
  <span class="Comment"># hook up stdin</span>
  stdin:address:channel<span class="Special"> &lt;- </span><span class="Identifier">new</span>-channel 10/capacity
  start-running send-keys-to-channel:recipe, console, stdin, screen
  <span class="Comment"># buffer lines in stdin</span>
  buffered-stdin:address:channel<span class="Special"> &lt;- </span><span class="Identifier">new</span>-channel 10/capacity
  start-running buffer-lines:recipe, stdin, buffered-stdin
  {
    msg:address:<span class="Identifier">array</span>:character<span class="Special"> &lt;- </span><span class="Identifier">new</span> [Stupid text-mode chessboard. White pieces <span class="Identifier">in</span> uppercase; black pieces <span class="Identifier">in</span> lowercase. No checking for legal moves.
]
    <span class="Identifier">print</span>-string screen, msg
    cursor-to-next-line screen
    <span class="Identifier">print</span>-board screen, board
    cursor-to-next-line screen
    msg<span class="Special"> &lt;- </span><span class="Identifier">new</span> [Type <span class="Identifier">in</span> your move as &lt;from square&gt;-&lt;to square&gt;. For example: 'a2-a4'. Then press &lt;enter&gt;.
]
    <span class="Identifier">print</span>-string screen, msg
    cursor-to-next-line screen
    msg<span class="Special"> &lt;- </span><span class="Identifier">new</span> [Hit 'q' to exit.
]
    <span class="Identifier">print</span>-string screen, msg
    {
      cursor-to-next-line screen
      msg<span class="Special"> &lt;- </span><span class="Identifier">new</span> [move: ]
      <span class="Identifier">print</span>-string screen, msg
      m:address:move, <span class="Identifier">quit</span>:boolean, <span class="Identifier">error</span>:boolean<span class="Special"> &lt;- </span><span class="Identifier">read</span>-move buffered-stdin, screen
      break-if <span class="Identifier">quit</span>, +<span class="Identifier">quit</span>:label
      buffered-stdin<span class="Special"> &lt;- </span>clear-channel buffered-stdin  <span class="Comment"># cleanup after error. todo: test this?</span>
      loop-if <span class="Identifier">error</span>
    }
    board<span class="Special"> &lt;- </span>make-move board, m
    clear-screen screen
    loop
  }
  +<span class="Identifier">quit</span>
]

<span class="SalientComment">## a board is an array of files, a file is an array of characters (squares)</span>

recipe <span class="Identifier">new</span>-board [
  <span class="Underlined">local</span>-scope
  initial-position:address:<span class="Identifier">array</span>:number<span class="Special"> &lt;- </span>next-ingredient
  <span class="Comment"># assert(length(initial-position) == 64)</span>
  len:number<span class="Special"> &lt;- </span><span class="Identifier">length</span> *initial-position
  correct-<span class="Identifier">length</span>?:boolean<span class="Special"> &lt;- </span>equal len, 64
  <span class="Identifier">assert</span> correct-<span class="Identifier">length</span>?, [chessboard had incorrect size]
  <span class="Comment"># board is an array of pointers to files; file is an array of characters</span>
  board:address:<span class="Identifier">array</span>:address:<span class="Identifier">array</span>:character<span class="Special"> &lt;- </span><span class="Identifier">new</span> location:<span class="Identifier">type</span>, 8
  col:number<span class="Special"> &lt;- </span><span class="Identifier">copy</span> 0
  {
    done?:boolean<span class="Special"> &lt;- </span>equal col, 8
    break-if done?
    file:address:address:<span class="Identifier">array</span>:character<span class="Special"> &lt;- </span>index-address *board, col
    *file<span class="Special"> &lt;- </span><span class="Identifier">new</span>-file initial-position, col
    col<span class="Special"> &lt;- </span>add col, 1
    loop
  }
  reply board
]

recipe <span class="Identifier">new</span>-file [
  <span class="Underlined">local</span>-scope
  position:address:<span class="Identifier">array</span>:number<span class="Special"> &lt;- </span>next-ingredient
  index:number<span class="Special"> &lt;- </span>next-ingredient
  index<span class="Special"> &lt;- </span>multiply index, 8
  result:address:<span class="Identifier">array</span>:character<span class="Special"> &lt;- </span><span class="Identifier">new</span> character:<span class="Identifier">type</span>, 8
  row:number<span class="Special"> &lt;- </span><span class="Identifier">copy</span> 0
  {
    done?:boolean<span class="Special"> &lt;- </span>equal row, 8
    break-if done?
    dest:address:character<span class="Special"> &lt;- </span>index-address *result, row
    *dest<span class="Special"> &lt;- </span>index *position, index
    row<span class="Special"> &lt;- </span>add row, 1
    index<span class="Special"> &lt;- </span>add index, 1
    loop
  }
  reply result
]

recipe <span class="Identifier">print</span>-board [
  <span class="Underlined">local</span>-scope
  screen:address<span class="Special"> &lt;- </span>next-ingredient
  board:address:<span class="Identifier">array</span>:address:<span class="Identifier">array</span>:character<span class="Special"> &lt;- </span>next-ingredient
  row:number<span class="Special"> &lt;- </span><span class="Identifier">copy</span> 7  <span class="Comment"># start printing from the top of the board</span>
  <span class="Comment"># print each row</span>
  {
    done?:boolean<span class="Special"> &lt;- </span>lesser-than row, 0
    break-if done?
    <span class="Comment"># print rank number as a legend</span>
    rank:number<span class="Special"> &lt;- </span>add row, 1
    <span class="Identifier">print</span>-integer screen, rank
    s:address:<span class="Identifier">array</span>:character<span class="Special"> &lt;- </span><span class="Identifier">new</span> [ | ]
    <span class="Identifier">print</span>-string screen, s
    <span class="Comment"># print each square in the row</span>
    col:number<span class="Special"> &lt;- </span><span class="Identifier">copy</span> 0
    {
      done?:boolean<span class="Special"> &lt;- </span>equal col:number, 8
      break-if done?:boolean
      f:address:<span class="Identifier">array</span>:character<span class="Special"> &lt;- </span>index *board, col
      c:character<span class="Special"> &lt;- </span>index *f, row
      <span class="Identifier">print</span>-character screen, c
      <span class="Identifier">print</span>-character screen, 32/space
      col<span class="Special"> &lt;- </span>add col, 1
      loop
    }
    row<span class="Special"> &lt;- </span>subtract row, 1
    cursor-to-next-line screen
    loop
  }
  <span class="Comment"># print file letters as legend</span>
  s<span class="Special"> &lt;- </span><span class="Identifier">new</span> [  +----------------]
  <span class="Identifier">print</span>-string screen, s
  screen<span class="Special"> &lt;- </span>cursor-to-next-line screen
  s<span class="Special"> &lt;- </span><span class="Identifier">new</span> [    a b c d e f g h]
  screen<span class="Special"> &lt;- </span><span class="Identifier">print</span>-string screen, s
  screen<span class="Special"> &lt;- </span>cursor-to-next-line screen
]

<span class="Comment"># board:address:array:address:array:character &lt;- initial-position</span>
recipe initial-position [
  <span class="Underlined">local</span>-scope
  <span class="Comment"># layout in memory (in raster order):</span>
  <span class="Comment">#   R P _ _ _ _ p r</span>
  <span class="Comment">#   N P _ _ _ _ p n</span>
  <span class="Comment">#   B P _ _ _ _ p b</span>
  <span class="Comment">#   Q P _ _ _ _ p q</span>
  <span class="Comment">#   K P _ _ _ _ p k</span>
  <span class="Comment">#   B P _ _ _ _ p B</span>
  <span class="Comment">#   N P _ _ _ _ p n</span>
  <span class="Comment">#   R P _ _ _ _ p r</span>
  initial-position:address:<span class="Identifier">array</span>:number<span class="Special"> &lt;- </span><span class="Identifier">new</span>-<span class="Identifier">array</span> 82/R, 80/P, 32/blank, 32/blank, 32/blank, 32/blank, 112/p, 114/r, 78/N, 80/P, 32/blank, 32/blank, 32/blank, 32/blank, 112/p, 110/n, 66/B, 80/P, 32/blank, 32/blank, 32/blank, 32/blank, 112/p, 98/b, 81/Q, 80/P, 32/blank, 32/blank, 32/blank, 32/blank, 112/p, 113/q, 75/K, 80/P, 32/blank, 32/blank, 32/blank, 32/blank, 112/p, 107/k, 66/B, 80/P, 32/blank, 32/blank, 32/blank, 32/blank, 112/p, 98/b, 78/N, 80/P, 32/blank, 32/blank, 32/blank, 32/blank, 112/p, 110/n, 82/R, 80/P, 32/blank, 32/blank, 32/blank, 32/blank, 112/p, 114/r
<span class="CommentedCode">#?       82/R, 80/P, 32/blank, 32/blank, 32/blank, 32/blank, 112/p, 114/r,</span>
<span class="CommentedCode">#?       78/N, 80/P, 32/blank, 32/blank, 32/blank, 32/blank, 112/p, 110/n,</span>
<span class="CommentedCode">#?       66/B, 80/P, 32/blank, 32/blank, 32/blank, 32/blank, 112/p, 98/b, </span>
<span class="CommentedCode">#?       81/Q, 80/P, 32/blank, 32/blank, 32/blank, 32/blank, 112/p, 113/q,</span>
<span class="CommentedCode">#?       75/K, 80/P, 32/blank, 32/blank, 32/blank, 32/blank, 112/p, 107/k,</span>
<span class="CommentedCode">#?       66/B, 80/P, 32/blank, 32/blank, 32/blank, 32/blank, 112/p, 98/b,</span>
<span class="CommentedCode">#?       78/N, 80/P, 32/blank, 32/blank, 32/blank, 32/blank, 112/p, 110/n,</span>
<span class="CommentedCode">#?       82/R, 80/P, 32/blank, 32/blank, 32/blank, 32/blank, 112/p, 114/r</span>
  board:address:<span class="Identifier">array</span>:address:<span class="Identifier">array</span>:character<span class="Special"> &lt;- </span><span class="Identifier">new</span>-board initial-position
  reply board
]

scenario printing-the-board [
  <span class="Identifier">assume</span>-screen 30/width, 12/height
  run [
    1:address:<span class="Identifier">array</span>:address:<span class="Identifier">array</span>:character/board<span class="Special"> &lt;- </span>initial-position
    screen:address<span class="Special"> &lt;- </span><span class="Identifier">print</span>-board screen:address, 1:address:<span class="Identifier">array</span>:address:<span class="Identifier">array</span>:character/board
  ]
  screen-should-contain [
  <span class="Comment">#  012345678901234567890123456789</span>
    .8 | r n b q k b n r           .
    .7 | p p p p p p p p           .
    .6 |                           .
    .5 |                           .
    .4 |                           .
    .3 |                           .
    .2 | P P P P P P P P           .
    .1 | R N B Q K B N R           .
    .  +----------------           .
    .    a b c d e f g h           .
    .                              .
    .                              .
  ]
]

<span class="SalientComment">## data structure: move</span>

container move [
  <span class="Comment"># valid range: 0-7</span>
  from-file:number
  from-rank:number
  to-file:number
  to-rank:number
]

<span class="Comment"># result:address:move, quit?:boolean, error?:boolean &lt;- read-move stdin:address:channel, screen:address</span>
<span class="Comment"># prints only error messages to screen</span>
recipe <span class="Identifier">read</span>-move [
  <span class="Underlined">local</span>-scope
  stdin:address:channel<span class="Special"> &lt;- </span>next-ingredient
  screen:address<span class="Special"> &lt;- </span>next-ingredient
  from-file:number, <span class="Identifier">quit</span>?:boolean, <span class="Identifier">error</span>?:boolean<span class="Special"> &lt;- </span><span class="Identifier">read</span>-file stdin, screen
  reply-if <span class="Identifier">quit</span>?, 0/dummy, <span class="Identifier">quit</span>?, <span class="Identifier">error</span>?
  reply-if <span class="Identifier">error</span>?, 0/dummy, <span class="Identifier">quit</span>?, <span class="Identifier">error</span>?
  <span class="Comment"># construct the move object</span>
  result:address:move<span class="Special"> &lt;- </span><span class="Identifier">new</span> move:<span class="Identifier">type</span>
  x:address:number<span class="Special"> &lt;- </span>get-address *result, from-file:offset
  *x<span class="Special"> &lt;- </span><span class="Identifier">copy</span> from-file
  x<span class="Special"> &lt;- </span>get-address *result, from-rank:offset
  *x, <span class="Identifier">quit</span>?, <span class="Identifier">error</span>?<span class="Special"> &lt;- </span><span class="Identifier">read</span>-rank stdin, screen
  reply-if <span class="Identifier">quit</span>?, 0/dummy, <span class="Identifier">quit</span>?, <span class="Identifier">error</span>?
  reply-if <span class="Identifier">error</span>?, 0/dummy, <span class="Identifier">quit</span>?, <span class="Identifier">error</span>?
  <span class="Identifier">error</span>?<span class="Special"> &lt;- </span>expect-from-channel stdin, 45/dash, screen
  reply-if <span class="Identifier">error</span>?, 0/dummy, 0/<span class="Identifier">quit</span>, <span class="Identifier">error</span>?
  x<span class="Special"> &lt;- </span>get-address *result, to-file:offset
  *x, <span class="Identifier">quit</span>?, <span class="Identifier">error</span>?<span class="Special"> &lt;- </span><span class="Identifier">read</span>-file stdin, screen
  reply-if <span class="Identifier">quit</span>?:boolean, 0/dummy, <span class="Identifier">quit</span>?:boolean, <span class="Identifier">error</span>?:boolean
  reply-if <span class="Identifier">error</span>?:boolean, 0/dummy, <span class="Identifier">quit</span>?:boolean, <span class="Identifier">error</span>?:boolean
  x:address:number<span class="Special"> &lt;- </span>get-address *result, to-rank:offset
  *x, <span class="Identifier">quit</span>?, <span class="Identifier">error</span>?<span class="Special"> &lt;- </span><span class="Identifier">read</span>-rank stdin, screen
  reply-if <span class="Identifier">quit</span>?, 0/dummy, <span class="Identifier">quit</span>?, <span class="Identifier">error</span>?
  reply-if <span class="Identifier">error</span>?, 0/dummy, <span class="Identifier">quit</span>?, <span class="Identifier">error</span>?
  <span class="Identifier">error</span>?<span class="Special"> &lt;- </span>expect-from-channel stdin, 10/newline, screen
  reply-if <span class="Identifier">error</span>?, 0/dummy, 0/<span class="Identifier">quit</span>, <span class="Identifier">error</span>?
  reply result, <span class="Identifier">quit</span>?, <span class="Identifier">error</span>?
]

<span class="Comment"># file:number, quit:boolean, error:boolean &lt;- read-file stdin:address:channel, screen:address</span>
<span class="Comment"># valid values for file: 0-7</span>
recipe <span class="Identifier">read</span>-file [
  <span class="Underlined">local</span>-scope
  stdin:address:channel<span class="Special"> &lt;- </span>next-ingredient
  screen:address<span class="Special"> &lt;- </span>next-ingredient
  c:character, stdin<span class="Special"> &lt;- </span><span class="Identifier">read</span> stdin
  {
    q-pressed?:boolean<span class="Special"> &lt;- </span>equal c, 81/Q
    break-unless q-pressed?
    reply 0/dummy, 1/<span class="Identifier">quit</span>, 0/<span class="Identifier">error</span>
  }
  {
    q-pressed?<span class="Special"> &lt;- </span>equal c, 113/q
    break-unless q-pressed?
    reply 0/dummy, 1/<span class="Identifier">quit</span>, 0/<span class="Identifier">error</span>
  }
  {
    empty-fake-keyboard?:boolean<span class="Special"> &lt;- </span>equal c, 0/eof
    break-unless empty-fake-keyboard?
    reply 0/dummy, 1/<span class="Identifier">quit</span>, 0/<span class="Identifier">error</span>
  }
  {
    newline?:boolean<span class="Special"> &lt;- </span>equal c, 10/newline
    break-unless newline?
    <span class="Identifier">error</span>-message:address:<span class="Identifier">array</span>:character<span class="Special"> &lt;- </span><span class="Identifier">new</span> [that's not enough]
    <span class="Identifier">print</span>-string screen, <span class="Identifier">error</span>-message
    reply 0/dummy, 0/<span class="Identifier">quit</span>, 1/<span class="Identifier">error</span>
  }
  file:number<span class="Special"> &lt;- </span>subtract c, 97/a
  <span class="Comment"># 'a' &lt;= file &lt;= 'h'</span>
  {
    above-<span class="Identifier">min</span>:boolean<span class="Special"> &lt;- </span>greater-or-equal file, 0
    break-if above-<span class="Identifier">min</span>
    <span class="Identifier">error</span>-message:address:<span class="Identifier">array</span>:character<span class="Special"> &lt;- </span><span class="Identifier">new</span> [file too low: ]
    <span class="Identifier">print</span>-string screen, <span class="Identifier">error</span>-message
    <span class="Identifier">print</span>-character screen, c
    cursor-to-next-line screen
    reply 0/dummy, 0/<span class="Identifier">quit</span>, 1/<span class="Identifier">error</span>
  }
  {
    below-<span class="Identifier">max</span>:boolean<span class="Special"> &lt;- </span>lesser-than file, 8
    break-if below-<span class="Identifier">max</span>
    <span class="Identifier">error</span>-message<span class="Special"> &lt;- </span><span class="Identifier">new</span> [file too high: ]
    <span class="Identifier">print</span>-string screen, <span class="Identifier">error</span>-message
    <span class="Identifier">print</span>-character screen, c
    reply 0/dummy, 0/<span class="Identifier">quit</span>, 1/<span class="Identifier">error</span>
  }
  reply file, 0/<span class="Identifier">quit</span>, 0/<span class="Identifier">error</span>
]

<span class="Comment"># rank:number &lt;- read-rank stdin:address:channel, screen:address</span>
<span class="Comment"># valid values: 0-7, -1 (quit), -2 (error)</span>
recipe <span class="Identifier">read</span>-rank [
  <span class="Underlined">local</span>-scope
  stdin:address:channel<span class="Special"> &lt;- </span>next-ingredient
  screen:address<span class="Special"> &lt;- </span>next-ingredient
  c:character, stdin<span class="Special"> &lt;- </span><span class="Identifier">read</span> stdin
  {
    q-pressed?:boolean<span class="Special"> &lt;- </span>equal c, 8/Q
    break-unless q-pressed?
    reply 0/dummy, 1/<span class="Identifier">quit</span>, 0/<span class="Identifier">error</span>
  }
  {
    q-pressed?<span class="Special"> &lt;- </span>equal c, 113/q
    break-unless q-pressed?
    reply 0/dummy, 1/<span class="Identifier">quit</span>, 0/<span class="Identifier">error</span>
  }
  {
    newline?:boolean<span class="Special"> &lt;- </span>equal c, 10  <span class="Comment"># newline</span>
    break-unless newline?
    <span class="Identifier">error</span>-message:address:<span class="Identifier">array</span>:character<span class="Special"> &lt;- </span><span class="Identifier">new</span> [that's not enough]
    <span class="Identifier">print</span>-string screen, <span class="Identifier">error</span>-message
    reply 0/dummy, 0/<span class="Identifier">quit</span>, 1/<span class="Identifier">error</span>
  }
  rank:number<span class="Special"> &lt;- </span>subtract c, 49/'1'
  <span class="Comment"># assert'1' &lt;= rank &lt;= '8'</span>
  {
    above-<span class="Identifier">min</span>:boolean<span class="Special"> &lt;- </span>greater-or-equal rank, 0
    break-if above-<span class="Identifier">min</span>
    <span class="Identifier">error</span>-message<span class="Special"> &lt;- </span><span class="Identifier">new</span> [rank too low: ]
    <span class="Identifier">print</span>-string screen, <span class="Identifier">error</span>-message
    <span class="Identifier">print</span>-character screen, c
    reply 0/dummy, 0/<span class="Identifier">quit</span>, 1/<span class="Identifier">error</span>
  }
  {
    below-<span class="Identifier">max</span>:boolean<span class="Special"> &lt;- </span>lesser-or-equal rank, 7
    break-if below-<span class="Identifier">max</span>
    <span class="Identifier">error</span>-message<span class="Special"> &lt;- </span><span class="Identifier">new</span> [rank too high: ]
    <span class="Identifier">print</span>-string screen, <span class="Identifier">error</span>-message
    <span class="Identifier">print</span>-character screen, c
    reply 0/dummy, 0/<span class="Identifier">quit</span>, 1/<span class="Identifier">error</span>
  }
  reply rank, 0/<span class="Identifier">quit</span>, 0/<span class="Identifier">error</span>
]

<span class="Comment"># read a character from the given channel and check that it's what we expect</span>
<span class="Comment"># return true on error</span>
recipe expect-from-channel [
  <span class="Underlined">local</span>-scope
  stdin:address:channel<span class="Special"> &lt;- </span>next-ingredient
  expected:character<span class="Special"> &lt;- </span>next-ingredient
  screen:address<span class="Special"> &lt;- </span>next-ingredient
  c:character, stdin<span class="Special"> &lt;- </span><span class="Identifier">read</span> stdin
  {
    <span class="Identifier">match</span>?:boolean<span class="Special"> &lt;- </span>equal c, expected
    break-if <span class="Identifier">match</span>?
    s:address:<span class="Identifier">array</span>:character<span class="Special"> &lt;- </span><span class="Identifier">new</span> [expected character not found]
    <span class="Identifier">print</span>-string screen, s
  }
  result:boolean<span class="Special"> &lt;- </span>not <span class="Identifier">match</span>?
  reply result
]

scenario <span class="Identifier">read</span>-move-blocking [
  <span class="Identifier">assume</span>-screen 20/width, 2/height
  run [
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">new</span>-channel 2
    2:number/routine<span class="Special"> &lt;- </span>start-running <span class="Identifier">read</span>-move:recipe, 1:address:channel, screen:address
    <span class="Comment"># 'read-move' is waiting for input</span>
    wait-for-routine 2:number
    3:number<span class="Special"> &lt;- </span>routine-state 2:number/<span class="Identifier">id</span>
    4:boolean/waiting?<span class="Special"> &lt;- </span>equal 3:number/routine-state, 3/waiting
    <span class="Identifier">assert</span> 4:boolean/waiting?, [
F <span class="Identifier">read</span>-move-blocking: routine failed to pause after coming up (before any keys were pressed)]
    <span class="Comment"># press 'a'</span>
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">write</span> 1:address:channel, 97/a
    restart 2:number/routine
    <span class="Comment"># 'read-move' still waiting for input</span>
    wait-for-routine 2:number
    3:number<span class="Special"> &lt;- </span>routine-state 2:number/<span class="Identifier">id</span>
    4:boolean/waiting?<span class="Special"> &lt;- </span>equal 3:number/routine-state, 3/waiting
    <span class="Identifier">assert</span> 4:boolean/waiting?, [
F <span class="Identifier">read</span>-move-blocking: routine failed to pause after rank 'a']
    <span class="Comment"># press '2'</span>
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">write</span> 1:address:channel, 50/'2'
    restart 2:number/routine
    <span class="Comment"># 'read-move' still waiting for input</span>
    wait-for-routine 2:number
    3:number<span class="Special"> &lt;- </span>routine-state 2:number/<span class="Identifier">id</span>
    4:boolean/waiting?<span class="Special"> &lt;- </span>equal 3:number/routine-state, 3/waiting
    <span class="Identifier">assert</span> 4:boolean/waiting?, [
F <span class="Identifier">read</span>-move-blocking: routine failed to pause after file 'a2']
    <span class="Comment"># press '-'</span>
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">write</span> 1:address:channel, 45/'-'
    restart 2:number/routine
    <span class="Comment"># 'read-move' still waiting for input</span>
    wait-for-routine 2:number
    3:number<span class="Special"> &lt;- </span>routine-state 2:number
    4:boolean/waiting?<span class="Special"> &lt;- </span>equal 3:number/routine-state, 3/waiting
    <span class="Identifier">assert</span> 4:boolean/waiting?/routine-state, [
F <span class="Identifier">read</span>-move-blocking: routine failed to pause after hyphen 'a2-']
    <span class="Comment"># press 'a'</span>
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">write</span> 1:address:channel, 97/a
    restart 2:number/routine
    <span class="Comment"># 'read-move' still waiting for input</span>
    wait-for-routine 2:number
    3:number<span class="Special"> &lt;- </span>routine-state 2:number
    4:boolean/waiting?<span class="Special"> &lt;- </span>equal 3:number/routine-state, 3/waiting
    <span class="Identifier">assert</span> 4:boolean/waiting?/routine-state, [
F <span class="Identifier">read</span>-move-blocking: routine failed to pause after rank 'a2-a']
    <span class="Comment"># press '4'</span>
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">write</span> 1:address:channel, 52/'4'
    restart 2:number/routine
    <span class="Comment"># 'read-move' still waiting for input</span>
    wait-for-routine 2:number
    3:number<span class="Special"> &lt;- </span>routine-state 2:number
    4:boolean/waiting?<span class="Special"> &lt;- </span>equal 3:number/routine-state, 3/waiting
    <span class="Identifier">assert</span> 4:boolean/waiting?, [
F <span class="Identifier">read</span>-move-blocking: routine failed to pause after file 'a2-a4']
    <span class="Comment"># press 'newline'</span>
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">write</span> 1:address:channel, 10  <span class="Comment"># newline</span>
    restart 2:number/routine
    <span class="Comment"># 'read-move' now completes</span>
    wait-for-routine 2:number
    3:number<span class="Special"> &lt;- </span>routine-state 2:number
    4:boolean/completed?<span class="Special"> &lt;- </span>equal 3:number/routine-state, 1/completed
    <span class="Identifier">assert</span> 4:boolean/completed?, [
F <span class="Identifier">read</span>-move-blocking: routine failed to terminate on newline]
    trace 1, [test], [reached end]
  ]
  trace-should-contain [
    test: reached end
  ]
]

scenario <span class="Identifier">read</span>-move-<span class="Identifier">quit</span> [
  <span class="Identifier">assume</span>-screen 20/width, 2/height
  run [
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">new</span>-channel 2
    2:number/routine<span class="Special"> &lt;- </span>start-running <span class="Identifier">read</span>-move:recipe, 1:address:channel, screen:address
    <span class="Comment"># 'read-move' is waiting for input</span>
    wait-for-routine 2:number
    3:number<span class="Special"> &lt;- </span>routine-state 2:number/<span class="Identifier">id</span>
    4:boolean/waiting?<span class="Special"> &lt;- </span>equal 3:number/routine-state, 3/waiting
    <span class="Identifier">assert</span> 4:boolean/waiting?, [
F <span class="Identifier">read</span>-move-<span class="Identifier">quit</span>: routine failed to pause after coming up (before any keys were pressed)]
    <span class="Comment"># press 'q'</span>
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">write</span> 1:address:channel, 113/q
    restart 2:number/routine
    <span class="Comment"># 'read-move' completes</span>
    wait-for-routine 2:number
    3:number<span class="Special"> &lt;- </span>routine-state 2:number/<span class="Identifier">id</span>
    4:boolean/completed?<span class="Special"> &lt;- </span>equal 3:number/routine-state, 1/completed
    <span class="Identifier">assert</span> 4:boolean/completed?, [
F <span class="Identifier">read</span>-move-<span class="Identifier">quit</span>: routine failed to terminate on 'q']
    trace 1, [test], [reached end]
  ]
  trace-should-contain [
    test: reached end
  ]
]

scenario <span class="Identifier">read</span>-move-illegal-file [
  <span class="Identifier">assume</span>-screen 20/width, 2/height
  run [
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">new</span>-channel 2
    2:number/routine<span class="Special"> &lt;- </span>start-running <span class="Identifier">read</span>-move:recipe, 1:address:channel, screen:address
    <span class="Comment"># 'read-move' is waiting for input</span>
    wait-for-routine 2:number
    3:number<span class="Special"> &lt;- </span>routine-state 2:number/<span class="Identifier">id</span>
    4:boolean/waiting?<span class="Special"> &lt;- </span>equal 3:number/routine-state, 3/waiting
    <span class="Identifier">assert</span> 4:boolean/waiting?, [
F <span class="Identifier">read</span>-move-file: routine failed to pause after coming up (before any keys were pressed)]
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">write</span> 1:address:channel, 50/'2'
    restart 2:number/routine
    wait-for-routine 2:number
  ]
  screen-should-contain [
    .file too low: 2     .
    .                    .
  ]
]

scenario <span class="Identifier">read</span>-move-illegal-rank [
  <span class="Identifier">assume</span>-screen 20/width, 2/height
  run [
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">new</span>-channel 2
    2:number/routine<span class="Special"> &lt;- </span>start-running <span class="Identifier">read</span>-move:recipe, 1:address:channel, screen:address
    <span class="Comment"># 'read-move' is waiting for input</span>
    wait-for-routine 2:number
    3:number<span class="Special"> &lt;- </span>routine-state 2:number/<span class="Identifier">id</span>
    4:boolean/waiting?<span class="Special"> &lt;- </span>equal 3:number/routine-state, 3/waiting
    <span class="Identifier">assert</span> 4:boolean/waiting?, [
F <span class="Identifier">read</span>-move-file: routine failed to pause after coming up (before any keys were pressed)]
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">write</span> 1:address:channel, 97/a
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">write</span> 1:address:channel, 97/a
    restart 2:number/routine
    wait-for-routine 2:number
  ]
  screen-should-contain [
    .rank too high: a    .
    .                    .
  ]
]

scenario <span class="Identifier">read</span>-move-empty [
  <span class="Identifier">assume</span>-screen 20/width, 2/height
  run [
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">new</span>-channel 2
    2:number/routine<span class="Special"> &lt;- </span>start-running <span class="Identifier">read</span>-move:recipe, 1:address:channel, screen:address
    <span class="Comment"># 'read-move' is waiting for input</span>
    wait-for-routine 2:number
    3:number<span class="Special"> &lt;- </span>routine-state 2:number/<span class="Identifier">id</span>
    4:boolean/waiting?<span class="Special"> &lt;- </span>equal 3:number/routine-state, 3/waiting
    <span class="Identifier">assert</span> 4:boolean/waiting?, [
F <span class="Identifier">read</span>-move-file: routine failed to pause after coming up (before any keys were pressed)]
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">write</span> 1:address:channel, 10/newline
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">write</span> 1:address:channel, 97/a
    restart 2:number/routine
    wait-for-routine 2:number
  ]
  screen-should-contain [
    .that's not enough   .
    .                    .
  ]
]

recipe make-move [
  <span class="Underlined">local</span>-scope
  b:address:<span class="Identifier">array</span>:address:<span class="Identifier">array</span>:character<span class="Special"> &lt;- </span>next-ingredient
  m:address:move<span class="Special"> &lt;- </span>next-ingredient
  from-file:number<span class="Special"> &lt;- </span>get *m, from-file:offset
  from-rank:number<span class="Special"> &lt;- </span>get *m, from-rank:offset
  to-file:number<span class="Special"> &lt;- </span>get *m, to-file:offset
  to-rank:number<span class="Special"> &lt;- </span>get *m, to-rank:offset
  f:address:<span class="Identifier">array</span>:character<span class="Special"> &lt;- </span>index *b, from-file
  src:address:character/square<span class="Special"> &lt;- </span>index-address *f, from-rank
  f<span class="Special"> &lt;- </span>index *b, to-file
  dest:address:character/square<span class="Special"> &lt;- </span>index-address *f, to-rank
  *dest<span class="Special"> &lt;- </span><span class="Identifier">copy</span> *src
  *src<span class="Special"> &lt;- </span><span class="Identifier">copy</span> 32/space
  reply b/same-as-ingredient:0
]

scenario making-a-move [
  <span class="Identifier">assume</span>-screen 30/width, 12/height
  run [
    2:address:<span class="Identifier">array</span>:address:<span class="Identifier">array</span>:character/board<span class="Special"> &lt;- </span>initial-position
    3:address:move<span class="Special"> &lt;- </span><span class="Identifier">new</span> move:<span class="Identifier">type</span>
    4:address:number<span class="Special"> &lt;- </span>get-address *3:address:move, from-file:offset
    *4:address:number<span class="Special"> &lt;- </span><span class="Identifier">copy</span> 6/g
    5:address:number<span class="Special"> &lt;- </span>get-address *3:address:move, from-rank:offset
    *5:address:number<span class="Special"> &lt;- </span><span class="Identifier">copy</span> 1/'2'
    6:address:number<span class="Special"> &lt;- </span>get-address *3:address:move, to-file:offset
    *6:address:number<span class="Special"> &lt;- </span><span class="Identifier">copy</span> 6/g
    7:address:number<span class="Special"> &lt;- </span>get-address *3:address:move, to-rank:offset
    *7:address:number<span class="Special"> &lt;- </span><span class="Identifier">copy</span> 3/'4'
    2:address:<span class="Identifier">array</span>:address:<span class="Identifier">array</span>:character/board<span class="Special"> &lt;- </span>make-move 2:address:<span class="Identifier">array</span>:address:<span class="Identifier">array</span>:character/board, 3:address:move
    screen:address<span class="Special"> &lt;- </span><span class="Identifier">print</span>-board screen:address, 2:address:<span class="Identifier">array</span>:address:<span class="Identifier">array</span>:character/board
  ]
  screen-should-contain [
  <span class="Comment">#  012345678901234567890123456789</span>
    .8 | r n b q k b n r           .
    .7 | p p p p p p p p           .
    .6 |                           .
    .5 |                           .
    .4 |             P             .
    .3 |                           .
    .2 | P P P P P P   P           .
    .1 | R N B Q K B N R           .
    .  +----------------           .
    .    a b c d e f g h           .
    .                              .
  ]
]
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
