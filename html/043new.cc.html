<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>Mu - 043new.cc</title>
<meta name="Generator" content="Vim/7.4">
<meta name="plugin-version" content="vim7.4_v1">
<meta name="syntax" content="cpp">
<meta name="settings" content="use_css,pre_wrap,no_foldcolumn,expand_tabs,prevent_copy=">
<meta name="colorscheme" content="minimal">
<style type="text/css">
<!--
pre { white-space: pre-wrap; font-family: monospace; color: #eeeeee; background-color: #080808; }
body { font-family: monospace; color: #eeeeee; background-color: #080808; }
* { font-size: 1.05em; }
.traceContains { color: #008000; }
.SalientComment { color: #00ffff; }
.cSpecial { color: #008000; }
.CommentedCode { color: #6c6c6c; }
.Comment { color: #9090ff; }
.Delimiter { color: #a04060; }
.Special { color: #ff6060; }
.Identifier { color: #804000; }
.Constant { color: #00a0a0; }
-->
</style>

<script type='text/javascript'>
<!--

-->
</script>
</head>
<body>
<pre id='vimCodeElement'>
<span class="Comment">//: A simple memory allocator to create space for new variables at runtime.</span>

<span class="Delimiter">:(scenarios run)</span>
<span class="Delimiter">:(scenario new)</span>
<span class="Comment"># call new two times with identical arguments; you should get back different results</span>
recipe main [
  <span class="Constant">1</span>:address:number/<span class="Special">raw &lt;- </span>new number:type
  <span class="Constant">2</span>:address:number/<span class="Special">raw &lt;- </span>new number:type
  <span class="Constant">3</span>:boolean/<span class="Special">raw &lt;- </span>equal <span class="Constant">1</span>:address:number/<span class="Special">raw</span><span class="Delimiter">,</span> <span class="Constant">2</span>:address:number/<span class="Special">raw</span>
]
<span class="traceContains">+mem: storing 0 in location 3</span>

<span class="Delimiter">:(before &quot;End Globals&quot;)</span>
long long int Memory_allocated_until = Reserved_for_tests<span class="Delimiter">;</span>
long long int Initial_memory_per_routine = <span class="Constant">100000</span><span class="Delimiter">;</span>
<span class="Delimiter">:(before &quot;End Setup&quot;)</span>
Memory_allocated_until = Reserved_for_tests<span class="Delimiter">;</span>
Initial_memory_per_routine = <span class="Constant">100000</span><span class="Delimiter">;</span>
<span class="Delimiter">:(before &quot;End routine Fields&quot;)</span>
long long int alloc<span class="Delimiter">,</span> alloc_max<span class="Delimiter">;</span>
<span class="Delimiter">:(before &quot;End routine Constructor&quot;)</span>
alloc = Memory_allocated_until<span class="Delimiter">;</span>
Memory_allocated_until += Initial_memory_per_routine<span class="Delimiter">;</span>
alloc_max = Memory_allocated_until<span class="Delimiter">;</span>
trace<span class="Delimiter">(</span><span class="Constant">9999</span><span class="Delimiter">,</span> <span class="Constant">&quot;new&quot;</span><span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;routine allocated memory from &quot;</span> &lt;&lt; alloc &lt;&lt; <span class="Constant">&quot; to &quot;</span> &lt;&lt; alloc_max &lt;&lt; end<span class="Delimiter">();</span>

<span class="SalientComment">//:: 'new' takes a weird 'type' as its first ingredient; don't error on it</span>
<span class="Delimiter">:(before &quot;End Mu Types Initialization&quot;)</span>
put<span class="Delimiter">(</span>Type_ordinal<span class="Delimiter">,</span> <span class="Constant">&quot;type&quot;</span><span class="Delimiter">,</span> <span class="Constant">0</span><span class="Delimiter">);</span>

<span class="SalientComment">//:: typecheck 'new' instructions</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Declarations&quot;)</span>
NEW<span class="Delimiter">,</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Numbers&quot;)</span>
put<span class="Delimiter">(</span>Recipe_ordinal<span class="Delimiter">,</span> <span class="Constant">&quot;new&quot;</span><span class="Delimiter">,</span> NEW<span class="Delimiter">);</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Checks&quot;)</span>
case NEW: <span class="Delimiter">{</span>
  if <span class="Delimiter">(</span>inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>empty<span class="Delimiter">()</span> || SIZE<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">)</span> &gt; <span class="Constant">2</span><span class="Delimiter">)</span> <span class="Delimiter">{</span>
    raise_error &lt;&lt; maybe<span class="Delimiter">(</span>get<span class="Delimiter">(</span>Recipe<span class="Delimiter">,</span> r<span class="Delimiter">).</span>name<span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;'new' requires one or two ingredients, but got &quot;</span> &lt;&lt; inst<span class="Delimiter">.</span>to_string<span class="Delimiter">()</span> &lt;&lt; <span class="cSpecial">'\n'</span> &lt;&lt; end<span class="Delimiter">();</span>
    <span class="Identifier">break</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Comment">// End NEW Check Special-cases</span>
  reagent type = inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">);</span>
  if <span class="Delimiter">(</span>!is_mu_type_literal<span class="Delimiter">(</span>type<span class="Delimiter">))</span> <span class="Delimiter">{</span>
    raise_error &lt;&lt; maybe<span class="Delimiter">(</span>get<span class="Delimiter">(</span>Recipe<span class="Delimiter">,</span> r<span class="Delimiter">).</span>name<span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;first ingredient of 'new' should be a type, but got &quot;</span> &lt;&lt; type<span class="Delimiter">.</span>original_string &lt;&lt; <span class="cSpecial">'\n'</span> &lt;&lt; end<span class="Delimiter">();</span>
    <span class="Identifier">break</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Identifier">break</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="SalientComment">//:: translate 'new' to 'allocate' instructions that take a size instead of a type</span>
<span class="Delimiter">:(after &quot;Transform.push_back(check_instruction)&quot;)</span>  <span class="Comment">// check_instruction will guard against direct 'allocate' instructions below</span>
Transform<span class="Delimiter">.</span>push_back<span class="Delimiter">(</span>transform_new_to_allocate<span class="Delimiter">);</span>  <span class="Comment">// idempotent</span>

<span class="Delimiter">:(code)</span>
void transform_new_to_allocate<span class="Delimiter">(</span>const recipe_ordinal r<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  trace<span class="Delimiter">(</span><span class="Constant">9991</span><span class="Delimiter">,</span> <span class="Constant">&quot;transform&quot;</span><span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;--- convert 'new' to 'allocate' for recipe &quot;</span> &lt;&lt; get<span class="Delimiter">(</span>Recipe<span class="Delimiter">,</span> r<span class="Delimiter">).</span>name &lt;&lt; end<span class="Delimiter">();</span>
<span class="CommentedCode">//?   cerr &lt;&lt; &quot;--- convert 'new' to 'allocate' for recipe &quot; &lt;&lt; get(Recipe, r).name &lt;&lt; '\n';</span>
  for <span class="Delimiter">(</span>long long int i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; SIZE<span class="Delimiter">(</span>get<span class="Delimiter">(</span>Recipe<span class="Delimiter">,</span> r<span class="Delimiter">).</span>steps<span class="Delimiter">);</span> ++i<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    instruction&amp; inst = get<span class="Delimiter">(</span>Recipe<span class="Delimiter">,</span> r<span class="Delimiter">).</span>steps<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">);</span>
    <span class="Comment">// Convert 'new' To 'allocate'</span>
    if <span class="Delimiter">(</span>inst<span class="Delimiter">.</span>name == <span class="Constant">&quot;new&quot;</span><span class="Delimiter">)</span> <span class="Delimiter">{</span>
      inst<span class="Delimiter">.</span>operation = ALLOCATE<span class="Delimiter">;</span>
      string_tree* type_name = new string_tree<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>name<span class="Delimiter">);</span>
      <span class="Comment">// End Post-processing(type_name) When Converting 'new'</span>
      type_tree* type = new_type_tree<span class="Delimiter">(</span>type_name<span class="Delimiter">);</span>
      inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>set_value<span class="Delimiter">(</span>size_of<span class="Delimiter">(</span>type<span class="Delimiter">));</span>
      trace<span class="Delimiter">(</span><span class="Constant">9992</span><span class="Delimiter">,</span> <span class="Constant">&quot;new&quot;</span><span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;size of &quot;</span> &lt;&lt; debug_string<span class="Delimiter">(</span>type_name<span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot; is &quot;</span> &lt;&lt; inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>value &lt;&lt; end<span class="Delimiter">();</span>
      delete type<span class="Delimiter">;</span>
      delete type_name<span class="Delimiter">;</span>
    <span class="Delimiter">}</span>
  <span class="Delimiter">}</span>
<span class="Delimiter">}</span>

<span class="SalientComment">//:: implement 'allocate' based on size</span>

<span class="Delimiter">:(before &quot;End Primitive Recipe Declarations&quot;)</span>
ALLOCATE<span class="Delimiter">,</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Numbers&quot;)</span>
put<span class="Delimiter">(</span>Recipe_ordinal<span class="Delimiter">,</span> <span class="Constant">&quot;allocate&quot;</span><span class="Delimiter">,</span> ALLOCATE<span class="Delimiter">);</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Implementations&quot;)</span>
case ALLOCATE: <span class="Delimiter">{</span>
  <span class="Comment">// compute the space we need</span>
  long long int size = ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">);</span>
  if <span class="Delimiter">(</span>SIZE<span class="Delimiter">(</span>ingredients<span class="Delimiter">)</span> &gt; <span class="Constant">1</span><span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Comment">// array</span>
    trace<span class="Delimiter">(</span><span class="Constant">9999</span><span class="Delimiter">,</span> <span class="Constant">&quot;mem&quot;</span><span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;array size is &quot;</span> &lt;&lt; ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">1</span><span class="Delimiter">).</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">)</span> &lt;&lt; end<span class="Delimiter">();</span>
    size = <span class="Comment">/*</span><span class="Comment">space for length</span><span class="Comment">*/</span><span class="Constant">1</span> + size*ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">1</span><span class="Delimiter">).</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">);</span>
  <span class="Delimiter">}</span>
<span class="CommentedCode">//?   Total_alloc += size;</span>
<span class="CommentedCode">//?   Num_alloc++;</span>
  <span class="Comment">// compute the region of memory to return</span>
  <span class="Comment">// really crappy at the moment</span>
  ensure_space<span class="Delimiter">(</span>size<span class="Delimiter">);</span>
  const long long int result = Current_routine<span class="Delimiter">-&gt;</span>alloc<span class="Delimiter">;</span>
  trace<span class="Delimiter">(</span><span class="Constant">9999</span><span class="Delimiter">,</span> <span class="Constant">&quot;mem&quot;</span><span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;new alloc: &quot;</span> &lt;&lt; result &lt;&lt; end<span class="Delimiter">();</span>
  <span class="Comment">// save result</span>
  products<span class="Delimiter">.</span>resize<span class="Delimiter">(</span><span class="Constant">1</span><span class="Delimiter">);</span>
  products<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>push_back<span class="Delimiter">(</span>result<span class="Delimiter">);</span>
  <span class="Comment">// initialize allocated space</span>
  for <span class="Delimiter">(</span>long long int address = result<span class="Delimiter">;</span> address &lt; result+size<span class="Delimiter">;</span> ++address<span class="Delimiter">)</span>
    put<span class="Delimiter">(</span>Memory<span class="Delimiter">,</span> address<span class="Delimiter">,</span> <span class="Constant">0</span><span class="Delimiter">);</span>
  <span class="Comment">// initialize array length</span>
  if <span class="Delimiter">(</span>SIZE<span class="Delimiter">(</span>current_instruction<span class="Delimiter">().</span>ingredients<span class="Delimiter">)</span> &gt; <span class="Constant">1</span><span class="Delimiter">)</span>
    put<span class="Delimiter">(</span>Memory<span class="Delimiter">,</span> result<span class="Delimiter">,</span> ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">1</span><span class="Delimiter">).</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">));</span>
  <span class="Comment">// bump</span>
  Current_routine<span class="Delimiter">-&gt;</span>alloc += size<span class="Delimiter">;</span>
  <span class="Comment">// no support for reclaiming memory</span>
  assert<span class="Delimiter">(</span>Current_routine<span class="Delimiter">-&gt;</span>alloc &lt;= Current_routine<span class="Delimiter">-&gt;</span>alloc_max<span class="Delimiter">);</span>
  <span class="Identifier">break</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="SalientComment">//:: ensure we never call 'allocate' directly; its types are not checked</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Checks&quot;)</span>
case ALLOCATE: <span class="Delimiter">{</span>
  raise &lt;&lt; <span class="Constant">&quot;never call 'allocate' directly'; always use 'new'</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span> &lt;&lt; end<span class="Delimiter">();</span>
  <span class="Identifier">break</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="SalientComment">//:: ensure we never call 'new' without translating it (unless we add special-cases later)</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Implementations&quot;)</span>
case NEW: <span class="Delimiter">{</span>
  raise &lt;&lt; <span class="Constant">&quot;no implementation for 'new'; why wasn't it translated to 'allocate'?</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span> &lt;&lt; end<span class="Delimiter">();</span>
  <span class="Identifier">break</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="CommentedCode">//? :(before &quot;End Globals&quot;)</span>
<span class="CommentedCode">//? long long int Total_alloc = 0;</span>
<span class="CommentedCode">//? long long int Num_alloc = 0;</span>
<span class="CommentedCode">//? long long int Total_free = 0;</span>
<span class="CommentedCode">//? long long int Num_free = 0;</span>
<span class="CommentedCode">//? :(before &quot;End Setup&quot;)</span>
<span class="CommentedCode">//? Total_alloc = Num_alloc = Total_free = Num_free = 0;</span>
<span class="CommentedCode">//? :(before &quot;End Teardown&quot;)</span>
<span class="CommentedCode">//? cerr &lt;&lt; Total_alloc &lt;&lt; &quot;/&quot; &lt;&lt; Num_alloc</span>
<span class="CommentedCode">//?      &lt;&lt; &quot; vs &quot; &lt;&lt; Total_free &lt;&lt; &quot;/&quot; &lt;&lt; Num_free &lt;&lt; '\n';</span>
<span class="CommentedCode">//? cerr &lt;&lt; SIZE(Memory) &lt;&lt; '\n';</span>

<span class="Delimiter">:(code)</span>
void ensure_space<span class="Delimiter">(</span>long long int size<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  if <span class="Delimiter">(</span>size &gt; Initial_memory_per_routine<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    tb_shutdown<span class="Delimiter">();</span>
    cerr &lt;&lt; <span class="Constant">&quot;can't allocate &quot;</span> &lt;&lt; size &lt;&lt; <span class="Constant">&quot; locations, that's too much.</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span><span class="Delimiter">;</span>
    exit<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">);</span>
  <span class="Delimiter">}</span>
  if <span class="Delimiter">(</span>Current_routine<span class="Delimiter">-&gt;</span>alloc + size &gt; Current_routine<span class="Delimiter">-&gt;</span>alloc_max<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Comment">// waste the remaining space and create a new chunk</span>
    Current_routine<span class="Delimiter">-&gt;</span>alloc = Memory_allocated_until<span class="Delimiter">;</span>
    Memory_allocated_until += Initial_memory_per_routine<span class="Delimiter">;</span>
    Current_routine<span class="Delimiter">-&gt;</span>alloc_max = Memory_allocated_until<span class="Delimiter">;</span>
    trace<span class="Delimiter">(</span><span class="Constant">9999</span><span class="Delimiter">,</span> <span class="Constant">&quot;new&quot;</span><span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;routine allocated memory from &quot;</span> &lt;&lt; Current_routine<span class="Delimiter">-&gt;</span>alloc &lt;&lt; <span class="Constant">&quot; to &quot;</span> &lt;&lt; Current_routine<span class="Delimiter">-&gt;</span>alloc_max &lt;&lt; end<span class="Delimiter">();</span>
  <span class="Delimiter">}</span>
<span class="Delimiter">}</span>

<span class="Delimiter">:(scenario new_initializes)</span>
<span class="Special">% Memory_allocated_until = 10;</span>
<span class="Special">% put(Memory, Memory_allocated_until, 1);</span>
recipe main [
  <span class="Constant">1</span>:address:number<span class="Special"> &lt;- </span>new number:type
  <span class="Constant">2</span>:number<span class="Special"> &lt;- </span>copy *<span class="Constant">1</span>:address:number
]
<span class="traceContains">+mem: storing 0 in location 2</span>

<span class="Delimiter">:(scenario new_array)</span>
recipe main [
  <span class="Constant">1</span>:address:array:number/<span class="Special">raw &lt;- </span>new number:type<span class="Delimiter">,</span> <span class="Constant">5</span>
  <span class="Constant">2</span>:address:number/<span class="Special">raw &lt;- </span>new number:type
  <span class="Constant">3</span>:number/<span class="Special">raw &lt;- </span>subtract <span class="Constant">2</span>:address:number/<span class="Special">raw</span><span class="Delimiter">,</span> <span class="Constant">1</span>:address:array:number/<span class="Special">raw</span>
]
<span class="traceContains">+run: 1:address:array:number/raw &lt;- new number:type, 5</span>
<span class="traceContains">+mem: array size is 5</span>
<span class="Comment"># don't forget the extra location for array size</span>
<span class="traceContains">+mem: storing 6 in location 3</span>

<span class="Delimiter">:(scenario new_empty_array)</span>
recipe main [
  <span class="Constant">1</span>:address:array:number/<span class="Special">raw &lt;- </span>new number:type<span class="Delimiter">,</span> <span class="Constant">0</span>
  <span class="Constant">2</span>:address:number/<span class="Special">raw &lt;- </span>new number:type
  <span class="Constant">3</span>:number/<span class="Special">raw &lt;- </span>subtract <span class="Constant">2</span>:address:number/<span class="Special">raw</span><span class="Delimiter">,</span> <span class="Constant">1</span>:address:array:number/<span class="Special">raw</span>
]
<span class="traceContains">+run: 1:address:array:number/raw &lt;- new number:type, 0</span>
<span class="traceContains">+mem: array size is 0</span>
<span class="traceContains">+mem: storing 1 in location 3</span>

<span class="Comment">//: Make sure that each routine gets a different alloc to start.</span>
<span class="Delimiter">:(scenario new_concurrent)</span>
recipe f1 [
  start-running f2:recipe
  <span class="Constant">1</span>:address:number/<span class="Special">raw &lt;- </span>new number:type
  <span class="Comment"># wait for f2 to complete</span>
  <span class="Delimiter">{</span>
    loop-unless <span class="Constant">4</span>:number/<span class="Special">raw</span>
  <span class="Delimiter">}</span>
]
recipe f2 [
  <span class="Constant">2</span>:address:number/<span class="Special">raw &lt;- </span>new number:type
  <span class="Comment"># hack: assumes scheduler implementation</span>
  <span class="Constant">3</span>:boolean/<span class="Special">raw &lt;- </span>equal <span class="Constant">1</span>:address:number/<span class="Special">raw</span><span class="Delimiter">,</span> <span class="Constant">2</span>:address:number/<span class="Special">raw</span>
  <span class="Comment"># signal f2 complete</span>
  <span class="Constant">4</span>:number/<span class="Special">raw &lt;- </span>copy <span class="Constant">1</span>
]
<span class="traceContains">+mem: storing 0 in location 3</span>

<span class="Comment">//: If a routine runs out of its initial allocation, it should allocate more.</span>
<span class="Delimiter">:(scenario new_overflow)</span>
<span class="Special">% Initial_memory_per_routine = 2;</span>
recipe main [
  <span class="Constant">1</span>:address:number/<span class="Special">raw &lt;- </span>new number:type
  <span class="Constant">2</span>:address:point/<span class="Special">raw &lt;- </span>new point:type  <span class="Comment"># not enough room in initial page</span>
]
<span class="traceContains">+new: routine allocated memory from 1000 to 1002</span>
<span class="traceContains">+new: routine allocated memory from 1002 to 1004</span>

<span class="Comment">//: We also provide a way to return memory, and to reuse reclaimed memory.</span>
<span class="Comment">//: todo: custodians, etc. Following malloc/free is a temporary hack.</span>

<span class="Delimiter">:(scenario new_reclaim)</span>
recipe main [
  <span class="Constant">1</span>:address:number<span class="Special"> &lt;- </span>new number:type
  abandon <span class="Constant">1</span>:address:number
  <span class="Constant">2</span>:address:number<span class="Special"> &lt;- </span>new number:type  <span class="Comment"># must be same size as abandoned memory to reuse</span>
  <span class="Constant">3</span>:boolean<span class="Special"> &lt;- </span>equal <span class="Constant">1</span>:address:number<span class="Delimiter">,</span> <span class="Constant">2</span>:address:number
]
<span class="Comment"># both allocations should have returned the same address</span>
<span class="traceContains">+mem: storing 1 in location 3</span>

<span class="Delimiter">:(before &quot;End Globals&quot;)</span>
map&lt;long long int<span class="Delimiter">,</span> long long int&gt; Free_list<span class="Delimiter">;</span>
<span class="Delimiter">:(before &quot;End Setup&quot;)</span>
Free_list<span class="Delimiter">.</span>clear<span class="Delimiter">();</span>

<span class="Delimiter">:(before &quot;End Primitive Recipe Declarations&quot;)</span>
ABANDON<span class="Delimiter">,</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Numbers&quot;)</span>
put<span class="Delimiter">(</span>Recipe_ordinal<span class="Delimiter">,</span> <span class="Constant">&quot;abandon&quot;</span><span class="Delimiter">,</span> ABANDON<span class="Delimiter">);</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Checks&quot;)</span>
case ABANDON: <span class="Delimiter">{</span>
  if <span class="Delimiter">(</span>SIZE<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">)</span> != <span class="Constant">1</span><span class="Delimiter">)</span> <span class="Delimiter">{</span>
    raise_error &lt;&lt; maybe<span class="Delimiter">(</span>get<span class="Delimiter">(</span>Recipe<span class="Delimiter">,</span> r<span class="Delimiter">).</span>name<span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;'abandon' requires one ingredient, but got '&quot;</span> &lt;&lt; inst<span class="Delimiter">.</span>to_string<span class="Delimiter">()</span> &lt;&lt; <span class="Constant">&quot;'</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span> &lt;&lt; end<span class="Delimiter">();</span>
    <span class="Identifier">break</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  reagent types = inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">);</span>
  canonize_type<span class="Delimiter">(</span>types<span class="Delimiter">);</span>
  if <span class="Delimiter">(</span>!types<span class="Delimiter">.</span>type || types<span class="Delimiter">.</span>type<span class="Delimiter">-&gt;</span>value != get<span class="Delimiter">(</span>Type_ordinal<span class="Delimiter">,</span> <span class="Constant">&quot;address&quot;</span><span class="Delimiter">))</span> <span class="Delimiter">{</span>
    raise_error &lt;&lt; maybe<span class="Delimiter">(</span>get<span class="Delimiter">(</span>Recipe<span class="Delimiter">,</span> r<span class="Delimiter">).</span>name<span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;first ingredient of 'abandon' should be an address, but got &quot;</span> &lt;&lt; inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>original_string &lt;&lt; <span class="cSpecial">'\n'</span> &lt;&lt; end<span class="Delimiter">();</span>
    <span class="Identifier">break</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Identifier">break</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Implementations&quot;)</span>
case ABANDON: <span class="Delimiter">{</span>
  long long int address = ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">);</span>
  reagent types = current_instruction<span class="Delimiter">().</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">);</span>
  canonize<span class="Delimiter">(</span>types<span class="Delimiter">);</span>
  <span class="Comment">// lookup_memory without drop_one_lookup {</span>
  types<span class="Delimiter">.</span>set_value<span class="Delimiter">(</span>get_or_insert<span class="Delimiter">(</span>Memory<span class="Delimiter">,</span> types<span class="Delimiter">.</span>value<span class="Delimiter">));</span>
  drop_address_from_type<span class="Delimiter">(</span>types<span class="Delimiter">);</span>
  <span class="Comment">// }</span>
  abandon<span class="Delimiter">(</span>address<span class="Delimiter">,</span> size_of<span class="Delimiter">(</span>types<span class="Delimiter">));</span>
  <span class="Identifier">break</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="Delimiter">:(code)</span>
void abandon<span class="Delimiter">(</span>long long int address<span class="Delimiter">,</span> long long int size<span class="Delimiter">)</span> <span class="Delimiter">{</span>
<span class="CommentedCode">//?   Total_free += size;</span>
<span class="CommentedCode">//?   Num_free++;</span>
<span class="CommentedCode">//?   cerr &lt;&lt; &quot;abandon: &quot; &lt;&lt; size &lt;&lt; '\n';</span>
  <span class="Comment">// clear memory</span>
  for <span class="Delimiter">(</span>long long int curr = address<span class="Delimiter">;</span> curr &lt; address+size<span class="Delimiter">;</span> ++curr<span class="Delimiter">)</span>
    put<span class="Delimiter">(</span>Memory<span class="Delimiter">,</span> curr<span class="Delimiter">,</span> <span class="Constant">0</span><span class="Delimiter">);</span>
  <span class="Comment">// append existing free list to address</span>
  put<span class="Delimiter">(</span>Memory<span class="Delimiter">,</span> address<span class="Delimiter">,</span> Free_list[size]<span class="Delimiter">);</span>
  Free_list[size] = address<span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="Delimiter">:(before &quot;ensure_space(size)&quot; following &quot;case ALLOCATE&quot;)</span>
if <span class="Delimiter">(</span>Free_list[size]<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  long long int result = Free_list[size]<span class="Delimiter">;</span>
  Free_list[size] = get_or_insert<span class="Delimiter">(</span>Memory<span class="Delimiter">,</span> result<span class="Delimiter">);</span>
  for <span class="Delimiter">(</span>long long int curr = result+<span class="Constant">1</span><span class="Delimiter">;</span> curr &lt; result+size<span class="Delimiter">;</span> ++curr<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    if <span class="Delimiter">(</span>get_or_insert<span class="Delimiter">(</span>Memory<span class="Delimiter">,</span> curr<span class="Delimiter">)</span> != <span class="Constant">0</span><span class="Delimiter">)</span> <span class="Delimiter">{</span>
      raise_error &lt;&lt; maybe<span class="Delimiter">(</span>current_recipe_name<span class="Delimiter">())</span> &lt;&lt; <span class="Constant">&quot;memory in free list was not zeroed out: &quot;</span> &lt;&lt; curr &lt;&lt; <span class="Constant">'/'</span> &lt;&lt; result &lt;&lt; <span class="Constant">&quot;; somebody wrote to us after free!!!</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span> &lt;&lt; end<span class="Delimiter">();</span>
      <span class="Identifier">break</span><span class="Delimiter">;</span>  <span class="Comment">// always fatal</span>
    <span class="Delimiter">}</span>
  <span class="Delimiter">}</span>
  if <span class="Delimiter">(</span>SIZE<span class="Delimiter">(</span>current_instruction<span class="Delimiter">().</span>ingredients<span class="Delimiter">)</span> &gt; <span class="Constant">1</span><span class="Delimiter">)</span>
    put<span class="Delimiter">(</span>Memory<span class="Delimiter">,</span> result<span class="Delimiter">,</span> ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">1</span><span class="Delimiter">).</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">));</span>
  else
    put<span class="Delimiter">(</span>Memory<span class="Delimiter">,</span> result<span class="Delimiter">,</span> <span class="Constant">0</span><span class="Delimiter">);</span>
  products<span class="Delimiter">.</span>resize<span class="Delimiter">(</span><span class="Constant">1</span><span class="Delimiter">);</span>
  products<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>push_back<span class="Delimiter">(</span>result<span class="Delimiter">);</span>
  <span class="Identifier">break</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="Delimiter">:(scenario new_differing_size_no_reclaim)</span>
recipe main [
  <span class="Constant">1</span>:address:number<span class="Special"> &lt;- </span>new number:type
  abandon <span class="Constant">1</span>:address:number
  <span class="Constant">2</span>:address:number<span class="Special"> &lt;- </span>new number:type<span class="Delimiter">,</span> <span class="Constant">2</span>  <span class="Comment"># different size</span>
  <span class="Constant">3</span>:boolean<span class="Special"> &lt;- </span>equal <span class="Constant">1</span>:address:number<span class="Delimiter">,</span> <span class="Constant">2</span>:address:number
]
<span class="Comment"># no reuse</span>
<span class="traceContains">+mem: storing 0 in location 3</span>

<span class="Delimiter">:(scenario new_reclaim_array)</span>
recipe main [
  <span class="Constant">1</span>:address:array:number<span class="Special"> &lt;- </span>new number:type<span class="Delimiter">,</span> <span class="Constant">2</span>
  abandon <span class="Constant">1</span>:address:array:number
  <span class="Constant">2</span>:address:array:number<span class="Special"> &lt;- </span>new number:type<span class="Delimiter">,</span> <span class="Constant">2</span>
  <span class="Constant">3</span>:boolean<span class="Special"> &lt;- </span>equal <span class="Constant">1</span>:address:array:number<span class="Delimiter">,</span> <span class="Constant">2</span>:address:array:number
]
<span class="Comment"># reuse</span>
<span class="traceContains">+mem: storing 1 in location 3</span>

<span class="SalientComment">//:: Next, extend 'new' to handle a unicode string literal argument.</span>

<span class="Delimiter">:(scenario new_string)</span>
recipe main [
  <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new [abc def]
  <span class="Constant">2</span>:character<span class="Special"> &lt;- </span>index *<span class="Constant">1</span>:address:array:character<span class="Delimiter">,</span> <span class="Constant">5</span>
]
<span class="Comment"># number code for 'e'</span>
<span class="traceContains">+mem: storing 101 in location 2</span>

<span class="Delimiter">:(scenario new_string_handles_unicode)</span>
recipe main [
  <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new [a«c]
  <span class="Constant">2</span>:number<span class="Special"> &lt;- </span>length *<span class="Constant">1</span>:address:array:character
  <span class="Constant">3</span>:character<span class="Special"> &lt;- </span>index *<span class="Constant">1</span>:address:array:character<span class="Delimiter">,</span> <span class="Constant">1</span>
]
<span class="traceContains">+mem: storing 3 in location 2</span>
<span class="Comment"># unicode for '«'</span>
<span class="traceContains">+mem: storing 171 in location 3</span>

<span class="Delimiter">:(before &quot;End NEW Check Special-cases&quot;)</span>
if <span class="Delimiter">(</span>is_literal_string<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">)))</span> <span class="Identifier">break</span><span class="Delimiter">;</span>
<span class="Delimiter">:(before &quot;Convert 'new' To 'allocate'&quot;)</span>
if <span class="Delimiter">(</span>inst<span class="Delimiter">.</span>name == <span class="Constant">&quot;new&quot;</span> &amp;&amp; is_literal_string<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">)))</span> <span class="Identifier">continue</span><span class="Delimiter">;</span>
<span class="Delimiter">:(after &quot;case NEW&quot; following &quot;Primitive Recipe Implementations&quot;)</span>
  if <span class="Delimiter">(</span>is_literal_string<span class="Delimiter">(</span>current_instruction<span class="Delimiter">().</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">)))</span> <span class="Delimiter">{</span>
    products<span class="Delimiter">.</span>resize<span class="Delimiter">(</span><span class="Constant">1</span><span class="Delimiter">);</span>
    products<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>push_back<span class="Delimiter">(</span>new_mu_string<span class="Delimiter">(</span>current_instruction<span class="Delimiter">().</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>name<span class="Delimiter">));</span>
    <span class="Identifier">break</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>

<span class="Delimiter">:(code)</span>
long long int new_mu_string<span class="Delimiter">(</span>const string&amp; contents<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Comment">// allocate an array just large enough for it</span>
  long long int string_length = unicode_length<span class="Delimiter">(</span>contents<span class="Delimiter">);</span>
<span class="CommentedCode">//?   Total_alloc += string_length+1;</span>
<span class="CommentedCode">//?   Num_alloc++;</span>
  ensure_space<span class="Delimiter">(</span>string_length+<span class="Constant">1</span><span class="Delimiter">);</span>  <span class="Comment">// don't forget the extra location for array size</span>
  <span class="Comment">// initialize string</span>
  long long int result = Current_routine<span class="Delimiter">-&gt;</span>alloc<span class="Delimiter">;</span>
  put<span class="Delimiter">(</span>Memory<span class="Delimiter">,</span> Current_routine<span class="Delimiter">-&gt;</span>alloc++<span class="Delimiter">,</span> string_length<span class="Delimiter">);</span>
  long long int curr = <span class="Constant">0</span><span class="Delimiter">;</span>
  const char* raw_contents = contents<span class="Delimiter">.</span>c_str<span class="Delimiter">();</span>
  for <span class="Delimiter">(</span>long long int i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; string_length<span class="Delimiter">;</span> ++i<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    uint32_t curr_character<span class="Delimiter">;</span>
    assert<span class="Delimiter">(</span>curr &lt; SIZE<span class="Delimiter">(</span>contents<span class="Delimiter">));</span>
    tb_utf8_char_to_unicode<span class="Delimiter">(</span>&amp;curr_character<span class="Delimiter">,</span> &amp;raw_contents[curr]<span class="Delimiter">);</span>
    put<span class="Delimiter">(</span>Memory<span class="Delimiter">,</span> Current_routine<span class="Delimiter">-&gt;</span>alloc<span class="Delimiter">,</span> curr_character<span class="Delimiter">);</span>
    curr += tb_utf8_char_length<span class="Delimiter">(</span>raw_contents[curr]<span class="Delimiter">);</span>
    ++Current_routine<span class="Delimiter">-&gt;</span>alloc<span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Comment">// mu strings are not null-terminated in memory</span>
  <span class="Identifier">return</span> result<span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="Comment">//: pass in commandline args as ingredients to main</span>
<span class="Comment">//: todo: test this</span>

<span class="Delimiter">:(after &quot;Update main_routine&quot;)</span>
Current_routine = main_routine<span class="Delimiter">;</span>
for <span class="Delimiter">(</span>long long int i = <span class="Constant">1</span><span class="Delimiter">;</span> i &lt; argc<span class="Delimiter">;</span> ++i<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  vector&lt;double&gt; arg<span class="Delimiter">;</span>
  arg<span class="Delimiter">.</span>push_back<span class="Delimiter">(</span>new_mu_string<span class="Delimiter">(</span>argv[i]<span class="Delimiter">));</span>
  current_call<span class="Delimiter">().</span>ingredient_atoms<span class="Delimiter">.</span>push_back<span class="Delimiter">(</span>arg<span class="Delimiter">);</span>
<span class="Delimiter">}</span>

<span class="Comment">//: stash recognizes strings</span>

<span class="Delimiter">:(scenario stash_string)</span>
recipe main [
  x:address:array:character<span class="Special"> &lt;- </span>new [abc]
  stash [foo:]<span class="Delimiter">,</span> x:address:array:character
]
<span class="traceContains">+app: foo: abc</span>

<span class="Delimiter">:(before &quot;End print Special-cases(reagent r, data)&quot;)</span>
if <span class="Delimiter">(</span>is_mu_string<span class="Delimiter">(</span>r<span class="Delimiter">))</span> <span class="Delimiter">{</span>
  assert<span class="Delimiter">(</span>scalar<span class="Delimiter">(</span>data<span class="Delimiter">));</span>
  <span class="Identifier">return</span> read_mu_string<span class="Delimiter">(</span>data<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">));</span>
<span class="Delimiter">}</span>

<span class="Delimiter">:(scenario unicode_string)</span>
recipe main [
  x:address:array:character<span class="Special"> &lt;- </span>new [♠]
  stash [foo:]<span class="Delimiter">,</span> x:address:array:character
]
<span class="traceContains">+app: foo: ♠</span>

<span class="Comment">//: Allocate more to routine when initializing a literal string</span>
<span class="Delimiter">:(scenario new_string_overflow)</span>
<span class="Special">% Initial_memory_per_routine = 2;</span>
recipe main [
  <span class="Constant">1</span>:address:number/<span class="Special">raw &lt;- </span>new number:type
  <span class="Constant">2</span>:address:array:character/<span class="Special">raw &lt;- </span>new [a]  <span class="Comment"># not enough room in initial page, if you take the array size into account</span>
]
<span class="traceContains">+new: routine allocated memory from 1000 to 1002</span>
<span class="traceContains">+new: routine allocated memory from 1002 to 1004</span>

<span class="Comment">//: helpers</span>
<span class="Delimiter">:(code)</span>
long long int unicode_length<span class="Delimiter">(</span>const string&amp; s<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  const char* in = s<span class="Delimiter">.</span>c_str<span class="Delimiter">();</span>
  long long int result = <span class="Constant">0</span><span class="Delimiter">;</span>
  long long int curr = <span class="Constant">0</span><span class="Delimiter">;</span>
  while <span class="Delimiter">(</span>curr &lt; SIZE<span class="Delimiter">(</span>s<span class="Delimiter">))</span> <span class="Delimiter">{</span>  <span class="Comment">// carefully bounds-check on the string</span>
    <span class="Comment">// before accessing its raw pointer</span>
    ++result<span class="Delimiter">;</span>
    curr += tb_utf8_char_length<span class="Delimiter">(</span>in[curr]<span class="Delimiter">);</span>
  <span class="Delimiter">}</span>
  <span class="Identifier">return</span> result<span class="Delimiter">;</span>
<span class="Delimiter">}</span>

string read_mu_string<span class="Delimiter">(</span>long long int address<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  long long int size = get_or_insert<span class="Delimiter">(</span>Memory<span class="Delimiter">,</span> address<span class="Delimiter">);</span>
  if <span class="Delimiter">(</span>size == <span class="Constant">0</span><span class="Delimiter">)</span> <span class="Identifier">return</span> <span class="Constant">&quot;&quot;</span><span class="Delimiter">;</span>
  ostringstream tmp<span class="Delimiter">;</span>
  for <span class="Delimiter">(</span>long long int curr = address+<span class="Constant">1</span><span class="Delimiter">;</span> curr &lt;= address+size<span class="Delimiter">;</span> ++curr<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    tmp &lt;&lt; to_unicode<span class="Delimiter">(</span>static_cast&lt;uint32_t&gt;<span class="Delimiter">(</span>get_or_insert<span class="Delimiter">(</span>Memory<span class="Delimiter">,</span> curr<span class="Delimiter">)));</span>
  <span class="Delimiter">}</span>
  <span class="Identifier">return</span> tmp<span class="Delimiter">.</span>str<span class="Delimiter">();</span>
<span class="Delimiter">}</span>

bool is_mu_type_literal<span class="Delimiter">(</span>reagent r<span class="Delimiter">)</span> <span class="Delimiter">{</span>
<span class="CommentedCode">//?   if (!r.properties.empty())</span>
<span class="CommentedCode">//?     dump_property(r.properties.at(0).second, cerr);</span>
  <span class="Identifier">return</span> is_literal<span class="Delimiter">(</span>r<span class="Delimiter">)</span> &amp;&amp; !r<span class="Delimiter">.</span>properties<span class="Delimiter">.</span>empty<span class="Delimiter">()</span> &amp;&amp; r<span class="Delimiter">.</span>properties<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>second &amp;&amp; r<span class="Delimiter">.</span>properties<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>second<span class="Delimiter">-&gt;</span>value == <span class="Constant">&quot;type&quot;</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
