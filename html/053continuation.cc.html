<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>Mu - 053continuation.cc</title>
<meta name="Generator" content="Vim/7.4">
<meta name="plugin-version" content="vim7.4_v1">
<meta name="syntax" content="cpp">
<meta name="settings" content="use_css,pre_wrap,no_foldcolumn,expand_tabs,prevent_copy=">
<meta name="colorscheme" content="minimal">
<style type="text/css">
<!--
pre { white-space: pre-wrap; font-family: monospace; color: #eeeeee; background-color: #080808; }
body { font-family: monospace; color: #eeeeee; background-color: #080808; }
* { font-size: 1.05em; }
.cSpecial { color: #008000; }
.SalientComment { color: #00ffff; }
.traceAbsent { color: #c00000; }
.traceContains { color: #008000; }
.Constant { color: #00a0a0; }
.Comment { color: #9090ff; }
.Delimiter { color: #a04060; }
.Special { color: #ff6060; }
.Identifier { color: #804000; }
-->
</style>

<script type='text/javascript'>
<!--

-->
</script>
</head>
<body>
<pre id='vimCodeElement'>
<span class="Comment">//: Continuations are a powerful primitive for constructing advanced kinds of</span>
<span class="Comment">//: control *policies* like back-tracking. They're usually provided using a</span>
<span class="Comment">//: primitive called 'call-cc': <a href="http://en.wikipedia.org/wiki/Call-with-current-continuation)">http://en.wikipedia.org/wiki/Call-with-current-continuation)</a></span>
<span class="Comment">//: But in mu 'call-cc' is constructed out of a combination of two primitives:</span>
<span class="Comment">//:   'current-continuation', which returns a continuation, and</span>
<span class="Comment">//:   'continue-from', which takes a continuation to switch to.</span>

<span class="Comment">//: todo: implement continuations in mu's memory</span>
<span class="Delimiter">:(before &quot;End Globals&quot;)</span>
map&lt;long long int<span class="Delimiter">,</span> call_stack&gt; Continuation<span class="Delimiter">;</span>
long long int Next_continuation_id = <span class="Constant">0</span><span class="Delimiter">;</span>
<span class="Delimiter">:(before &quot;End Setup&quot;)</span>
Continuation<span class="Delimiter">.</span>clear<span class="Delimiter">();</span>
Next_continuation_id = <span class="Constant">0</span><span class="Delimiter">;</span>

<span class="Delimiter">:(before &quot;End Mu Types Initialization&quot;)</span>
type_ordinal continuation = Type_ordinal[<span class="Constant">&quot;continuation&quot;</span>] = Next_type_ordinal++<span class="Delimiter">;</span>
Type[continuation]<span class="Delimiter">.</span>name = <span class="Constant">&quot;continuation&quot;</span><span class="Delimiter">;</span>

<span class="Delimiter">:(before &quot;End Primitive Recipe Declarations&quot;)</span>
CURRENT_CONTINUATION<span class="Delimiter">,</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Numbers&quot;)</span>
Recipe_ordinal[<span class="Constant">&quot;current-continuation&quot;</span>] = CURRENT_CONTINUATION<span class="Delimiter">;</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Implementations&quot;)</span>
case CURRENT_CONTINUATION: <span class="Delimiter">{</span>
  <span class="Comment">// copy the current call stack</span>
  Continuation[Next_continuation_id] = Current_routine<span class="Delimiter">-&gt;</span>calls<span class="Delimiter">;</span>  <span class="Comment">// deep copy because calls have no pointers</span>
  <span class="Comment">// make sure calling the copy doesn't spawn the same continuation again</span>
  ++Continuation[Next_continuation_id]<span class="Delimiter">.</span>front<span class="Delimiter">().</span>running_step_index<span class="Delimiter">;</span>
  products<span class="Delimiter">.</span>resize<span class="Delimiter">(</span><span class="Constant">1</span><span class="Delimiter">);</span>
  products<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>push_back<span class="Delimiter">(</span>Next_continuation_id<span class="Delimiter">);</span>
  ++Next_continuation_id<span class="Delimiter">;</span>
  trace<span class="Delimiter">(</span><span class="Constant">&quot;current-continuation&quot;</span><span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;new continuation &quot;</span> &lt;&lt; Next_continuation_id &lt;&lt; end<span class="Delimiter">();</span>
  <span class="Identifier">break</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="Delimiter">:(before &quot;End Primitive Recipe Declarations&quot;)</span>
CONTINUE_FROM<span class="Delimiter">,</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Numbers&quot;)</span>
Recipe_ordinal[<span class="Constant">&quot;continue-from&quot;</span>] = CONTINUE_FROM<span class="Delimiter">;</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Implementations&quot;)</span>
case CONTINUE_FROM: <span class="Delimiter">{</span>
  if <span class="Delimiter">(</span>!scalar<span class="Delimiter">(</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">)))</span> <span class="Delimiter">{</span>
    raise &lt;&lt; current_recipe_name<span class="Delimiter">()</span> &lt;&lt; <span class="Constant">&quot;: first ingredient of 'continue-from' should be a continuation id generated by 'current-continuation', but got &quot;</span> &lt;&lt; current_instruction<span class="Delimiter">().</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>original_string &lt;&lt; <span class="cSpecial">'\n'</span> &lt;&lt; end<span class="Delimiter">();</span>
    <span class="Identifier">break</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  long long int c = ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">);</span>
  Current_routine<span class="Delimiter">-&gt;</span>calls = Continuation[c]<span class="Delimiter">;</span>  <span class="Comment">// deep copy; calls have no pointers</span>
  <span class="Identifier">continue</span><span class="Delimiter">;</span>  <span class="Comment">// skip rest of this instruction</span>
<span class="Delimiter">}</span>

<span class="Delimiter">:(scenario continuation)</span>
<span class="Comment"># simulate a loop using continuations</span>
recipe main [
  <span class="Constant">1</span>:number<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
  <span class="Constant">2</span>:continuation<span class="Special"> &lt;- </span>current-continuation
  <span class="Delimiter">{</span>
    <span class="Constant">3</span>:boolean<span class="Special"> &lt;- </span>greater-or-equal <span class="Constant">1</span>:number<span class="Delimiter">,</span> <span class="Constant">3</span>
    <span class="Identifier">break</span>-if <span class="Constant">3</span>:boolean
    <span class="Constant">1</span>:number<span class="Special"> &lt;- </span>add <span class="Constant">1</span>:number<span class="Delimiter">,</span> <span class="Constant">1</span>
    <span class="Identifier">continue</span>-from <span class="Constant">2</span>:continuation  <span class="Comment"># loop</span>
  <span class="Delimiter">}</span>
]
<span class="traceContains">+mem: storing 1 in location 1</span>
<span class="traceContains">+mem: storing 2 in location 1</span>
<span class="traceContains">+mem: storing 3 in location 1</span>
<span class="traceAbsent">-mem: storing 4 in location 1</span>
<span class="Comment"># ensure every iteration doesn't copy the stack over and over</span>
$current-continuation: <span class="Constant">1</span>

<span class="Delimiter">:(scenario continuation_inside_caller)</span>
recipe main [
  <span class="Constant">1</span>:number<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
  <span class="Constant">2</span>:continuation<span class="Special"> &lt;- </span>loop-body
  <span class="Delimiter">{</span>
    <span class="Constant">3</span>:boolean<span class="Special"> &lt;- </span>greater-or-equal <span class="Constant">1</span>:number<span class="Delimiter">,</span> <span class="Constant">3</span>
    <span class="Identifier">break</span>-if <span class="Constant">3</span>:boolean
    <span class="Identifier">continue</span>-from <span class="Constant">2</span>:continuation  <span class="Comment"># loop</span>
  <span class="Delimiter">}</span>
]

recipe loop-body [
  <span class="Constant">4</span>:continuation<span class="Special"> &lt;- </span>current-continuation
  <span class="Constant">1</span>:number<span class="Special"> &lt;- </span>add <span class="Constant">1</span>:number<span class="Delimiter">,</span> <span class="Constant">1</span>
]
<span class="traceContains">+mem: storing 1 in location 1</span>
<span class="traceContains">+mem: storing 2 in location 1</span>
<span class="traceContains">+mem: storing 3 in location 1</span>
<span class="traceAbsent">-mem: storing 4 in location 1</span>

<span class="SalientComment">//:: A variant of continuations is the 'delimited' continuation that can be called like any other recipe.</span>
<span class="Comment">//:</span>
<span class="Comment">//: In mu, this is constructed out of two primitives:</span>
<span class="Comment">//:</span>
<span class="Comment">//:  * 'create-delimited-continuation' lays down a mark on the call</span>
<span class="Comment">//:    stack and calls the provided function (it is sometimes called 'prompt')</span>
<span class="Comment">//:  * 'reply-current-continuation' copies the top of the stack until the</span>
<span class="Comment">//:    mark, and returns it as the response of create-delimited-continuation</span>
<span class="Comment">//:    (which might be a distant ancestor on the call stack; intervening calls</span>
<span class="Comment">//:    don't return)</span>
<span class="Comment">//:</span>
<span class="Comment">//: The resulting slice of the stack can now be called just like a regular</span>
<span class="Comment">//: function.</span>

<span class="Delimiter">:(scenario delimited_continuation)</span>
recipe main [
  <span class="Constant">1</span>:continuation<span class="Special"> &lt;- </span>create-delimited-continuation f:recipe <span class="Constant">12</span>  <span class="Comment"># 12 is an argument to f</span>
  <span class="Constant">2</span>:number<span class="Special"> &lt;- </span>copy <span class="Constant">5</span>
  <span class="Delimiter">{</span>
    <span class="Constant">2</span>:number<span class="Special"> &lt;- </span>call <span class="Constant">1</span>:continuation<span class="Delimiter">,</span> <span class="Constant">2</span>:number  <span class="Comment"># 2 is an argument to g, the 'top' of the continuation</span>
    <span class="Constant">3</span>:boolean<span class="Special"> &lt;- </span>greater-or-equal <span class="Constant">2</span>:number<span class="Delimiter">,</span> <span class="Constant">8</span>
    <span class="Identifier">break</span>-if <span class="Constant">3</span>:boolean
    loop
  <span class="Delimiter">}</span>
]

recipe f [
  <span class="Constant">11</span>:number<span class="Special"> &lt;- </span>next-ingredient
  <span class="Constant">12</span>:number<span class="Special"> &lt;- </span>g <span class="Constant">11</span>:number
  reply <span class="Constant">12</span>:number
]

recipe g [
  <span class="Constant">21</span>:number<span class="Special"> &lt;- </span>next-ingredient
  rewind-ingredients
  reply-delimited-continuation
  <span class="Comment"># calls of the continuation start from here</span>
  <span class="Constant">22</span>:number<span class="Special"> &lt;- </span>next-ingredient
  <span class="Constant">23</span>:number<span class="Special"> &lt;- </span>add <span class="Constant">22</span>:number<span class="Delimiter">,</span> <span class="Constant">1</span>
  reply <span class="Constant">23</span>:number
]
<span class="Comment"># first call of 'g' executes the part before reply-delimited-continuation</span>
<span class="traceContains">+mem: storing 12 in location 21</span>
<span class="traceContains">+run: 2:number &lt;- copy 5</span>
<span class="traceContains">+mem: storing 5 in location 2</span>
<span class="Comment"># calls of the continuation execute the part after reply-delimited-continuation</span>
<span class="traceContains">+run: 2:number &lt;- call 1:continuation, 2:number</span>
<span class="traceContains">+mem: storing 5 in location 22</span>
<span class="traceContains">+mem: storing 6 in location 2</span>
<span class="traceContains">+run: 2:number &lt;- call 1:continuation, 2:number</span>
<span class="traceContains">+mem: storing 6 in location 22</span>
<span class="traceContains">+mem: storing 7 in location 2</span>
<span class="traceContains">+run: 2:number &lt;- call 1:continuation, 2:number</span>
<span class="traceContains">+mem: storing 7 in location 22</span>
<span class="traceContains">+mem: storing 8 in location 2</span>
<span class="Comment"># first call of 'g' does not execute the part after reply-delimited-continuation</span>
<span class="traceAbsent">-mem: storing 12 in location 22</span>
<span class="Comment"># calls of the continuation don't execute the part before reply-delimited-continuation</span>
<span class="traceAbsent">-mem: storing 5 in location 21</span>
<span class="traceAbsent">-mem: storing 6 in location 21</span>
<span class="traceAbsent">-mem: storing 7 in location 21</span>
<span class="Comment"># termination</span>
<span class="traceAbsent">-mem: storing 9 in location 2</span>

<span class="Comment">//: 'create-delimited-continuation' is like 'call' except it adds a 'reset' mark to</span>
<span class="Comment">//: the call stack</span>

<span class="Delimiter">:(before &quot;End call Fields&quot;)</span>
bool is_reset<span class="Delimiter">;</span>
<span class="Delimiter">:(before &quot;End call Constructor&quot;)</span>
is_reset = <span class="Constant">false</span><span class="Delimiter">;</span>

<span class="Comment">//: like call, but mark the current call as a 'reset' call before pushing the next one on it</span>

<span class="Delimiter">:(before &quot;End Primitive Recipe Declarations&quot;)</span>
CREATE_DELIMITED_CONTINUATION<span class="Delimiter">,</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Numbers&quot;)</span>
Recipe_ordinal[<span class="Constant">&quot;create-delimited-continuation&quot;</span>] = CREATE_DELIMITED_CONTINUATION<span class="Delimiter">;</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Implementations&quot;)</span>
case CREATE_DELIMITED_CONTINUATION: <span class="Delimiter">{</span>
  Current_routine<span class="Delimiter">-&gt;</span>calls<span class="Delimiter">.</span>front<span class="Delimiter">().</span>is_reset = <span class="Constant">true</span><span class="Delimiter">;</span>
  Current_routine<span class="Delimiter">-&gt;</span>calls<span class="Delimiter">.</span>push_front<span class="Delimiter">(</span>call<span class="Delimiter">(</span>Recipe_ordinal[current_instruction<span class="Delimiter">().</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>name]<span class="Delimiter">));</span>
  ingredients<span class="Delimiter">.</span>erase<span class="Delimiter">(</span>ingredients<span class="Delimiter">.</span>begin<span class="Delimiter">());</span>  <span class="Comment">// drop the callee</span>
  <span class="Identifier">goto</span> call_housekeeping<span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="Comment">//: save the slice of current call stack until the 'create-delimited-continuation'</span>
<span class="Comment">//: call, and return it as the result.</span>
<span class="Comment">//: todo: implement delimited continuations in mu's memory</span>
<span class="Delimiter">:(before &quot;End Globals&quot;)</span>
map&lt;long long int<span class="Delimiter">,</span> call_stack&gt; Delimited_continuation<span class="Delimiter">;</span>
long long int Next_delimited_continuation_id = <span class="Constant">0</span><span class="Delimiter">;</span>
<span class="Delimiter">:(before &quot;End Setup&quot;)</span>
Delimited_continuation<span class="Delimiter">.</span>clear<span class="Delimiter">();</span>
Next_delimited_continuation_id = <span class="Constant">0</span><span class="Delimiter">;</span>

<span class="Delimiter">:(before &quot;End Primitive Recipe Declarations&quot;)</span>
REPLY_DELIMITED_CONTINUATION<span class="Delimiter">,</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Numbers&quot;)</span>
Recipe_ordinal[<span class="Constant">&quot;reply-delimited-continuation&quot;</span>] = REPLY_DELIMITED_CONTINUATION<span class="Delimiter">;</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Implementations&quot;)</span>
case REPLY_DELIMITED_CONTINUATION: <span class="Delimiter">{</span>
  <span class="Comment">// first clear any existing ingredients, to isolate the creation of the</span>
  <span class="Comment">// continuation from its calls</span>
  Current_routine<span class="Delimiter">-&gt;</span>calls<span class="Delimiter">.</span>front<span class="Delimiter">().</span>ingredient_atoms<span class="Delimiter">.</span>clear<span class="Delimiter">();</span>
  Current_routine<span class="Delimiter">-&gt;</span>calls<span class="Delimiter">.</span>front<span class="Delimiter">().</span>next_ingredient_to_process = <span class="Constant">0</span><span class="Delimiter">;</span>
  <span class="Comment">// copy the current call stack until the most recent 'reset' call</span>
  call_stack::iterator find_reset<span class="Delimiter">(</span>call_stack&amp; c<span class="Delimiter">);</span>  <span class="Comment">// manual prototype containing '::'</span>
  call_stack::iterator reset = find_reset<span class="Delimiter">(</span>Current_routine<span class="Delimiter">-&gt;</span>calls<span class="Delimiter">);</span>
  if <span class="Delimiter">(</span>reset == Current_routine<span class="Delimiter">-&gt;</span>calls<span class="Delimiter">.</span>end<span class="Delimiter">())</span> <span class="Delimiter">{</span>
    raise &lt;&lt; current_recipe_name<span class="Delimiter">()</span> &lt;&lt; <span class="Constant">&quot;: couldn't find a 'reset' call to jump out to</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span> &lt;&lt; end<span class="Delimiter">();</span>
    <span class="Identifier">break</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  Delimited_continuation[Next_delimited_continuation_id] = call_stack<span class="Delimiter">(</span>Current_routine<span class="Delimiter">-&gt;</span>calls<span class="Delimiter">.</span>begin<span class="Delimiter">(),</span> reset<span class="Delimiter">);</span>
  while <span class="Delimiter">(</span>Current_routine<span class="Delimiter">-&gt;</span>calls<span class="Delimiter">.</span>begin<span class="Delimiter">()</span> != reset<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    --Callstack_depth<span class="Delimiter">;</span>
    Current_routine<span class="Delimiter">-&gt;</span>calls<span class="Delimiter">.</span>pop_front<span class="Delimiter">();</span>
  <span class="Delimiter">}</span>
  <span class="Comment">// return it as the result of the 'reset' call</span>
  products<span class="Delimiter">.</span>resize<span class="Delimiter">(</span><span class="Constant">1</span><span class="Delimiter">);</span>
  products<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>push_back<span class="Delimiter">(</span>Next_delimited_continuation_id<span class="Delimiter">);</span>
  ++Next_delimited_continuation_id<span class="Delimiter">;</span>
  <span class="Identifier">break</span><span class="Delimiter">;</span>  <span class="Comment">// continue to process rest of 'reset' call</span>
<span class="Delimiter">}</span>

<span class="Delimiter">:(code)</span>
call_stack::iterator find_reset<span class="Delimiter">(</span>call_stack&amp; c<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  for <span class="Delimiter">(</span>call_stack::iterator p = c<span class="Delimiter">.</span>begin<span class="Delimiter">();</span> p != c<span class="Delimiter">.</span>end<span class="Delimiter">();</span> ++p<span class="Delimiter">)</span>
    if <span class="Delimiter">(</span>p<span class="Delimiter">-&gt;</span>is_reset<span class="Delimiter">)</span> <span class="Identifier">return</span> p<span class="Delimiter">;</span>
  <span class="Identifier">return</span> c<span class="Delimiter">.</span>end<span class="Delimiter">();</span>
<span class="Delimiter">}</span>

<span class="Comment">//: overload 'call' for continuations</span>
<span class="Delimiter">:(after &quot;Begin Call&quot;)</span>
  if <span class="Delimiter">(</span>!current_instruction<span class="Delimiter">().</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>properties<span class="Delimiter">.</span>empty<span class="Delimiter">()</span>
      &amp;&amp; !current_instruction<span class="Delimiter">().</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>properties<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>second<span class="Delimiter">.</span>empty<span class="Delimiter">()</span>
      &amp;&amp; current_instruction<span class="Delimiter">().</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>properties<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>second<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">)</span> == <span class="Constant">&quot;continuation&quot;</span><span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Comment">// copy multiple calls on to current call stack</span>
    assert<span class="Delimiter">(</span>scalar<span class="Delimiter">(</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">)));</span>
    if <span class="Delimiter">(</span>Delimited_continuation<span class="Delimiter">.</span>find<span class="Delimiter">(</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">))</span> == Delimited_continuation<span class="Delimiter">.</span>end<span class="Delimiter">())</span> <span class="Delimiter">{</span>
      raise &lt;&lt; current_recipe_name<span class="Delimiter">()</span> &lt;&lt; <span class="Constant">&quot;: no such delimited continuation &quot;</span> &lt;&lt; current_instruction<span class="Delimiter">().</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>original_string &lt;&lt; <span class="cSpecial">'\n'</span> &lt;&lt; end<span class="Delimiter">();</span>
    <span class="Delimiter">}</span>
    const call_stack&amp; new_calls = Delimited_continuation[ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">)</span>]<span class="Delimiter">;</span>
    for <span class="Delimiter">(</span>call_stack::const_reverse_iterator p = new_calls<span class="Delimiter">.</span>rbegin<span class="Delimiter">();</span> p != new_calls<span class="Delimiter">.</span>rend<span class="Delimiter">();</span> ++p<span class="Delimiter">)</span>
      Current_routine<span class="Delimiter">-&gt;</span>calls<span class="Delimiter">.</span>push_front<span class="Delimiter">(</span>*p<span class="Delimiter">);</span>
    ++current_step_index<span class="Delimiter">();</span>  <span class="Comment">// skip past the reply-delimited-continuation</span>
    ingredients<span class="Delimiter">.</span>erase<span class="Delimiter">(</span>ingredients<span class="Delimiter">.</span>begin<span class="Delimiter">());</span>  <span class="Comment">// drop the callee</span>
    <span class="Identifier">goto</span> call_housekeeping<span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
