<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>Mu - 070text.mu</title>
<meta name="Generator" content="Vim/7.4">
<meta name="plugin-version" content="vim7.4_v2">
<meta name="syntax" content="none">
<meta name="settings" content="use_css,pre_wrap,no_foldcolumn,expand_tabs,prevent_copy=">
<meta name="colorscheme" content="minimal">
<style type="text/css">
<!--
pre { white-space: pre-wrap; font-family: monospace; color: #eeeeee; background-color: #080808; }
body { font-size: 12pt; font-family: monospace; color: #eeeeee; background-color: #080808; }
* { font-size: 12pt; font-size: 1em; }
.muRecipe { color: #ff8700; }
.muData { color: #ffff00; }
.muScenario { color: #00af00; }
.Delimiter { color: #800080; }
.Comment { color: #9090ff; }
.Constant { color: #00a0a0; }
.Special { color: #c00000; }
.muControl { color: #c0a020; }
-->
</style>

<script type='text/javascript'>
<!--

-->
</script>
</head>
<body>
<pre id='vimCodeElement'>
<span class="Comment"># Some useful helpers for dealing with text (arrays of characters)</span>

<span class="Comment"># to-text-line gets called implicitly in various places</span>
<span class="Comment"># define it to be identical to 'to-text' by default</span>
<span class="muRecipe">def</span> to-text-line x:_elem<span class="muRecipe"> -&gt; </span>y:address:array:character [
  <span class="Constant">local-scope</span>
  <span class="Constant">load-ingredients</span>
  y<span class="Special"> &lt;- </span>to-text x
]

<span class="Comment"># variant for arrays (since we can't pass them around otherwise)</span>
<span class="muRecipe">def</span> array-to-text-line x:address:array:_elem<span class="muRecipe"> -&gt; </span>y:address:array:character [
  <span class="Constant">local-scope</span>
  <span class="Constant">load-ingredients</span>
  y<span class="Special"> &lt;- </span>to-text *x
]

<span class="Comment"># to-text on text is just the identity function</span>
<span class="muRecipe">def</span> to-text x:address:array:character<span class="muRecipe"> -&gt; </span>y:address:array:character [
  <span class="Constant">local-scope</span>
  <span class="Constant">load-ingredients</span>
  <span class="muControl">return</span> x
]

<span class="muRecipe">def</span> equal a:address:array:character, b:address:array:character<span class="muRecipe"> -&gt; </span>result:boolean [
  <span class="Constant">local-scope</span>
  <span class="Constant">load-ingredients</span>
  a-len:number<span class="Special"> &lt;- </span>length *a
  b-len:number<span class="Special"> &lt;- </span>length *b
  <span class="Comment"># compare lengths</span>
  <span class="Delimiter">{</span>
    trace <span class="Constant">99</span>, <span class="Constant">[text-equal]</span>, <span class="Constant">[comparing lengths]</span>
    length-equal?:boolean<span class="Special"> &lt;- </span>equal a-len, b-len
    <span class="muControl">break-if</span> length-equal?
    <span class="muControl">return</span> <span class="Constant">0</span>
  <span class="Delimiter">}</span>
  <span class="Comment"># compare each corresponding character</span>
  trace <span class="Constant">99</span>, <span class="Constant">[text-equal]</span>, <span class="Constant">[comparing characters]</span>
  i:number<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
  <span class="Delimiter">{</span>
    done?:boolean<span class="Special"> &lt;- </span>greater-or-equal i, a-len
    <span class="muControl">break-if</span> done?
    a2:character<span class="Special"> &lt;- </span>index *a, i
    b2:character<span class="Special"> &lt;- </span>index *b, i
    <span class="Delimiter">{</span>
      chars-match?:boolean<span class="Special"> &lt;- </span>equal a2, b2
      <span class="muControl">break-if</span> chars-match?
      <span class="muControl">return</span> <span class="Constant">0</span>
    <span class="Delimiter">}</span>
    i<span class="Special"> &lt;- </span>add i, <span class="Constant">1</span>
    <span class="muControl">loop</span>
  <span class="Delimiter">}</span>
  <span class="muControl">return</span> <span class="Constant">1</span>
]

<span class="muScenario">scenario</span> text-equal-reflexive [
  run [
    <span class="Constant">default-space</span>:address:array:location<span class="Special"> &lt;- </span>new <span class="Constant">location:type</span>, <span class="Constant">30</span>
    x:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[abc]</span>
    <span class="Constant">3</span>:boolean/<span class="Special">raw &lt;- </span>equal x, x
  ]
  memory-should-contain [
    <span class="Constant">3</span><span class="Special"> &lt;- </span><span class="Constant">1</span>  <span class="Comment"># x == x for all x</span>
  ]
]

<span class="muScenario">scenario</span> text-equal-identical [
  run [
    <span class="Constant">default-space</span>:address:array:location<span class="Special"> &lt;- </span>new <span class="Constant">location:type</span>, <span class="Constant">30</span>
    x:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[abc]</span>
    y:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[abc]</span>
    <span class="Constant">3</span>:boolean/<span class="Special">raw &lt;- </span>equal x, y
  ]
  memory-should-contain [
    <span class="Constant">3</span><span class="Special"> &lt;- </span><span class="Constant">1</span>  <span class="Comment"># abc == abc</span>
  ]
]

<span class="muScenario">scenario</span> text-equal-distinct-lengths [
  run [
    <span class="Constant">default-space</span>:address:array:location<span class="Special"> &lt;- </span>new <span class="Constant">location:type</span>, <span class="Constant">30</span>
    x:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[abc]</span>
    y:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[abcd]</span>
    <span class="Constant">3</span>:boolean/<span class="Special">raw &lt;- </span>equal x, y
  ]
  memory-should-contain [
    <span class="Constant">3</span><span class="Special"> &lt;- </span><span class="Constant">0</span>  <span class="Comment"># abc != abcd</span>
  ]
  trace-should-contain [
    text-equal: comparing lengths
  ]
  trace-should-not-contain [
    text-equal: comparing characters
  ]
]

<span class="muScenario">scenario</span> text-equal-with-empty [
  run [
    <span class="Constant">default-space</span>:address:array:location<span class="Special"> &lt;- </span>new <span class="Constant">location:type</span>, <span class="Constant">30</span>
    x:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[]</span>
    y:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[abcd]</span>
    <span class="Constant">3</span>:boolean/<span class="Special">raw &lt;- </span>equal x, y
  ]
  memory-should-contain [
    <span class="Constant">3</span><span class="Special"> &lt;- </span><span class="Constant">0</span>  <span class="Comment"># &quot;&quot; != abcd</span>
  ]
]

<span class="muScenario">scenario</span> text-equal-common-lengths-but-distinct [
  run [
    <span class="Constant">default-space</span>:address:array:location<span class="Special"> &lt;- </span>new <span class="Constant">location:type</span>, <span class="Constant">30</span>
    x:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[abc]</span>
    y:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[abd]</span>
    <span class="Constant">3</span>:boolean/<span class="Special">raw &lt;- </span>equal x, y
  ]
  memory-should-contain [
    <span class="Constant">3</span><span class="Special"> &lt;- </span><span class="Constant">0</span>  <span class="Comment"># abc != abd</span>
  ]
]

<span class="Comment"># A new type to help incrementally construct texts.</span>
<span class="muData">container</span> buffer [
  length:number
  data:address:array:character
]

<span class="muRecipe">def</span> new-buffer capacity:number<span class="muRecipe"> -&gt; </span>result:address:buffer [
  <span class="Constant">local-scope</span>
  <span class="Constant">load-ingredients</span>
  result<span class="Special"> &lt;- </span>new <span class="Constant">buffer:type</span>
  *result<span class="Special"> &lt;- </span>put *result, <span class="Constant">length:offset</span>, <span class="Constant">0</span>
  data:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">character:type</span>, capacity
  *result<span class="Special"> &lt;- </span>put *result, <span class="Constant">data:offset</span>, data
  <span class="muControl">return</span> result
]

<span class="muRecipe">def</span> grow-buffer in:address:buffer<span class="muRecipe"> -&gt; </span>in:address:buffer [
  <span class="Constant">local-scope</span>
  <span class="Constant">load-ingredients</span>
  <span class="Comment"># double buffer size</span>
  olddata:address:array:character<span class="Special"> &lt;- </span>get *in, <span class="Constant">data:offset</span>
  oldlen:number<span class="Special"> &lt;- </span>length *olddata
  newlen:number<span class="Special"> &lt;- </span>multiply oldlen, <span class="Constant">2</span>
  newdata:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">character:type</span>, newlen
  *in<span class="Special"> &lt;- </span>put *in, <span class="Constant">data:offset</span>, newdata
  <span class="Comment"># copy old contents</span>
  i:number<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
  <span class="Delimiter">{</span>
    done?:boolean<span class="Special"> &lt;- </span>greater-or-equal i, oldlen
    <span class="muControl">break-if</span> done?
    src:character<span class="Special"> &lt;- </span>index *olddata, i
    *newdata<span class="Special"> &lt;- </span>put-index *newdata, i, src
    i<span class="Special"> &lt;- </span>add i, <span class="Constant">1</span>
    <span class="muControl">loop</span>
  <span class="Delimiter">}</span>
]

<span class="muRecipe">def</span> buffer-full? in:address:buffer<span class="muRecipe"> -&gt; </span>result:boolean [
  <span class="Constant">local-scope</span>
  <span class="Constant">load-ingredients</span>
  len:number<span class="Special"> &lt;- </span>get *in, <span class="Constant">length:offset</span>
  s:address:array:character<span class="Special"> &lt;- </span>get *in, <span class="Constant">data:offset</span>
  capacity:number<span class="Special"> &lt;- </span>length *s
  result<span class="Special"> &lt;- </span>greater-or-equal len, capacity
]

<span class="Comment"># most broadly applicable definition of append to a buffer: just call to-text</span>
<span class="muRecipe">def</span> append buf:address:buffer, x:_elem<span class="muRecipe"> -&gt; </span>buf:address:buffer [
  <span class="Constant">local-scope</span>
  <span class="Constant">load-ingredients</span>
  text:address:array:character<span class="Special"> &lt;- </span>to-text x
  len:number<span class="Special"> &lt;- </span>length *text
  i:number<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
  <span class="Delimiter">{</span>
    done?:boolean<span class="Special"> &lt;- </span>greater-or-equal i, len
    <span class="muControl">break-if</span> done?
    c:character<span class="Special"> &lt;- </span>index *text, i
    buf<span class="Special"> &lt;- </span>append buf, c
    i<span class="Special"> &lt;- </span>add i, <span class="Constant">1</span>
    <span class="muControl">loop</span>
  <span class="Delimiter">}</span>
]

<span class="muRecipe">def</span> append in:address:buffer, c:character<span class="muRecipe"> -&gt; </span>in:address:buffer [
  <span class="Constant">local-scope</span>
  <span class="Constant">load-ingredients</span>
  len:number<span class="Special"> &lt;- </span>get *in, <span class="Constant">length:offset</span>
  <span class="Delimiter">{</span>
    <span class="Comment"># backspace? just drop last character if it exists and return</span>
    backspace?:boolean<span class="Special"> &lt;- </span>equal c, <span class="Constant">8/backspace</span>
    <span class="muControl">break-unless</span> backspace?
    empty?:boolean<span class="Special"> &lt;- </span>lesser-or-equal len, <span class="Constant">0</span>
    <span class="muControl">return-if</span> empty?
    len<span class="Special"> &lt;- </span>subtract len, <span class="Constant">1</span>
    *in<span class="Special"> &lt;- </span>put *in, <span class="Constant">length:offset</span>, len
    <span class="muControl">return</span>
  <span class="Delimiter">}</span>
  <span class="Delimiter">{</span>
    <span class="Comment"># grow buffer if necessary</span>
    full?:boolean<span class="Special"> &lt;- </span>buffer-full? in
    <span class="muControl">break-unless</span> full?
    in<span class="Special"> &lt;- </span>grow-buffer in
  <span class="Delimiter">}</span>
  s:address:array:character<span class="Special"> &lt;- </span>get *in, <span class="Constant">data:offset</span>
  *s<span class="Special"> &lt;- </span>put-index *s, len, c
  len<span class="Special"> &lt;- </span>add len, <span class="Constant">1</span>
  *in<span class="Special"> &lt;- </span>put *in, <span class="Constant">length:offset</span>, len
]

<span class="muScenario">scenario</span> buffer-append-works [
  run [
    <span class="Constant">local-scope</span>
    x:address:buffer<span class="Special"> &lt;- </span>new-buffer <span class="Constant">3</span>
    s1:address:array:character<span class="Special"> &lt;- </span>get *x, <span class="Constant">data:offset</span>
    c:character<span class="Special"> &lt;- </span>copy <span class="Constant">97/a</span>
    x<span class="Special"> &lt;- </span>append x, c
    c:character<span class="Special"> &lt;- </span>copy <span class="Constant">98/b</span>
    x<span class="Special"> &lt;- </span>append x, c
    c:character<span class="Special"> &lt;- </span>copy <span class="Constant">99/c</span>
    x<span class="Special"> &lt;- </span>append x, c
    s2:address:array:character<span class="Special"> &lt;- </span>get *x, <span class="Constant">data:offset</span>
    <span class="Constant">1</span>:boolean/<span class="Special">raw &lt;- </span>equal s1, s2
    <span class="Constant">2</span>:array:character/<span class="Special">raw &lt;- </span>copy *s2
<span class="Constant">    +buffer-filled</span>
    c:character<span class="Special"> &lt;- </span>copy <span class="Constant">100/d</span>
    x<span class="Special"> &lt;- </span>append x, c
    s3:address:array:character<span class="Special"> &lt;- </span>get *x, <span class="Constant">data:offset</span>
    <span class="Constant">10</span>:boolean/<span class="Special">raw &lt;- </span>equal s1, s3
    <span class="Constant">11</span>:number/<span class="Special">raw &lt;- </span>get *x, <span class="Constant">length:offset</span>
    <span class="Constant">12</span>:array:character/<span class="Special">raw &lt;- </span>copy *s3
  ]
  memory-should-contain [
    <span class="Comment"># before +buffer-filled</span>
    <span class="Constant">1</span><span class="Special"> &lt;- </span><span class="Constant">1</span>   <span class="Comment"># no change in data pointer</span>
    <span class="Constant">2</span><span class="Special"> &lt;- </span><span class="Constant">3</span>   <span class="Comment"># size of data</span>
    <span class="Constant">3</span><span class="Special"> &lt;- </span><span class="Constant">97</span>  <span class="Comment"># data</span>
    <span class="Constant">4</span><span class="Special"> &lt;- </span><span class="Constant">98</span>
    <span class="Constant">5</span><span class="Special"> &lt;- </span><span class="Constant">99</span>
    <span class="Comment"># in the end</span>
    <span class="Constant">10</span><span class="Special"> &lt;- </span><span class="Constant">0</span>   <span class="Comment"># data pointer has grown</span>
    <span class="Constant">11</span><span class="Special"> &lt;- </span><span class="Constant">4</span>   <span class="Comment"># final length</span>
    <span class="Constant">12</span><span class="Special"> &lt;- </span><span class="Constant">6</span>   <span class="Comment"># but data's capacity has doubled</span>
    <span class="Constant">13</span><span class="Special"> &lt;- </span><span class="Constant">97</span>  <span class="Comment"># data</span>
    <span class="Constant">14</span><span class="Special"> &lt;- </span><span class="Constant">98</span>
    <span class="Constant">15</span><span class="Special"> &lt;- </span><span class="Constant">99</span>
    <span class="Constant">16</span><span class="Special"> &lt;- </span><span class="Constant">100</span>
    <span class="Constant">17</span><span class="Special"> &lt;- </span><span class="Constant">0</span>
    <span class="Constant">18</span><span class="Special"> &lt;- </span><span class="Constant">0</span>
  ]
]

<span class="muScenario">scenario</span> buffer-append-handles-backspace [
  run [
    <span class="Constant">local-scope</span>
    x:address:buffer<span class="Special"> &lt;- </span>new-buffer <span class="Constant">3</span>
    c:character<span class="Special"> &lt;- </span>copy <span class="Constant">97/a</span>
    x<span class="Special"> &lt;- </span>append x, c
    c:character<span class="Special"> &lt;- </span>copy <span class="Constant">98/b</span>
    x<span class="Special"> &lt;- </span>append x, c
    c:character<span class="Special"> &lt;- </span>copy <span class="Constant">8/backspace</span>
    x<span class="Special"> &lt;- </span>append x, c
    s:address:array:character<span class="Special"> &lt;- </span>buffer-to-array x
    <span class="Constant">1</span>:array:character/<span class="Special">raw &lt;- </span>copy *s
  ]
  memory-should-contain [
    <span class="Constant">1</span><span class="Special"> &lt;- </span><span class="Constant">1</span>   <span class="Comment"># length</span>
    <span class="Constant">2</span><span class="Special"> &lt;- </span><span class="Constant">97</span>  <span class="Comment"># contents</span>
    <span class="Constant">3</span><span class="Special"> &lt;- </span><span class="Constant">0</span>
  ]
]

<span class="muRecipe">def</span> to-text n:number<span class="muRecipe"> -&gt; </span>result:address:array:character [
  <span class="Constant">local-scope</span>
  <span class="Constant">load-ingredients</span>
  <span class="Comment"># is n zero?</span>
  <span class="Delimiter">{</span>
    <span class="muControl">break-if</span> n
    result<span class="Special"> &lt;- </span>new <span class="Constant">[0]</span>
    <span class="muControl">return</span>
  <span class="Delimiter">}</span>
  <span class="Comment"># save sign</span>
  negate-result:boolean<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
  <span class="Delimiter">{</span>
    negative?:boolean<span class="Special"> &lt;- </span>lesser-than n, <span class="Constant">0</span>
    <span class="muControl">break-unless</span> negative?
    negate-result<span class="Special"> &lt;- </span>copy <span class="Constant">1</span>
    n<span class="Special"> &lt;- </span>multiply n, <span class="Constant">-1</span>
  <span class="Delimiter">}</span>
  <span class="Comment"># add digits from right to left into intermediate buffer</span>
  tmp:address:buffer<span class="Special"> &lt;- </span>new-buffer <span class="Constant">30</span>
  digit-base:number<span class="Special"> &lt;- </span>copy <span class="Constant">48</span>  <span class="Comment"># '0'</span>
  <span class="Delimiter">{</span>
    done?:boolean<span class="Special"> &lt;- </span>equal n, <span class="Constant">0</span>
    <span class="muControl">break-if</span> done?
    n, digit:number<span class="Special"> &lt;- </span>divide-with-remainder n, <span class="Constant">10</span>
    c:character<span class="Special"> &lt;- </span>add digit-base, digit
    tmp:address:buffer<span class="Special"> &lt;- </span>append tmp, c
    <span class="muControl">loop</span>
  <span class="Delimiter">}</span>
  <span class="Comment"># add sign</span>
  <span class="Delimiter">{</span>
    <span class="muControl">break-unless</span> negate-result:boolean
    minus:character<span class="Special"> &lt;- </span>copy <span class="Constant">45/-</span>
    tmp<span class="Special"> &lt;- </span>append tmp, minus
  <span class="Delimiter">}</span>
  <span class="Comment"># reverse buffer into text result</span>
  len:number<span class="Special"> &lt;- </span>get *tmp, <span class="Constant">length:offset</span>
  buf:address:array:character<span class="Special"> &lt;- </span>get *tmp, <span class="Constant">data:offset</span>
  result<span class="Special"> &lt;- </span>new <span class="Constant">character:type</span>, len
  i:number<span class="Special"> &lt;- </span>subtract len, <span class="Constant">1</span>  <span class="Comment"># source index, decreasing</span>
  j:number<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>  <span class="Comment"># destination index, increasing</span>
  <span class="Delimiter">{</span>
    <span class="Comment"># while i &gt;= 0</span>
    done?:boolean<span class="Special"> &lt;- </span>lesser-than i, <span class="Constant">0</span>
    <span class="muControl">break-if</span> done?
    <span class="Comment"># result[j] = tmp[i]</span>
    src:character<span class="Special"> &lt;- </span>index *buf, i
    *result<span class="Special"> &lt;- </span>put-index *result, j, src
    i<span class="Special"> &lt;- </span>subtract i, <span class="Constant">1</span>
    j<span class="Special"> &lt;- </span>add j, <span class="Constant">1</span>
    <span class="muControl">loop</span>
  <span class="Delimiter">}</span>
]

<span class="muRecipe">def</span> to-text x:boolean<span class="muRecipe"> -&gt; </span>result:address:array:character [
  <span class="Constant">local-scope</span>
  <span class="Constant">load-ingredients</span>
  n:number<span class="Special"> &lt;- </span>copy x:boolean
  result<span class="Special"> &lt;- </span>to-text n
]

<span class="muRecipe">def</span> to-text x:address:_elem<span class="muRecipe"> -&gt; </span>result:address:array:character [
  <span class="Constant">local-scope</span>
  <span class="Constant">load-ingredients</span>
  n:number<span class="Special"> &lt;- </span>copy x
  result<span class="Special"> &lt;- </span>to-text n
]

<span class="muRecipe">def</span> buffer-to-array in:address:buffer<span class="muRecipe"> -&gt; </span>result:address:array:character [
  <span class="Constant">local-scope</span>
  <span class="Constant">load-ingredients</span>
  <span class="Delimiter">{</span>
    <span class="Comment"># propagate null buffer</span>
    <span class="muControl">break-if</span> in
    <span class="muControl">return</span> <span class="Constant">0</span>
  <span class="Delimiter">}</span>
  len:number<span class="Special"> &lt;- </span>get *in, <span class="Constant">length:offset</span>
  s:address:array:character<span class="Special"> &lt;- </span>get *in, <span class="Constant">data:offset</span>
  <span class="Comment"># we can't just return s because it is usually the wrong length</span>
  result<span class="Special"> &lt;- </span>new <span class="Constant">character:type</span>, len
  i:number<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
  <span class="Delimiter">{</span>
    done?:boolean<span class="Special"> &lt;- </span>greater-or-equal i, len
    <span class="muControl">break-if</span> done?
    src:character<span class="Special"> &lt;- </span>index *s, i
    *result<span class="Special"> &lt;- </span>put-index *result, i, src
    i<span class="Special"> &lt;- </span>add i, <span class="Constant">1</span>
    <span class="muControl">loop</span>
  <span class="Delimiter">}</span>
]

<span class="muScenario">scenario</span> integer-to-decimal-digit-zero [
  run [
    <span class="Constant">1</span>:address:array:character/<span class="Special">raw &lt;- </span>to-text <span class="Constant">0</span>
    <span class="Constant">2</span>:array:character/<span class="Special">raw &lt;- </span>copy *<span class="Constant">1</span>:address:array:character/<span class="Special">raw</span>
  ]
  memory-should-contain [
    <span class="Constant">2</span>:array:character<span class="Special"> &lt;- </span><span class="Constant">[0]</span>
  ]
]

<span class="muScenario">scenario</span> integer-to-decimal-digit-positive [
  run [
    <span class="Constant">1</span>:address:array:character/<span class="Special">raw &lt;- </span>to-text <span class="Constant">234</span>
    <span class="Constant">2</span>:array:character/<span class="Special">raw &lt;- </span>copy *<span class="Constant">1</span>:address:array:character/<span class="Special">raw</span>
  ]
  memory-should-contain [
    <span class="Constant">2</span>:array:character<span class="Special"> &lt;- </span><span class="Constant">[234]</span>
  ]
]

<span class="muScenario">scenario</span> integer-to-decimal-digit-negative [
  run [
    <span class="Constant">1</span>:address:array:character/<span class="Special">raw &lt;- </span>to-text <span class="Constant">-1</span>
    <span class="Constant">2</span>:array:character/<span class="Special">raw &lt;- </span>copy *<span class="Constant">1</span>:address:array:character/<span class="Special">raw</span>
  ]
  memory-should-contain [
    <span class="Constant">2</span><span class="Special"> &lt;- </span><span class="Constant">2</span>
    <span class="Constant">3</span><span class="Special"> &lt;- </span><span class="Constant">45</span>  <span class="Comment"># '-'</span>
    <span class="Constant">4</span><span class="Special"> &lt;- </span><span class="Constant">49</span>  <span class="Comment"># '1'</span>
  ]
]

<span class="muRecipe">def</span> append a:address:array:character, b:address:array:character<span class="muRecipe"> -&gt; </span>result:address:array:character [
  <span class="Constant">local-scope</span>
  <span class="Constant">load-ingredients</span>
  <span class="Comment"># result = new character[a.length + b.length]</span>
  a-len:number<span class="Special"> &lt;- </span>length *a
  b-len:number<span class="Special"> &lt;- </span>length *b
  result-len:number<span class="Special"> &lt;- </span>add a-len, b-len
  result<span class="Special"> &lt;- </span>new <span class="Constant">character:type</span>, result-len
  <span class="Comment"># copy a into result</span>
  result-idx:number<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
  i:number<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
  <span class="Delimiter">{</span>
    <span class="Comment"># while i &lt; a.length</span>
    a-done?:boolean<span class="Special"> &lt;- </span>greater-or-equal i, a-len
    <span class="muControl">break-if</span> a-done?
    <span class="Comment"># result[result-idx] = a[i]</span>
    in:character<span class="Special"> &lt;- </span>index *a, i
    *result<span class="Special"> &lt;- </span>put-index *result, result-idx, in
    i<span class="Special"> &lt;- </span>add i, <span class="Constant">1</span>
    result-idx<span class="Special"> &lt;- </span>add result-idx, <span class="Constant">1</span>
    <span class="muControl">loop</span>
  <span class="Delimiter">}</span>
  <span class="Comment"># copy b into result</span>
  i<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
  <span class="Delimiter">{</span>
    <span class="Comment"># while i &lt; b.length</span>
    b-done?:boolean<span class="Special"> &lt;- </span>greater-or-equal i, b-len
    <span class="muControl">break-if</span> b-done?
    <span class="Comment"># result[result-idx] = a[i]</span>
    in:character<span class="Special"> &lt;- </span>index *b, i
    *result<span class="Special"> &lt;- </span>put-index *result, result-idx, in
    i<span class="Special"> &lt;- </span>add i, <span class="Constant">1</span>
    result-idx<span class="Special"> &lt;- </span>add result-idx, <span class="Constant">1</span>
    <span class="muControl">loop</span>
  <span class="Delimiter">}</span>
]

<span class="muScenario">scenario</span> text-append-1 [
  run [
    <span class="Constant">1</span>:address:array:character/<span class="Special">raw &lt;- </span>new <span class="Constant">[hello,]</span>
    <span class="Constant">2</span>:address:array:character/<span class="Special">raw &lt;- </span>new <span class="Constant">[ world!]</span>
    <span class="Constant">3</span>:address:array:character/<span class="Special">raw &lt;- </span>append <span class="Constant">1</span>:address:array:character/<span class="Special">raw</span>, <span class="Constant">2</span>:address:array:character/<span class="Special">raw</span>
    <span class="Constant">4</span>:array:character/<span class="Special">raw &lt;- </span>copy *<span class="Constant">3</span>:address:array:character/<span class="Special">raw</span>
  ]
  memory-should-contain [
    <span class="Constant">4</span>:array:character<span class="Special"> &lt;- </span><span class="Constant">[hello, world!]</span>
  ]
]

<span class="muScenario">scenario</span> replace-character-in-text [
  run [
    <span class="Constant">1</span>:address:array:character/<span class="Special">raw &lt;- </span>new <span class="Constant">[abc]</span>
    <span class="Constant">1</span>:address:array:character/<span class="Special">raw &lt;- </span>replace <span class="Constant">1</span>:address:array:character/<span class="Special">raw</span>, <span class="Constant">98/b</span>, <span class="Constant">122/z</span>
    <span class="Constant">2</span>:array:character/<span class="Special">raw &lt;- </span>copy *<span class="Constant">1</span>:address:array:character/<span class="Special">raw</span>
  ]
  memory-should-contain [
    <span class="Constant">2</span>:array:character<span class="Special"> &lt;- </span><span class="Constant">[azc]</span>
  ]
]

<span class="muRecipe">def</span> replace s:address:array:character, oldc:character, newc:character, from:number/optional<span class="muRecipe"> -&gt; </span>s:address:array:character [
  <span class="Constant">local-scope</span>
  <span class="Constant">load-ingredients</span>
  len:number<span class="Special"> &lt;- </span>length *s
  i:number<span class="Special"> &lt;- </span>find-next s, oldc, from
  done?:boolean<span class="Special"> &lt;- </span>greater-or-equal i, len
  <span class="muControl">return-if</span> done?, s/same-as-ingredient:<span class="Constant">0</span>
  *s<span class="Special"> &lt;- </span>put-index *s, i, newc
  i<span class="Special"> &lt;- </span>add i, <span class="Constant">1</span>
  s<span class="Special"> &lt;- </span>replace s, oldc, newc, i
]

<span class="muScenario">scenario</span> replace-character-at-start [
  run [
    <span class="Constant">1</span>:address:array:character/<span class="Special">raw &lt;- </span>new <span class="Constant">[abc]</span>
    <span class="Constant">1</span>:address:array:character/<span class="Special">raw &lt;- </span>replace <span class="Constant">1</span>:address:array:character/<span class="Special">raw</span>, <span class="Constant">97/a</span>, <span class="Constant">122/z</span>
    <span class="Constant">2</span>:array:character/<span class="Special">raw &lt;- </span>copy *<span class="Constant">1</span>:address:array:character/<span class="Special">raw</span>
  ]
  memory-should-contain [
    <span class="Constant">2</span>:array:character<span class="Special"> &lt;- </span><span class="Constant">[zbc]</span>
  ]
]

<span class="muScenario">scenario</span> replace-character-at-end [
  run [
    <span class="Constant">1</span>:address:array:character/<span class="Special">raw &lt;- </span>new <span class="Constant">[abc]</span>
    <span class="Constant">1</span>:address:array:character/<span class="Special">raw &lt;- </span>replace <span class="Constant">1</span>:address:array:character/<span class="Special">raw</span>, <span class="Constant">99/c</span>, <span class="Constant">122/z</span>
    <span class="Constant">2</span>:array:character/<span class="Special">raw &lt;- </span>copy *<span class="Constant">1</span>:address:array:character/<span class="Special">raw</span>
  ]
  memory-should-contain [
    <span class="Constant">2</span>:array:character<span class="Special"> &lt;- </span><span class="Constant">[abz]</span>
  ]
]

<span class="muScenario">scenario</span> replace-character-missing [
  run [
    <span class="Constant">1</span>:address:array:character/<span class="Special">raw &lt;- </span>new <span class="Constant">[abc]</span>
    <span class="Constant">1</span>:address:array:character/<span class="Special">raw &lt;- </span>replace <span class="Constant">1</span>:address:array:character/<span class="Special">raw</span>, <span class="Constant">100/d</span>, <span class="Constant">122/z</span>
    <span class="Constant">2</span>:array:character/<span class="Special">raw &lt;- </span>copy *<span class="Constant">1</span>:address:array:character/<span class="Special">raw</span>
  ]
  memory-should-contain [
    <span class="Constant">2</span>:array:character<span class="Special"> &lt;- </span><span class="Constant">[abc]</span>
  ]
]

<span class="muScenario">scenario</span> replace-all-characters [
  run [
    <span class="Constant">1</span>:address:array:character/<span class="Special">raw &lt;- </span>new <span class="Constant">[banana]</span>
    <span class="Constant">1</span>:address:array:character/<span class="Special">raw &lt;- </span>replace <span class="Constant">1</span>:address:array:character/<span class="Special">raw</span>, <span class="Constant">97/a</span>, <span class="Constant">122/z</span>
    <span class="Constant">2</span>:array:character/<span class="Special">raw &lt;- </span>copy *<span class="Constant">1</span>:address:array:character/<span class="Special">raw</span>
  ]
  memory-should-contain [
    <span class="Constant">2</span>:array:character<span class="Special"> &lt;- </span><span class="Constant">[bznznz]</span>
  ]
]

<span class="Comment"># replace underscores in first with remaining args</span>
<span class="muRecipe">def</span> interpolate template:address:array:character<span class="muRecipe"> -&gt; </span>result:address:array:character [
  <span class="Constant">local-scope</span>
  <span class="Constant">load-ingredients</span>  <span class="Comment"># consume just the template</span>
  <span class="Comment"># compute result-len, space to allocate for result</span>
  tem-len:number<span class="Special"> &lt;- </span>length *template
  result-len:number<span class="Special"> &lt;- </span>copy tem-len
  <span class="Delimiter">{</span>
    <span class="Comment"># while ingredients remain</span>
    a:address:array:character, arg-received?:boolean<span class="Special"> &lt;- </span><span class="Constant">next-ingredient</span>
    <span class="muControl">break-unless</span> arg-received?
    <span class="Comment"># result-len = result-len + arg.length - 1 (for the 'underscore' being replaced)</span>
    a-len:number<span class="Special"> &lt;- </span>length *a
    result-len<span class="Special"> &lt;- </span>add result-len, a-len
    result-len<span class="Special"> &lt;- </span>subtract result-len, <span class="Constant">1</span>
    <span class="muControl">loop</span>
  <span class="Delimiter">}</span>
  <span class="Constant">rewind-ingredients</span>
  _<span class="Special"> &lt;- </span><span class="Constant">next-ingredient</span>  <span class="Comment"># skip template</span>
  result<span class="Special"> &lt;- </span>new <span class="Constant">character:type</span>, result-len
  <span class="Comment"># repeatedly copy sections of template and 'holes' into result</span>
  result-idx:number<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
  i:number<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
  <span class="Delimiter">{</span>
    <span class="Comment"># while arg received</span>
    a:address:array:character, arg-received?:boolean<span class="Special"> &lt;- </span><span class="Constant">next-ingredient</span>
    <span class="muControl">break-unless</span> arg-received?
    <span class="Comment"># copy template into result until '_'</span>
    <span class="Delimiter">{</span>
      <span class="Comment"># while i &lt; template.length</span>
      tem-done?:boolean<span class="Special"> &lt;- </span>greater-or-equal i, tem-len
      <span class="muControl">break-if</span> tem-done?, <span class="Constant">+done:label</span>
      <span class="Comment"># while template[i] != '_'</span>
      in:character<span class="Special"> &lt;- </span>index *template, i
      underscore?:boolean<span class="Special"> &lt;- </span>equal in, <span class="Constant">95/_</span>
      <span class="muControl">break-if</span> underscore?
      <span class="Comment"># result[result-idx] = template[i]</span>
      *result<span class="Special"> &lt;- </span>put-index *result, result-idx, in
      i<span class="Special"> &lt;- </span>add i, <span class="Constant">1</span>
      result-idx<span class="Special"> &lt;- </span>add result-idx, <span class="Constant">1</span>
      <span class="muControl">loop</span>
    <span class="Delimiter">}</span>
    <span class="Comment"># copy 'a' into result</span>
    j:number<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
    <span class="Delimiter">{</span>
      <span class="Comment"># while j &lt; a.length</span>
      arg-done?:boolean<span class="Special"> &lt;- </span>greater-or-equal j, a-len
      <span class="muControl">break-if</span> arg-done?
      <span class="Comment"># result[result-idx] = a[j]</span>
      in:character<span class="Special"> &lt;- </span>index *a, j
      *result<span class="Special"> &lt;- </span>put-index *result, result-idx, in
      j<span class="Special"> &lt;- </span>add j, <span class="Constant">1</span>
      result-idx<span class="Special"> &lt;- </span>add result-idx, <span class="Constant">1</span>
      <span class="muControl">loop</span>
    <span class="Delimiter">}</span>
    <span class="Comment"># skip '_' in template</span>
    i<span class="Special"> &lt;- </span>add i, <span class="Constant">1</span>
    <span class="muControl">loop</span>  <span class="Comment"># interpolate next arg</span>
  <span class="Delimiter">}</span>
<span class="Constant">  +done</span>
  <span class="Comment"># done with holes; copy rest of template directly into result</span>
  <span class="Delimiter">{</span>
    <span class="Comment"># while i &lt; template.length</span>
    tem-done?:boolean<span class="Special"> &lt;- </span>greater-or-equal i, tem-len
    <span class="muControl">break-if</span> tem-done?
    <span class="Comment"># result[result-idx] = template[i]</span>
    in:character<span class="Special"> &lt;- </span>index *template, i
    *result<span class="Special"> &lt;- </span>put-index *result, result-idx, in
    i<span class="Special"> &lt;- </span>add i, <span class="Constant">1</span>
    result-idx<span class="Special"> &lt;- </span>add result-idx, <span class="Constant">1</span>
    <span class="muControl">loop</span>
  <span class="Delimiter">}</span>
]

<span class="muScenario">scenario</span> interpolate-works [
  run [
    <span class="Constant">1</span>:address:array:character/<span class="Special">raw &lt;- </span>new <span class="Constant">[abc _]</span>
    <span class="Constant">2</span>:address:array:character/<span class="Special">raw &lt;- </span>new <span class="Constant">[def]</span>
    <span class="Constant">3</span>:address:array:character/<span class="Special">raw &lt;- </span>interpolate <span class="Constant">1</span>:address:array:character/<span class="Special">raw</span>, <span class="Constant">2</span>:address:array:character/<span class="Special">raw</span>
    <span class="Constant">4</span>:array:character/<span class="Special">raw &lt;- </span>copy *<span class="Constant">3</span>:address:array:character/<span class="Special">raw</span>
  ]
  memory-should-contain [
    <span class="Constant">4</span>:array:character<span class="Special"> &lt;- </span><span class="Constant">[abc def]</span>
  ]
]

<span class="muScenario">scenario</span> interpolate-at-start [
  run [
    <span class="Constant">1</span>:address:array:character/<span class="Special">raw &lt;- </span>new <span class="Constant">[_, hello!]</span>
    <span class="Constant">2</span>:address:array:character/<span class="Special">raw &lt;- </span>new <span class="Constant">[abc]</span>
    <span class="Constant">3</span>:address:array:character/<span class="Special">raw &lt;- </span>interpolate <span class="Constant">1</span>:address:array:character/<span class="Special">raw</span>, <span class="Constant">2</span>:address:array:character/<span class="Special">raw</span>
    <span class="Constant">4</span>:array:character/<span class="Special">raw &lt;- </span>copy *<span class="Constant">3</span>:address:array:character/<span class="Special">raw</span>
  ]
  memory-should-contain [
    <span class="Constant">4</span>:array:character<span class="Special"> &lt;- </span><span class="Constant">[abc, hello!]</span>
    <span class="Constant">16</span><span class="Special"> &lt;- </span><span class="Constant">0</span>  <span class="Comment"># out of bounds</span>
  ]
]

<span class="muScenario">scenario</span> interpolate-at-end [
  run [
    <span class="Constant">1</span>:address:array:character/<span class="Special">raw &lt;- </span>new <span class="Constant">[hello, _]</span>
    <span class="Constant">2</span>:address:array:character/<span class="Special">raw &lt;- </span>new <span class="Constant">[abc]</span>
    <span class="Constant">3</span>:address:array:character/<span class="Special">raw &lt;- </span>interpolate <span class="Constant">1</span>:address:array:character/<span class="Special">raw</span>, <span class="Constant">2</span>:address:array:character/<span class="Special">raw</span>
    <span class="Constant">4</span>:array:character/<span class="Special">raw &lt;- </span>copy *<span class="Constant">3</span>:address:array:character/<span class="Special">raw</span>
  ]
  memory-should-contain [
    <span class="Constant">4</span>:array:character<span class="Special"> &lt;- </span><span class="Constant">[hello, abc]</span>
  ]
]

<span class="Comment"># result:boolean &lt;- space? c:character</span>
<span class="muRecipe">def</span> space? c:character<span class="muRecipe"> -&gt; </span>result:boolean [
  <span class="Constant">local-scope</span>
  <span class="Constant">load-ingredients</span>
  <span class="Comment"># most common case first</span>
  result<span class="Special"> &lt;- </span>equal c, <span class="Constant">32/space</span>
  <span class="muControl">return-if</span> result
  result<span class="Special"> &lt;- </span>equal c, <span class="Constant">10/newline</span>
  <span class="muControl">return-if</span> result
  result<span class="Special"> &lt;- </span>equal c, <span class="Constant">9/tab</span>
  <span class="muControl">return-if</span> result
  result<span class="Special"> &lt;- </span>equal c, <span class="Constant">13/carriage-return</span>
  <span class="muControl">return-if</span> result
  <span class="Comment"># remaining uncommon cases in sorted order</span>
  <span class="Comment"># <a href="http://unicode.org">http://unicode.org</a> code-points in unicode-set Z and Pattern_White_Space</span>
  result<span class="Special"> &lt;- </span>equal c, <span class="Constant">11/ctrl-k</span>
  <span class="muControl">return-if</span> result
  result<span class="Special"> &lt;- </span>equal c, <span class="Constant">12/ctrl-l</span>
  <span class="muControl">return-if</span> result
  result<span class="Special"> &lt;- </span>equal c, <span class="Constant">133/ctrl-0085</span>
  <span class="muControl">return-if</span> result
  result<span class="Special"> &lt;- </span>equal c, <span class="Constant">160/no-break-space</span>
  <span class="muControl">return-if</span> result
  result<span class="Special"> &lt;- </span>equal c, <span class="Constant">5760/ogham-space-mark</span>
  <span class="muControl">return-if</span> result
  result<span class="Special"> &lt;- </span>equal c, <span class="Constant">8192/en-quad</span>
  <span class="muControl">return-if</span> result
  result<span class="Special"> &lt;- </span>equal c, <span class="Constant">8193/em-quad</span>
  <span class="muControl">return-if</span> result
  result<span class="Special"> &lt;- </span>equal c, <span class="Constant">8194/en-space</span>
  <span class="muControl">return-if</span> result
  result<span class="Special"> &lt;- </span>equal c, <span class="Constant">8195/em-space</span>
  <span class="muControl">return-if</span> result
  result<span class="Special"> &lt;- </span>equal c, <span class="Constant">8196/three-per-em-space</span>
  <span class="muControl">return-if</span> result
  result<span class="Special"> &lt;- </span>equal c, <span class="Constant">8197/four-per-em-space</span>
  <span class="muControl">return-if</span> result
  result<span class="Special"> &lt;- </span>equal c, <span class="Constant">8198/six-per-em-space</span>
  <span class="muControl">return-if</span> result
  result<span class="Special"> &lt;- </span>equal c, <span class="Constant">8199/figure-space</span>
  <span class="muControl">return-if</span> result
  result<span class="Special"> &lt;- </span>equal c, <span class="Constant">8200/punctuation-space</span>
  <span class="muControl">return-if</span> result
  result<span class="Special"> &lt;- </span>equal c, <span class="Constant">8201/thin-space</span>
  <span class="muControl">return-if</span> result
  result<span class="Special"> &lt;- </span>equal c, <span class="Constant">8202/hair-space</span>
  <span class="muControl">return-if</span> result
  result<span class="Special"> &lt;- </span>equal c, <span class="Constant">8206/left-to-right</span>
  <span class="muControl">return-if</span> result
  result<span class="Special"> &lt;- </span>equal c, <span class="Constant">8207/right-to-left</span>
  <span class="muControl">return-if</span> result
  result<span class="Special"> &lt;- </span>equal c, <span class="Constant">8232/line-separator</span>
  <span class="muControl">return-if</span> result
  result<span class="Special"> &lt;- </span>equal c, <span class="Constant">8233/paragraph-separator</span>
  <span class="muControl">return-if</span> result
  result<span class="Special"> &lt;- </span>equal c, <span class="Constant">8239/narrow-no-break-space</span>
  <span class="muControl">return-if</span> result
  result<span class="Special"> &lt;- </span>equal c, <span class="Constant">8287/medium-mathematical-space</span>
  <span class="muControl">return-if</span> result
  result<span class="Special"> &lt;- </span>equal c, <span class="Constant">12288/ideographic-space</span>
]

<span class="muRecipe">def</span> trim s:address:array:character<span class="muRecipe"> -&gt; </span>result:address:array:character [
  <span class="Constant">local-scope</span>
  <span class="Constant">load-ingredients</span>
  len:number<span class="Special"> &lt;- </span>length *s
  <span class="Comment"># left trim: compute start</span>
  start:number<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
  <span class="Delimiter">{</span>
    <span class="Delimiter">{</span>
      at-end?:boolean<span class="Special"> &lt;- </span>greater-or-equal start, len
      <span class="muControl">break-unless</span> at-end?
      result<span class="Special"> &lt;- </span>new <span class="Constant">character:type</span>, <span class="Constant">0</span>
      <span class="muControl">return</span>
    <span class="Delimiter">}</span>
    curr:character<span class="Special"> &lt;- </span>index *s, start
    whitespace?:boolean<span class="Special"> &lt;- </span>space? curr
    <span class="muControl">break-unless</span> whitespace?
    start<span class="Special"> &lt;- </span>add start, <span class="Constant">1</span>
    <span class="muControl">loop</span>
  <span class="Delimiter">}</span>
  <span class="Comment"># right trim: compute end</span>
  end:number<span class="Special"> &lt;- </span>subtract len, <span class="Constant">1</span>
  <span class="Delimiter">{</span>
    not-at-start?:boolean<span class="Special"> &lt;- </span>greater-than end, start
    assert not-at-start?, <span class="Constant">[end ran up against start]</span>
    curr:character<span class="Special"> &lt;- </span>index *s, end
    whitespace?:boolean<span class="Special"> &lt;- </span>space? curr
    <span class="muControl">break-unless</span> whitespace?
    end<span class="Special"> &lt;- </span>subtract end, <span class="Constant">1</span>
    <span class="muControl">loop</span>
  <span class="Delimiter">}</span>
  <span class="Comment"># result = new character[end+1 - start]</span>
  new-len:number<span class="Special"> &lt;- </span>subtract end, start, <span class="Constant">-1</span>
  result:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">character:type</span>, new-len
  <span class="Comment"># copy the untrimmed parts between start and end</span>
  i:number<span class="Special"> &lt;- </span>copy start
  j:number<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
  <span class="Delimiter">{</span>
    <span class="Comment"># while i &lt;= end</span>
    done?:boolean<span class="Special"> &lt;- </span>greater-than i, end
    <span class="muControl">break-if</span> done?
    <span class="Comment"># result[j] = s[i]</span>
    src:character<span class="Special"> &lt;- </span>index *s, i
    *result<span class="Special"> &lt;- </span>put-index *result, j, src
    i<span class="Special"> &lt;- </span>add i, <span class="Constant">1</span>
    j<span class="Special"> &lt;- </span>add j, <span class="Constant">1</span>
    <span class="muControl">loop</span>
  <span class="Delimiter">}</span>
]

<span class="muScenario">scenario</span> trim-unmodified [
  run [
    <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[abc]</span>
    <span class="Constant">2</span>:address:array:character<span class="Special"> &lt;- </span>trim <span class="Constant">1</span>:address:array:character
    <span class="Constant">3</span>:array:character<span class="Special"> &lt;- </span>copy *<span class="Constant">2</span>:address:array:character
  ]
  memory-should-contain [
    <span class="Constant">3</span>:array:character<span class="Special"> &lt;- </span><span class="Constant">[abc]</span>
  ]
]

<span class="muScenario">scenario</span> trim-left [
  run [
    <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[  abc]</span>
    <span class="Constant">2</span>:address:array:character<span class="Special"> &lt;- </span>trim <span class="Constant">1</span>:address:array:character
    <span class="Constant">3</span>:array:character<span class="Special"> &lt;- </span>copy *<span class="Constant">2</span>:address:array:character
  ]
  memory-should-contain [
    <span class="Constant">3</span>:array:character<span class="Special"> &lt;- </span><span class="Constant">[abc]</span>
  ]
]

<span class="muScenario">scenario</span> trim-right [
  run [
    <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[abc  ]</span>
    <span class="Constant">2</span>:address:array:character<span class="Special"> &lt;- </span>trim <span class="Constant">1</span>:address:array:character
    <span class="Constant">3</span>:array:character<span class="Special"> &lt;- </span>copy *<span class="Constant">2</span>:address:array:character
  ]
  memory-should-contain [
    <span class="Constant">3</span>:array:character<span class="Special"> &lt;- </span><span class="Constant">[abc]</span>
  ]
]

<span class="muScenario">scenario</span> trim-left-right [
  run [
    <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[  abc   ]</span>
    <span class="Constant">2</span>:address:array:character<span class="Special"> &lt;- </span>trim <span class="Constant">1</span>:address:array:character
    <span class="Constant">3</span>:array:character<span class="Special"> &lt;- </span>copy *<span class="Constant">2</span>:address:array:character
  ]
  memory-should-contain [
    <span class="Constant">3</span>:array:character<span class="Special"> &lt;- </span><span class="Constant">[abc]</span>
  ]
]

<span class="muScenario">scenario</span> trim-newline-tab [
  run [
    <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[  abc</span>
<span class="Constant">]</span>
    <span class="Constant">2</span>:address:array:character<span class="Special"> &lt;- </span>trim <span class="Constant">1</span>:address:array:character
    <span class="Constant">3</span>:array:character<span class="Special"> &lt;- </span>copy *<span class="Constant">2</span>:address:array:character
  ]
  memory-should-contain [
    <span class="Constant">3</span>:array:character<span class="Special"> &lt;- </span><span class="Constant">[abc]</span>
  ]
]

<span class="muRecipe">def</span> find-next text:address:array:character, pattern:character, idx:number<span class="muRecipe"> -&gt; </span>next-index:number [
  <span class="Constant">local-scope</span>
  <span class="Constant">load-ingredients</span>
  len:number<span class="Special"> &lt;- </span>length *text
  <span class="Delimiter">{</span>
    eof?:boolean<span class="Special"> &lt;- </span>greater-or-equal idx, len
    <span class="muControl">break-if</span> eof?
    curr:character<span class="Special"> &lt;- </span>index *text, idx
    found?:boolean<span class="Special"> &lt;- </span>equal curr, pattern
    <span class="muControl">break-if</span> found?
    idx<span class="Special"> &lt;- </span>add idx, <span class="Constant">1</span>
    <span class="muControl">loop</span>
  <span class="Delimiter">}</span>
  <span class="muControl">return</span> idx
]

<span class="muScenario">scenario</span> text-find-next [
  run [
    <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[a/b]</span>
    <span class="Constant">2</span>:number<span class="Special"> &lt;- </span>find-next <span class="Constant">1</span>:address:array:character, <span class="Constant">47/slash</span>, <span class="Constant">0/start-index</span>
  ]
  memory-should-contain [
    <span class="Constant">2</span><span class="Special"> &lt;- </span><span class="Constant">1</span>
  ]
]

<span class="muScenario">scenario</span> text-find-next-empty [
  run [
    <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[]</span>
    <span class="Constant">2</span>:number<span class="Special"> &lt;- </span>find-next <span class="Constant">1</span>:address:array:character, <span class="Constant">47/slash</span>, <span class="Constant">0/start-index</span>
  ]
  memory-should-contain [
    <span class="Constant">2</span><span class="Special"> &lt;- </span><span class="Constant">0</span>
  ]
]

<span class="muScenario">scenario</span> text-find-next-initial [
  run [
    <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[/abc]</span>
    <span class="Constant">2</span>:number<span class="Special"> &lt;- </span>find-next <span class="Constant">1</span>:address:array:character, <span class="Constant">47/slash</span>, <span class="Constant">0/start-index</span>
  ]
  memory-should-contain [
    <span class="Constant">2</span><span class="Special"> &lt;- </span><span class="Constant">0</span>  <span class="Comment"># prefix match</span>
  ]
]

<span class="muScenario">scenario</span> text-find-next-final [
  run [
    <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[abc/]</span>
    <span class="Constant">2</span>:number<span class="Special"> &lt;- </span>find-next <span class="Constant">1</span>:address:array:character, <span class="Constant">47/slash</span>, <span class="Constant">0/start-index</span>
  ]
  memory-should-contain [
    <span class="Constant">2</span><span class="Special"> &lt;- </span><span class="Constant">3</span>  <span class="Comment"># suffix match</span>
  ]
]

<span class="muScenario">scenario</span> text-find-next-missing [
  run [
    <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[abc]</span>
    <span class="Constant">2</span>:number<span class="Special"> &lt;- </span>find-next <span class="Constant">1</span>:address:array:character, <span class="Constant">47/slash</span>, <span class="Constant">0/start-index</span>
  ]
  memory-should-contain [
    <span class="Constant">2</span><span class="Special"> &lt;- </span><span class="Constant">3</span>  <span class="Comment"># no match</span>
  ]
]

<span class="muScenario">scenario</span> text-find-next-invalid-index [
  run [
    <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[abc]</span>
    <span class="Constant">2</span>:number<span class="Special"> &lt;- </span>find-next <span class="Constant">1</span>:address:array:character, <span class="Constant">47/slash</span>, <span class="Constant">4/start-index</span>
  ]
  memory-should-contain [
    <span class="Constant">2</span><span class="Special"> &lt;- </span><span class="Constant">4</span>  <span class="Comment"># no change</span>
  ]
]

<span class="muScenario">scenario</span> text-find-next-first [
  run [
    <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[ab/c/]</span>
    <span class="Constant">2</span>:number<span class="Special"> &lt;- </span>find-next <span class="Constant">1</span>:address:array:character, <span class="Constant">47/slash</span>, <span class="Constant">0/start-index</span>
  ]
  memory-should-contain [
    <span class="Constant">2</span><span class="Special"> &lt;- </span><span class="Constant">2</span>  <span class="Comment"># first '/' of multiple</span>
  ]
]

<span class="muScenario">scenario</span> text-find-next-second [
  run [
    <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[ab/c/]</span>
    <span class="Constant">2</span>:number<span class="Special"> &lt;- </span>find-next <span class="Constant">1</span>:address:array:character, <span class="Constant">47/slash</span>, <span class="Constant">3/start-index</span>
  ]
  memory-should-contain [
    <span class="Constant">2</span><span class="Special"> &lt;- </span><span class="Constant">4</span>  <span class="Comment"># second '/' of multiple</span>
  ]
]

<span class="Comment"># search for a pattern of multiple characters</span>
<span class="Comment"># fairly dumb algorithm</span>
<span class="muRecipe">def</span> find-next text:address:array:character, pattern:address:array:character, idx:number<span class="muRecipe"> -&gt; </span>next-index:number [
  <span class="Constant">local-scope</span>
  <span class="Constant">load-ingredients</span>
  first:character<span class="Special"> &lt;- </span>index *pattern, <span class="Constant">0</span>
  <span class="Comment"># repeatedly check for match at current idx</span>
  len:number<span class="Special"> &lt;- </span>length *text
  <span class="Delimiter">{</span>
    <span class="Comment"># does some unnecessary work checking even when there isn't enough of text left</span>
    done?:boolean<span class="Special"> &lt;- </span>greater-or-equal idx, len
    <span class="muControl">break-if</span> done?
    found?:boolean<span class="Special"> &lt;- </span>match-at text, pattern, idx
    <span class="muControl">break-if</span> found?
    idx<span class="Special"> &lt;- </span>add idx, <span class="Constant">1</span>
    <span class="Comment"># optimization: skip past indices that definitely won't match</span>
    idx<span class="Special"> &lt;- </span>find-next text, first, idx
    <span class="muControl">loop</span>
  <span class="Delimiter">}</span>
  <span class="muControl">return</span> idx
]

<span class="muScenario">scenario</span> find-next-text-1 [
  run [
    <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[abc]</span>
    <span class="Constant">2</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[bc]</span>
    <span class="Constant">3</span>:number<span class="Special"> &lt;- </span>find-next <span class="Constant">1</span>:address:array:character, <span class="Constant">2</span>:address:array:character, <span class="Constant">0</span>
  ]
  memory-should-contain [
    <span class="Constant">3</span><span class="Special"> &lt;- </span><span class="Constant">1</span>
  ]
]

<span class="muScenario">scenario</span> find-next-text-2 [
  run [
    <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[abcd]</span>
    <span class="Constant">2</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[bc]</span>
    <span class="Constant">3</span>:number<span class="Special"> &lt;- </span>find-next <span class="Constant">1</span>:address:array:character, <span class="Constant">2</span>:address:array:character, <span class="Constant">1</span>
  ]
  memory-should-contain [
    <span class="Constant">3</span><span class="Special"> &lt;- </span><span class="Constant">1</span>
  ]
]

<span class="muScenario">scenario</span> find-next-no-match [
  run [
    <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[abc]</span>
    <span class="Constant">2</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[bd]</span>
    <span class="Constant">3</span>:number<span class="Special"> &lt;- </span>find-next <span class="Constant">1</span>:address:array:character, <span class="Constant">2</span>:address:array:character, <span class="Constant">0</span>
  ]
  memory-should-contain [
    <span class="Constant">3</span><span class="Special"> &lt;- </span><span class="Constant">3</span>  <span class="Comment"># not found</span>
  ]
]

<span class="muScenario">scenario</span> find-next-suffix-match [
  run [
    <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[abcd]</span>
    <span class="Constant">2</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[cd]</span>
    <span class="Constant">3</span>:number<span class="Special"> &lt;- </span>find-next <span class="Constant">1</span>:address:array:character, <span class="Constant">2</span>:address:array:character, <span class="Constant">0</span>
  ]
  memory-should-contain [
    <span class="Constant">3</span><span class="Special"> &lt;- </span><span class="Constant">2</span>
  ]
]

<span class="muScenario">scenario</span> find-next-suffix-match-2 [
  run [
    <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[abcd]</span>
    <span class="Constant">2</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[cde]</span>
    <span class="Constant">3</span>:number<span class="Special"> &lt;- </span>find-next <span class="Constant">1</span>:address:array:character, <span class="Constant">2</span>:address:array:character, <span class="Constant">0</span>
  ]
  memory-should-contain [
    <span class="Constant">3</span><span class="Special"> &lt;- </span><span class="Constant">4</span>  <span class="Comment"># not found</span>
  ]
]

<span class="Comment"># checks if pattern matches at index 'idx'</span>
<span class="muRecipe">def</span> match-at text:address:array:character, pattern:address:array:character, idx:number<span class="muRecipe"> -&gt; </span>result:boolean [
  <span class="Constant">local-scope</span>
  <span class="Constant">load-ingredients</span>
  pattern-len:number<span class="Special"> &lt;- </span>length *pattern
  <span class="Comment"># check that there's space left for the pattern</span>
  <span class="Delimiter">{</span>
    x:number<span class="Special"> &lt;- </span>length *text
    x<span class="Special"> &lt;- </span>subtract x, pattern-len
    enough-room?:boolean<span class="Special"> &lt;- </span>lesser-or-equal idx, x
    <span class="muControl">break-if</span> enough-room?
    <span class="muControl">return</span> <span class="Constant">0/not-found</span>
  <span class="Delimiter">}</span>
  <span class="Comment"># check each character of pattern</span>
  pattern-idx:number<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
  <span class="Delimiter">{</span>
    done?:boolean<span class="Special"> &lt;- </span>greater-or-equal pattern-idx, pattern-len
    <span class="muControl">break-if</span> done?
    c:character<span class="Special"> &lt;- </span>index *text, idx
    exp:character<span class="Special"> &lt;- </span>index *pattern, pattern-idx
    <span class="Delimiter">{</span>
      match?:boolean<span class="Special"> &lt;- </span>equal c, exp
      <span class="muControl">break-if</span> match?
      <span class="muControl">return</span> <span class="Constant">0/not-found</span>
    <span class="Delimiter">}</span>
    idx<span class="Special"> &lt;- </span>add idx, <span class="Constant">1</span>
    pattern-idx<span class="Special"> &lt;- </span>add pattern-idx, <span class="Constant">1</span>
    <span class="muControl">loop</span>
  <span class="Delimiter">}</span>
  <span class="muControl">return</span> <span class="Constant">1/found</span>
]

<span class="muScenario">scenario</span> match-at-checks-pattern-at-index [
  run [
    <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[abc]</span>
    <span class="Constant">2</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[ab]</span>
    <span class="Constant">3</span>:boolean<span class="Special"> &lt;- </span>match-at <span class="Constant">1</span>:address:array:character, <span class="Constant">2</span>:address:array:character, <span class="Constant">0</span>
  ]
  memory-should-contain [
    <span class="Constant">3</span><span class="Special"> &lt;- </span><span class="Constant">1</span>  <span class="Comment"># match found</span>
  ]
]

<span class="muScenario">scenario</span> match-at-reflexive [
  run [
    <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[abc]</span>
    <span class="Constant">3</span>:boolean<span class="Special"> &lt;- </span>match-at <span class="Constant">1</span>:address:array:character, <span class="Constant">1</span>:address:array:character, <span class="Constant">0</span>
  ]
  memory-should-contain [
    <span class="Constant">3</span><span class="Special"> &lt;- </span><span class="Constant">1</span>  <span class="Comment"># match found</span>
  ]
]

<span class="muScenario">scenario</span> match-at-outside-bounds [
  run [
    <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[abc]</span>
    <span class="Constant">2</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[a]</span>
    <span class="Constant">3</span>:boolean<span class="Special"> &lt;- </span>match-at <span class="Constant">1</span>:address:array:character, <span class="Constant">2</span>:address:array:character, <span class="Constant">4</span>
  ]
  memory-should-contain [
    <span class="Constant">3</span><span class="Special"> &lt;- </span><span class="Constant">0</span>  <span class="Comment"># never matches</span>
  ]
]

<span class="muScenario">scenario</span> match-at-empty-pattern [
  run [
    <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[abc]</span>
    <span class="Constant">2</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[]</span>
    <span class="Constant">3</span>:boolean<span class="Special"> &lt;- </span>match-at <span class="Constant">1</span>:address:array:character, <span class="Constant">2</span>:address:array:character, <span class="Constant">0</span>
  ]
  memory-should-contain [
    <span class="Constant">3</span><span class="Special"> &lt;- </span><span class="Constant">1</span>  <span class="Comment"># always matches empty pattern given a valid index</span>
  ]
]

<span class="muScenario">scenario</span> match-at-empty-pattern-outside-bound [
  run [
    <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[abc]</span>
    <span class="Constant">2</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[]</span>
    <span class="Constant">3</span>:boolean<span class="Special"> &lt;- </span>match-at <span class="Constant">1</span>:address:array:character, <span class="Constant">2</span>:address:array:character, <span class="Constant">4</span>
  ]
  memory-should-contain [
    <span class="Constant">3</span><span class="Special"> &lt;- </span><span class="Constant">0</span>  <span class="Comment"># no match</span>
  ]
]

<span class="muScenario">scenario</span> match-at-empty-text [
  run [
    <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[]</span>
    <span class="Constant">2</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[abc]</span>
    <span class="Constant">3</span>:boolean<span class="Special"> &lt;- </span>match-at <span class="Constant">1</span>:address:array:character, <span class="Constant">2</span>:address:array:character, <span class="Constant">0</span>
  ]
  memory-should-contain [
    <span class="Constant">3</span><span class="Special"> &lt;- </span><span class="Constant">0</span>  <span class="Comment"># no match</span>
  ]
]

<span class="muScenario">scenario</span> match-at-empty-against-empty [
  run [
    <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[]</span>
    <span class="Constant">3</span>:boolean<span class="Special"> &lt;- </span>match-at <span class="Constant">1</span>:address:array:character, <span class="Constant">1</span>:address:array:character, <span class="Constant">0</span>
  ]
  memory-should-contain [
    <span class="Constant">3</span><span class="Special"> &lt;- </span><span class="Constant">1</span>  <span class="Comment"># matches because pattern is also empty</span>
  ]
]

<span class="muScenario">scenario</span> match-at-inside-bounds [
  run [
    <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[abc]</span>
    <span class="Constant">2</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[bc]</span>
    <span class="Constant">3</span>:boolean<span class="Special"> &lt;- </span>match-at <span class="Constant">1</span>:address:array:character, <span class="Constant">2</span>:address:array:character, <span class="Constant">1</span>
  ]
  memory-should-contain [
    <span class="Constant">3</span><span class="Special"> &lt;- </span><span class="Constant">1</span>  <span class="Comment"># match</span>
  ]
]

<span class="muScenario">scenario</span> match-at-inside-bounds-2 [
  run [
    <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[abc]</span>
    <span class="Constant">2</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[bc]</span>
    <span class="Constant">3</span>:boolean<span class="Special"> &lt;- </span>match-at <span class="Constant">1</span>:address:array:character, <span class="Constant">2</span>:address:array:character, <span class="Constant">0</span>
  ]
  memory-should-contain [
    <span class="Constant">3</span><span class="Special"> &lt;- </span><span class="Constant">0</span>  <span class="Comment"># no match</span>
  ]
]

<span class="muRecipe">def</span> split s:address:array:character, delim:character<span class="muRecipe"> -&gt; </span>result:address:array:address:array:character [
  <span class="Constant">local-scope</span>
  <span class="Constant">load-ingredients</span>
  <span class="Comment"># empty text? return empty array</span>
  len:number<span class="Special"> &lt;- </span>length *s
  <span class="Delimiter">{</span>
    empty?:boolean<span class="Special"> &lt;- </span>equal len, <span class="Constant">0</span>
    <span class="muControl">break-unless</span> empty?
    result<span class="Special"> &lt;- </span>new <span class="Delimiter">{</span>(address array character): type<span class="Delimiter">}</span>, <span class="Constant">0</span>
    <span class="muControl">return</span>
  <span class="Delimiter">}</span>
  <span class="Comment"># count #pieces we need room for</span>
  count:number<span class="Special"> &lt;- </span>copy <span class="Constant">1</span>  <span class="Comment"># n delimiters = n+1 pieces</span>
  idx:number<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
  <span class="Delimiter">{</span>
    idx<span class="Special"> &lt;- </span>find-next s, delim, idx
    done?:boolean<span class="Special"> &lt;- </span>greater-or-equal idx, len
    <span class="muControl">break-if</span> done?
    idx<span class="Special"> &lt;- </span>add idx, <span class="Constant">1</span>
    count<span class="Special"> &lt;- </span>add count, <span class="Constant">1</span>
    <span class="muControl">loop</span>
  <span class="Delimiter">}</span>
  <span class="Comment"># allocate space</span>
  result<span class="Special"> &lt;- </span>new <span class="Delimiter">{</span>(address array character): type<span class="Delimiter">}</span>, count
  <span class="Comment"># repeatedly copy slices start..end until delimiter into result[curr-result]</span>
  curr-result:number<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
  start:number<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
  <span class="Delimiter">{</span>
    <span class="Comment"># while next delim exists</span>
    done?:boolean<span class="Special"> &lt;- </span>greater-or-equal start, len
    <span class="muControl">break-if</span> done?
    end:number<span class="Special"> &lt;- </span>find-next s, delim, start
    <span class="Comment"># copy start..end into result[curr-result]</span>
    dest:address:array:character<span class="Special"> &lt;- </span>copy-range s, start, end
    *result<span class="Special"> &lt;- </span>put-index *result, curr-result, dest
    <span class="Comment"># slide over to next slice</span>
    start<span class="Special"> &lt;- </span>add end, <span class="Constant">1</span>
    curr-result<span class="Special"> &lt;- </span>add curr-result, <span class="Constant">1</span>
    <span class="muControl">loop</span>
  <span class="Delimiter">}</span>
]

<span class="muScenario">scenario</span> text-split-1 [
  run [
    <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[a/b]</span>
    <span class="Constant">2</span>:address:array:address:array:character<span class="Special"> &lt;- </span>split <span class="Constant">1</span>:address:array:character, <span class="Constant">47/slash</span>
    <span class="Constant">3</span>:number<span class="Special"> &lt;- </span>length *<span class="Constant">2</span>:address:array:address:array:character
    <span class="Constant">4</span>:address:array:character<span class="Special"> &lt;- </span>index *<span class="Constant">2</span>:address:array:address:array:character, <span class="Constant">0</span>
    <span class="Constant">5</span>:address:array:character<span class="Special"> &lt;- </span>index *<span class="Constant">2</span>:address:array:address:array:character, <span class="Constant">1</span>
    <span class="Constant">10</span>:array:character<span class="Special"> &lt;- </span>copy *<span class="Constant">4</span>:address:array:character
    <span class="Constant">20</span>:array:character<span class="Special"> &lt;- </span>copy *<span class="Constant">5</span>:address:array:character
  ]
  memory-should-contain [
    <span class="Constant">3</span><span class="Special"> &lt;- </span><span class="Constant">2</span>  <span class="Comment"># length of result</span>
    <span class="Constant">10</span>:array:character<span class="Special"> &lt;- </span><span class="Constant">[a]</span>
    <span class="Constant">20</span>:array:character<span class="Special"> &lt;- </span><span class="Constant">[b]</span>
  ]
]

<span class="muScenario">scenario</span> text-split-2 [
  run [
    <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[a/b/c]</span>
    <span class="Constant">2</span>:address:array:address:array:character<span class="Special"> &lt;- </span>split <span class="Constant">1</span>:address:array:character, <span class="Constant">47/slash</span>
    <span class="Constant">3</span>:number<span class="Special"> &lt;- </span>length *<span class="Constant">2</span>:address:array:address:array:character
    <span class="Constant">4</span>:address:array:character<span class="Special"> &lt;- </span>index *<span class="Constant">2</span>:address:array:address:array:character, <span class="Constant">0</span>
    <span class="Constant">5</span>:address:array:character<span class="Special"> &lt;- </span>index *<span class="Constant">2</span>:address:array:address:array:character, <span class="Constant">1</span>
    <span class="Constant">6</span>:address:array:character<span class="Special"> &lt;- </span>index *<span class="Constant">2</span>:address:array:address:array:character, <span class="Constant">2</span>
    <span class="Constant">10</span>:array:character<span class="Special"> &lt;- </span>copy *<span class="Constant">4</span>:address:array:character
    <span class="Constant">20</span>:array:character<span class="Special"> &lt;- </span>copy *<span class="Constant">5</span>:address:array:character
    <span class="Constant">30</span>:array:character<span class="Special"> &lt;- </span>copy *<span class="Constant">6</span>:address:array:character
  ]
  memory-should-contain [
    <span class="Constant">3</span><span class="Special"> &lt;- </span><span class="Constant">3</span>  <span class="Comment"># length of result</span>
    <span class="Constant">10</span>:array:character<span class="Special"> &lt;- </span><span class="Constant">[a]</span>
    <span class="Constant">20</span>:array:character<span class="Special"> &lt;- </span><span class="Constant">[b]</span>
    <span class="Constant">30</span>:array:character<span class="Special"> &lt;- </span><span class="Constant">[c]</span>
  ]
]

<span class="muScenario">scenario</span> text-split-missing [
  run [
    <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[abc]</span>
    <span class="Constant">2</span>:address:array:address:array:character<span class="Special"> &lt;- </span>split <span class="Constant">1</span>:address:array:character, <span class="Constant">47/slash</span>
    <span class="Constant">3</span>:number<span class="Special"> &lt;- </span>length *<span class="Constant">2</span>:address:array:address:array:character
    <span class="Constant">4</span>:address:array:character<span class="Special"> &lt;- </span>index *<span class="Constant">2</span>:address:array:address:array:character, <span class="Constant">0</span>
    <span class="Constant">10</span>:array:character<span class="Special"> &lt;- </span>copy *<span class="Constant">4</span>:address:array:character
  ]
  memory-should-contain [
    <span class="Constant">3</span><span class="Special"> &lt;- </span><span class="Constant">1</span>  <span class="Comment"># length of result</span>
    <span class="Constant">10</span>:array:character<span class="Special"> &lt;- </span><span class="Constant">[abc]</span>
  ]
]

<span class="muScenario">scenario</span> text-split-empty [
  run [
    <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[]</span>
    <span class="Constant">2</span>:address:array:address:array:character<span class="Special"> &lt;- </span>split <span class="Constant">1</span>:address:array:character, <span class="Constant">47/slash</span>
    <span class="Constant">3</span>:number<span class="Special"> &lt;- </span>length *<span class="Constant">2</span>:address:array:address:array:character
  ]
  memory-should-contain [
    <span class="Constant">3</span><span class="Special"> &lt;- </span><span class="Constant">0</span>  <span class="Comment"># empty result</span>
  ]
]

<span class="muScenario">scenario</span> text-split-empty-piece [
  run [
    <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[a/b//c]</span>
    <span class="Constant">2</span>:address:array:address:array:character<span class="Special"> &lt;- </span>split <span class="Constant">1</span>:address:array:character, <span class="Constant">47/slash</span>
    <span class="Constant">3</span>:number<span class="Special"> &lt;- </span>length *<span class="Constant">2</span>:address:array:address:array:character
    <span class="Constant">4</span>:address:array:character<span class="Special"> &lt;- </span>index *<span class="Constant">2</span>:address:array:address:array:character, <span class="Constant">0</span>
    <span class="Constant">5</span>:address:array:character<span class="Special"> &lt;- </span>index *<span class="Constant">2</span>:address:array:address:array:character, <span class="Constant">1</span>
    <span class="Constant">6</span>:address:array:character<span class="Special"> &lt;- </span>index *<span class="Constant">2</span>:address:array:address:array:character, <span class="Constant">2</span>
    <span class="Constant">7</span>:address:array:character<span class="Special"> &lt;- </span>index *<span class="Constant">2</span>:address:array:address:array:character, <span class="Constant">3</span>
    <span class="Constant">10</span>:array:character<span class="Special"> &lt;- </span>copy *<span class="Constant">4</span>:address:array:character
    <span class="Constant">20</span>:array:character<span class="Special"> &lt;- </span>copy *<span class="Constant">5</span>:address:array:character
    <span class="Constant">30</span>:array:character<span class="Special"> &lt;- </span>copy *<span class="Constant">6</span>:address:array:character
    <span class="Constant">40</span>:array:character<span class="Special"> &lt;- </span>copy *<span class="Constant">7</span>:address:array:character
  ]
  memory-should-contain [
    <span class="Constant">3</span><span class="Special"> &lt;- </span><span class="Constant">4</span>  <span class="Comment"># length of result</span>
    <span class="Constant">10</span>:array:character<span class="Special"> &lt;- </span><span class="Constant">[a]</span>
    <span class="Constant">20</span>:array:character<span class="Special"> &lt;- </span><span class="Constant">[b]</span>
    <span class="Constant">30</span>:array:character<span class="Special"> &lt;- </span><span class="Constant">[]</span>
    <span class="Constant">40</span>:array:character<span class="Special"> &lt;- </span><span class="Constant">[c]</span>
  ]
]

<span class="muRecipe">def</span> split-first text:address:array:character, delim:character<span class="muRecipe"> -&gt; </span>x:address:array:character, y:address:array:character [
  <span class="Constant">local-scope</span>
  <span class="Constant">load-ingredients</span>
  <span class="Comment"># empty text? return empty texts</span>
  len:number<span class="Special"> &lt;- </span>length *text
  <span class="Delimiter">{</span>
    empty?:boolean<span class="Special"> &lt;- </span>equal len, <span class="Constant">0</span>
    <span class="muControl">break-unless</span> empty?
    x:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[]</span>
    y:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[]</span>
    <span class="muControl">return</span>
  <span class="Delimiter">}</span>
  idx:number<span class="Special"> &lt;- </span>find-next text, delim, <span class="Constant">0</span>
  x:address:array:character<span class="Special"> &lt;- </span>copy-range text, <span class="Constant">0</span>, idx
  idx<span class="Special"> &lt;- </span>add idx, <span class="Constant">1</span>
  y:address:array:character<span class="Special"> &lt;- </span>copy-range text, idx, len
]

<span class="muScenario">scenario</span> text-split-first [
  run [
    <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[a/b]</span>
    <span class="Constant">2</span>:address:array:character, <span class="Constant">3</span>:address:array:character<span class="Special"> &lt;- </span>split-first <span class="Constant">1</span>:address:array:character, <span class="Constant">47/slash</span>
    <span class="Constant">10</span>:array:character<span class="Special"> &lt;- </span>copy *<span class="Constant">2</span>:address:array:character
    <span class="Constant">20</span>:array:character<span class="Special"> &lt;- </span>copy *<span class="Constant">3</span>:address:array:character
  ]
  memory-should-contain [
    <span class="Constant">10</span>:array:character<span class="Special"> &lt;- </span><span class="Constant">[a]</span>
    <span class="Constant">20</span>:array:character<span class="Special"> &lt;- </span><span class="Constant">[b]</span>
  ]
]

<span class="muRecipe">def</span> copy-range buf:address:array:character, start:number, end:number<span class="muRecipe"> -&gt; </span>result:address:array:character [
  <span class="Constant">local-scope</span>
  <span class="Constant">load-ingredients</span>
  <span class="Comment"># if end is out of bounds, trim it</span>
  len:number<span class="Special"> &lt;- </span>length *buf
  end:number<span class="Special"> &lt;- </span>min len, end
  <span class="Comment"># allocate space for result</span>
  len<span class="Special"> &lt;- </span>subtract end, start
  result:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">character:type</span>, len
  <span class="Comment"># copy start..end into result[curr-result]</span>
  src-idx:number<span class="Special"> &lt;- </span>copy start
  dest-idx:number<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
  <span class="Delimiter">{</span>
    done?:boolean<span class="Special"> &lt;- </span>greater-or-equal src-idx, end
    <span class="muControl">break-if</span> done?
    src:character<span class="Special"> &lt;- </span>index *buf, src-idx
    *result<span class="Special"> &lt;- </span>put-index *result, dest-idx, src
    src-idx<span class="Special"> &lt;- </span>add src-idx, <span class="Constant">1</span>
    dest-idx<span class="Special"> &lt;- </span>add dest-idx, <span class="Constant">1</span>
    <span class="muControl">loop</span>
  <span class="Delimiter">}</span>
]

<span class="muScenario">scenario</span> text-copy-copies-partial-text [
  run [
    <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[abc]</span>
    <span class="Constant">2</span>:address:array:character<span class="Special"> &lt;- </span>copy-range <span class="Constant">1</span>:address:array:character, <span class="Constant">1</span>, <span class="Constant">3</span>
    <span class="Constant">3</span>:array:character<span class="Special"> &lt;- </span>copy *<span class="Constant">2</span>:address:array:character
  ]
  memory-should-contain [
    <span class="Constant">3</span>:array:character<span class="Special"> &lt;- </span><span class="Constant">[bc]</span>
  ]
]

<span class="muScenario">scenario</span> text-copy-out-of-bounds [
  run [
    <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[abc]</span>
    <span class="Constant">2</span>:address:array:character<span class="Special"> &lt;- </span>copy-range <span class="Constant">1</span>:address:array:character, <span class="Constant">2</span>, <span class="Constant">4</span>
    <span class="Constant">3</span>:array:character<span class="Special"> &lt;- </span>copy *<span class="Constant">2</span>:address:array:character
  ]
  memory-should-contain [
    <span class="Constant">3</span>:array:character<span class="Special"> &lt;- </span><span class="Constant">[c]</span>
  ]
]

<span class="muScenario">scenario</span> text-copy-out-of-bounds-2 [
  run [
    <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span>new <span class="Constant">[abc]</span>
    <span class="Constant">2</span>:address:array:character<span class="Special"> &lt;- </span>copy-range <span class="Constant">1</span>:address:array:character, <span class="Constant">3</span>, <span class="Constant">3</span>
    <span class="Constant">3</span>:array:character<span class="Special"> &lt;- </span>copy *<span class="Constant">2</span>:address:array:character
  ]
  memory-should-contain [
    <span class="Constant">3</span>:array:character<span class="Special"> &lt;- </span><span class="Constant">[]</span>
  ]
]

<span class="muRecipe">def</span> min x:number, y:number<span class="muRecipe"> -&gt; </span>z:number [
  <span class="Constant">local-scope</span>
  <span class="Constant">load-ingredients</span>
  <span class="Delimiter">{</span>
    return-x?:boolean<span class="Special"> &lt;- </span>lesser-than x, y
    <span class="muControl">break-if</span> return-x?
    <span class="muControl">return</span> y
  <span class="Delimiter">}</span>
  <span class="muControl">return</span> x
]

<span class="muRecipe">def</span> max x:number, y:number<span class="muRecipe"> -&gt; </span>z:number [
  <span class="Constant">local-scope</span>
  <span class="Constant">load-ingredients</span>
  <span class="Delimiter">{</span>
    return-x?:boolean<span class="Special"> &lt;- </span>greater-than x, y
    <span class="muControl">break-if</span> return-x?
    <span class="muControl">return</span> y
  <span class="Delimiter">}</span>
  <span class="muControl">return</span> x
]
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
