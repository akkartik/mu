<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>Mu - 061channel.mu</title>
<meta name="Generator" content="Vim/7.4">
<meta name="plugin-version" content="vim7.4_v1">
<meta name="syntax" content="none">
<meta name="settings" content="use_css,pre_wrap,no_foldcolumn,expand_tabs,prevent_copy=">
<meta name="colorscheme" content="minimal">
<style type="text/css">
<!--
pre { white-space: pre-wrap; font-family: monospace; color: #eeeeee; background-color: #080808; }
body { font-family: monospace; color: #eeeeee; background-color: #080808; }
* { font-size: 1.05em; }
.SalientComment { color: #00ffff; }
.Underlined { color: #c000c0; text-decoration: underline; }
.Comment { color: #9090ff; }
.Special { color: #ff6060; }
.Identifier { color: #804000; }
-->
</style>

<script type='text/javascript'>
<!--

-->
</script>
</head>
<body>
<pre id='vimCodeElement'>
<span class="Comment"># Mu synchronizes using channels rather than locks, like Erlang and Go.</span>
#
<span class="Comment"># The two ends of a channel will usually belong to different routines, but</span>
<span class="Comment"># each end should only be used by a single one. Don't try to read from or</span>
<span class="Comment"># write to it from multiple routines at once.</span>
#
<span class="Comment"># The key property of channels is that writing to a full channel or reading</span>
<span class="Comment"># from an empty one will put the current routine in 'waiting' state until the</span>
<span class="Comment"># operation can be completed.</span>

scenario channel [
  run [
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">new</span>-channel 3/capacity
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">write</span> 1:address:channel, 34
    2:number, 1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">read</span> 1:address:channel
  ]
  memory-should-contain [
    2<span class="Special"> &lt;- </span>34
  ]
]

container channel [
  <span class="Comment"># To avoid locking, writer and reader will never write to the same location.</span>
  <span class="Comment"># So channels will include fields in pairs, one for the writer and one for the</span>
  <span class="Comment"># reader.</span>
  first-full:number  <span class="Comment"># for write</span>
  first-free:number  <span class="Comment"># for read</span>
  <span class="Comment"># A circular buffer contains values from index first-full up to (but not</span>
  <span class="Comment"># including) index first-empty. The reader always modifies it at first-full,</span>
  <span class="Comment"># while the writer always modifies it at first-empty.</span>
  data:address:<span class="Identifier">array</span>:location
]

<span class="Comment"># result:address:channel &lt;- new-channel capacity:number</span>
recipe <span class="Identifier">new</span>-channel [
  <span class="Underlined">local</span>-scope
  <span class="Comment"># result = new channel</span>
  result:address:channel<span class="Special"> &lt;- </span><span class="Identifier">new</span> channel:<span class="Identifier">type</span>
  <span class="Comment"># result.first-full = 0</span>
  full:address:number<span class="Special"> &lt;- </span>get-address *result, first-full:offset
  *full<span class="Special"> &lt;- </span><span class="Identifier">copy</span> 0
  <span class="Comment"># result.first-free = 0</span>
  free:address:number<span class="Special"> &lt;- </span>get-address *result, first-free:offset
  *free<span class="Special"> &lt;- </span><span class="Identifier">copy</span> 0
  <span class="Comment"># result.data = new location[ingredient+1]</span>
  capacity:number<span class="Special"> &lt;- </span>next-ingredient
  capacity<span class="Special"> &lt;- </span>add capacity, 1  <span class="Comment"># unused slot for 'full?' below</span>
  dest:address:address:<span class="Identifier">array</span>:location<span class="Special"> &lt;- </span>get-address *result, data:offset
  *dest<span class="Special"> &lt;- </span><span class="Identifier">new</span> location:<span class="Identifier">type</span>, capacity
  reply result
]

<span class="Comment"># chan &lt;- write chan:address:channel, val:location</span>
recipe <span class="Identifier">write</span> [
  <span class="Underlined">local</span>-scope
  chan:address:channel<span class="Special"> &lt;- </span>next-ingredient
  <span class="Identifier">val</span>:location<span class="Special"> &lt;- </span>next-ingredient
  {
    <span class="Comment"># block if chan is full</span>
    full:boolean<span class="Special"> &lt;- </span>channel-full? chan
    break-unless full
    full-address:address:number<span class="Special"> &lt;- </span>get-address *chan, first-full:offset
    wait-for-location *full-address
  }
  <span class="Comment"># store val</span>
  circular-buffer:address:<span class="Identifier">array</span>:location<span class="Special"> &lt;- </span>get *chan, data:offset
  free:address:number<span class="Special"> &lt;- </span>get-address *chan, first-free:offset
  dest:address:location<span class="Special"> &lt;- </span>index-address *circular-buffer, *free
  *dest<span class="Special"> &lt;- </span><span class="Identifier">copy</span> <span class="Identifier">val</span>
  <span class="Comment"># mark its slot as filled</span>
  *free<span class="Special"> &lt;- </span>add *free, 1
  {
    <span class="Comment"># wrap free around to 0 if necessary</span>
    len:number<span class="Special"> &lt;- </span><span class="Identifier">length</span> *circular-buffer
    at-end?:boolean<span class="Special"> &lt;- </span>greater-or-equal *free, len
    break-unless at-end?
    *free<span class="Special"> &lt;- </span><span class="Identifier">copy</span> 0
  }
  reply chan/same-as-ingredient:0
]

<span class="Comment"># result:location, chan &lt;- read chan:address:channel</span>
recipe <span class="Identifier">read</span> [
  <span class="Underlined">local</span>-scope
  chan:address:channel<span class="Special"> &lt;- </span>next-ingredient
  {
    <span class="Comment"># block if chan is empty</span>
    empty?:boolean<span class="Special"> &lt;- </span>channel-empty? chan
    break-unless empty?
    free-address:address:number<span class="Special"> &lt;- </span>get-address *chan, first-free:offset
    wait-for-location *free-address
  }
  <span class="Comment"># read result</span>
  full:address:number<span class="Special"> &lt;- </span>get-address *chan, first-full:offset
  circular-buffer:address:<span class="Identifier">array</span>:location<span class="Special"> &lt;- </span>get *chan, data:offset
  result:location<span class="Special"> &lt;- </span>index *circular-buffer, *full
  <span class="Comment"># mark its slot as empty</span>
  *full<span class="Special"> &lt;- </span>add *full, 1
  {
    <span class="Comment"># wrap full around to 0 if necessary</span>
    len:number<span class="Special"> &lt;- </span><span class="Identifier">length</span> *circular-buffer
    at-end?:boolean<span class="Special"> &lt;- </span>greater-or-equal *full, len
    break-unless at-end?
    *full<span class="Special"> &lt;- </span><span class="Identifier">copy</span> 0
  }
  reply result, chan/same-as-ingredient:0
]

recipe clear-channel [
  <span class="Underlined">local</span>-scope
  chan:address:channel<span class="Special"> &lt;- </span>next-ingredient
  {
    empty?:boolean<span class="Special"> &lt;- </span>channel-empty? chan
    break-if empty?
    _, chan<span class="Special"> &lt;- </span><span class="Identifier">read</span> chan
  }
  reply chan/same-as-ingredient:0
]

scenario channel-initialization [
  run [
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">new</span>-channel 3/capacity
    2:number<span class="Special"> &lt;- </span>get *1:address:channel, first-full:offset
    3:number<span class="Special"> &lt;- </span>get *1:address:channel, first-free:offset
  ]
  memory-should-contain [
    2<span class="Special"> &lt;- </span>0  <span class="Comment"># first-full</span>
    3<span class="Special"> &lt;- </span>0  <span class="Comment"># first-free</span>
  ]
]

scenario channel-<span class="Identifier">write</span>-increments-free [
  run [
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">new</span>-channel 3/capacity
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">write</span> 1:address:channel, 34
    2:number<span class="Special"> &lt;- </span>get *1:address:channel, first-full:offset
    3:number<span class="Special"> &lt;- </span>get *1:address:channel, first-free:offset
  ]
  memory-should-contain [
    2<span class="Special"> &lt;- </span>0  <span class="Comment"># first-full</span>
    3<span class="Special"> &lt;- </span>1  <span class="Comment"># first-free</span>
  ]
]

scenario channel-<span class="Identifier">read</span>-increments-full [
  run [
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">new</span>-channel 3/capacity
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">write</span> 1:address:channel, 34
    _, 1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">read</span> 1:address:channel
    2:number<span class="Special"> &lt;- </span>get *1:address:channel, first-full:offset
    3:number<span class="Special"> &lt;- </span>get *1:address:channel, first-free:offset
  ]
  memory-should-contain [
    2<span class="Special"> &lt;- </span>1  <span class="Comment"># first-full</span>
    3<span class="Special"> &lt;- </span>1  <span class="Comment"># first-free</span>
  ]
]

scenario channel-wrap [
  run [
    <span class="Comment"># channel with just 1 slot</span>
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">new</span>-channel 1/capacity
    <span class="Comment"># write and read a value</span>
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">write</span> 1:address:channel, 34
    _, 1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">read</span> 1:address:channel
    <span class="Comment"># first-free will now be 1</span>
    2:number<span class="Special"> &lt;- </span>get *1:address:channel, first-free:offset
    3:number<span class="Special"> &lt;- </span>get *1:address:channel, first-free:offset
    <span class="Comment"># write second value, verify that first-free wraps</span>
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">write</span> 1:address:channel, 34
    4:number<span class="Special"> &lt;- </span>get *1:address:channel, first-free:offset
    <span class="Comment"># read second value, verify that first-full wraps</span>
    _, 1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">read</span> 1:address:channel
    5:number<span class="Special"> &lt;- </span>get *1:address:channel, first-full:offset
  ]
  memory-should-contain [
    2<span class="Special"> &lt;- </span>1  <span class="Comment"># first-free after first write</span>
    3<span class="Special"> &lt;- </span>1  <span class="Comment"># first-full after first read</span>
    4<span class="Special"> &lt;- </span>0  <span class="Comment"># first-free after second write, wrapped</span>
    5<span class="Special"> &lt;- </span>0  <span class="Comment"># first-full after second read, wrapped</span>
  ]
]

<span class="SalientComment">## helpers</span>

<span class="Comment"># An empty channel has first-empty and first-full both at the same value.</span>
recipe channel-empty? [
  <span class="Underlined">local</span>-scope
  chan:address:channel<span class="Special"> &lt;- </span>next-ingredient
  <span class="Comment"># return chan.first-full == chan.first-free</span>
  full:number<span class="Special"> &lt;- </span>get *chan, first-full:offset
  free:number<span class="Special"> &lt;- </span>get *chan, first-free:offset
  result:boolean<span class="Special"> &lt;- </span>equal full, free
  reply result
]

<span class="Comment"># A full channel has first-empty just before first-full, wasting one slot.</span>
<span class="Comment"># (Other alternatives: <a href="https://en.wikipedia.org/wiki/Circular_buffer#Full_.2F_Empty_Buffer_Distinction)">https://en.wikipedia.org/wiki/Circular_buffer#Full_.2F_Empty_Buffer_Distinction)</a></span>
recipe channel-full? [
  <span class="Underlined">local</span>-scope
  chan:address:channel<span class="Special"> &lt;- </span>next-ingredient
  <span class="Comment"># tmp = chan.first-free + 1</span>
  tmp:number<span class="Special"> &lt;- </span>get *chan, first-free:offset
  tmp<span class="Special"> &lt;- </span>add tmp, 1
  {
    <span class="Comment"># if tmp == chan.capacity, tmp = 0</span>
    len:number<span class="Special"> &lt;- </span>channel-capacity chan
    at-end?:boolean<span class="Special"> &lt;- </span>greater-or-equal tmp, len
    break-unless at-end?
    tmp<span class="Special"> &lt;- </span><span class="Identifier">copy</span> 0
  }
  <span class="Comment"># return chan.first-full == tmp</span>
  full:number<span class="Special"> &lt;- </span>get *chan, first-full:offset
  result:boolean<span class="Special"> &lt;- </span>equal full, tmp
  reply result
]

<span class="Comment"># result:number &lt;- channel-capacity chan:address:channel</span>
recipe channel-capacity [
  <span class="Underlined">local</span>-scope
  chan:address:channel<span class="Special"> &lt;- </span>next-ingredient
  q:address:<span class="Identifier">array</span>:location<span class="Special"> &lt;- </span>get *chan, data:offset
  result:number<span class="Special"> &lt;- </span><span class="Identifier">length</span> *q
  reply result
]

scenario channel-<span class="Identifier">new</span>-empty-not-full [
  run [
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">new</span>-channel 3/capacity
    2:boolean<span class="Special"> &lt;- </span>channel-empty? 1:address:channel
    3:boolean<span class="Special"> &lt;- </span>channel-full? 1:address:channel
  ]
  memory-should-contain [
    2<span class="Special"> &lt;- </span>1  <span class="Comment"># empty?</span>
    3<span class="Special"> &lt;- </span>0  <span class="Comment"># full?</span>
  ]
]

scenario channel-<span class="Identifier">write</span>-not-empty [
  run [
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">new</span>-channel 3/capacity
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">write</span> 1:address:channel, 34
    2:boolean<span class="Special"> &lt;- </span>channel-empty? 1:address:channel
    3:boolean<span class="Special"> &lt;- </span>channel-full? 1:address:channel
  ]
  memory-should-contain [
    2<span class="Special"> &lt;- </span>0  <span class="Comment"># empty?</span>
    3<span class="Special"> &lt;- </span>0  <span class="Comment"># full?</span>
  ]
]

scenario channel-<span class="Identifier">write</span>-full [
  run [
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">new</span>-channel 1/capacity
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">write</span> 1:address:channel, 34
    2:boolean<span class="Special"> &lt;- </span>channel-empty? 1:address:channel
    3:boolean<span class="Special"> &lt;- </span>channel-full? 1:address:channel
  ]
  memory-should-contain [
    2<span class="Special"> &lt;- </span>0  <span class="Comment"># empty?</span>
    3<span class="Special"> &lt;- </span>1  <span class="Comment"># full?</span>
  ]
]

scenario channel-<span class="Identifier">read</span>-not-full [
  run [
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">new</span>-channel 1/capacity
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">write</span> 1:address:channel, 34
    _, 1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">read</span> 1:address:channel
    2:boolean<span class="Special"> &lt;- </span>channel-empty? 1:address:channel
    3:boolean<span class="Special"> &lt;- </span>channel-full? 1:address:channel
  ]
  memory-should-contain [
    2<span class="Special"> &lt;- </span>1  <span class="Comment"># empty?</span>
    3<span class="Special"> &lt;- </span>0  <span class="Comment"># full?</span>
  ]
]

<span class="Comment"># helper for channels of characters in particular</span>
<span class="Comment"># out &lt;- buffer-lines in:address:channel, out:address:channel</span>
recipe buffer-lines [
  <span class="Underlined">local</span>-scope
  <span class="Identifier">in</span>:address:channel<span class="Special"> &lt;- </span>next-ingredient
  out:address:channel<span class="Special"> &lt;- </span>next-ingredient
  <span class="Comment"># repeat forever</span>
  {
    line:address:buffer<span class="Special"> &lt;- </span><span class="Identifier">new</span>-buffer, 30
    <span class="Comment"># read characters from 'in' until newline, copy into line</span>
    {
      +next-character
      c:character, <span class="Identifier">in</span><span class="Special"> &lt;- </span><span class="Identifier">read</span> <span class="Identifier">in</span>
      <span class="Comment"># drop a character on backspace</span>
      {
        <span class="Comment"># special-case: if it's a backspace</span>
        backspace?:boolean<span class="Special"> &lt;- </span>equal c, 8
        break-unless backspace?
        <span class="Comment"># drop previous character</span>
        {
          buffer-<span class="Identifier">length</span>:address:number<span class="Special"> &lt;- </span>get-address *line, <span class="Identifier">length</span>:offset
          buffer-empty?:boolean<span class="Special"> &lt;- </span>equal *buffer-<span class="Identifier">length</span>, 0
          break-if buffer-empty?
          *buffer-<span class="Identifier">length</span><span class="Special"> &lt;- </span>subtract *buffer-<span class="Identifier">length</span>, 1
        }
        <span class="Comment"># and don't append this one</span>
        loop +next-character:label
      }
      <span class="Comment"># append anything else</span>
      line<span class="Special"> &lt;- </span>buffer-<span class="Identifier">append</span> line, c
      line-done?:boolean<span class="Special"> &lt;- </span>equal c, 10/newline
      break-if line-done?
      <span class="Comment"># stop buffering on eof (currently only generated by fake console)</span>
      eof?:boolean<span class="Special"> &lt;- </span>equal c, 0/eof
      break-if eof?
      loop
    }
    <span class="Comment"># copy line into 'out'</span>
    i:number<span class="Special"> &lt;- </span><span class="Identifier">copy</span> 0
    line-contents:address:<span class="Identifier">array</span>:character<span class="Special"> &lt;- </span>get *line, data:offset
    <span class="Identifier">max</span>:number<span class="Special"> &lt;- </span>get *line, <span class="Identifier">length</span>:offset
    {
      done?:boolean<span class="Special"> &lt;- </span>greater-or-equal i, <span class="Identifier">max</span>
      break-if done?
      c:character<span class="Special"> &lt;- </span>index *line-contents, i
      out<span class="Special"> &lt;- </span><span class="Identifier">write</span> out, c
      i<span class="Special"> &lt;- </span>add i, 1
      loop
    }
    loop
  }
  reply out/same-as-ingredient:1
]

scenario buffer-lines-blocks-until-newline [
  run [
    1:address:channel/stdin<span class="Special"> &lt;- </span><span class="Identifier">new</span>-channel 10/capacity
    2:address:channel/buffered-stdin<span class="Special"> &lt;- </span><span class="Identifier">new</span>-channel 10/capacity
    3:boolean<span class="Special"> &lt;- </span>channel-empty? 2:address:channel/buffered-stdin
    <span class="Identifier">assert</span> 3:boolean, [
F buffer-lines-blocks-until-newline: channel should be empty after init]
    <span class="Comment"># buffer stdin into buffered-stdin, try to read from buffered-stdin</span>
    4:number/buffer-routine<span class="Special"> &lt;- </span>start-running buffer-lines:recipe, 1:address:channel/stdin, 2:address:channel/buffered-stdin
    wait-for-routine 4:number/buffer-routine
    5:boolean<span class="Special"> &lt;- </span>channel-empty? 2:address:channel/buffered-stdin
    <span class="Identifier">assert</span> 5:boolean, [
F buffer-lines-blocks-until-newline: channel should be empty after buffer-lines bring-up]
    <span class="Comment"># write 'a'</span>
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">write</span> 1:address:channel, 97/a
    restart 4:number/buffer-routine
    wait-for-routine 4:number/buffer-routine
    6:boolean<span class="Special"> &lt;- </span>channel-empty? 2:address:channel/buffered-stdin
    <span class="Identifier">assert</span> 6:boolean, [
F buffer-lines-blocks-until-newline: channel should be empty after writing 'a']
    <span class="Comment"># write 'b'</span>
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">write</span> 1:address:channel, 98/b
    restart 4:number/buffer-routine
    wait-for-routine 4:number/buffer-routine
    7:boolean<span class="Special"> &lt;- </span>channel-empty? 2:address:channel/buffered-stdin
    <span class="Identifier">assert</span> 7:boolean, [
F buffer-lines-blocks-until-newline: channel should be empty after writing 'b']
    <span class="Comment"># write newline</span>
    1:address:channel<span class="Special"> &lt;- </span><span class="Identifier">write</span> 1:address:channel, 10/newline
    restart 4:number/buffer-routine
    wait-for-routine 4:number/buffer-routine
    8:boolean<span class="Special"> &lt;- </span>channel-empty? 2:address:channel/buffered-stdin
    9:boolean/completed?<span class="Special"> &lt;- </span>not 8:boolean
    <span class="Identifier">assert</span> 9:boolean/completed?, [
F buffer-lines-blocks-until-newline: channel should contain data after writing newline]
    trace 1, [test], [reached end]
  ]
  trace-should-contain [
    test: reached end
  ]
]
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
