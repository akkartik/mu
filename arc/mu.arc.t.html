<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>mu.arc.t</title>
<meta name="Generator" content="Vim/7.4">
<meta name="plugin-version" content="vim7.4_v1">
<meta name="syntax" content="scheme">
<meta name="settings" content="use_css,pre_wrap,no_foldcolumn,expand_tabs,prevent_copy=">
<meta name="colorscheme" content="minimal">
<style type="text/css">
<!--
pre { white-space: pre-wrap; font-family: monospace; color: #aaaaaa; background-color: #000000; }
body { font-family: monospace; color: #aaaaaa; background-color: #000000; }
a { color:#4444ff; }
* { font-size: 1em; }
.Global { color: #00af87; }
.SalientComment { color: #00ffff; }
.CommentedCode { color: #666666; }
.Mu, .Mu .Normal, .Mu .Constant { color: #eeeeee; }
.Op { color: #ff8888; }
.Delimiter { color: #600060; }
.Normal { color: #aaaaaa; }
.Comment { color: #8080ff; }
.Constant, .MuConstant { color: #008080; }
.Identifier { color: #008080; }
-->
</style>

<script type='text/javascript'>
<!--

-->
</script>
</head>
<body>
<pre id='vimCodeElement'>
<span class="Comment">; Mu: An exploration on making the global structure of programs more accessible.</span>
<span class="Comment">;</span>
<span class="Comment">;   &quot;Is it a language, or an operating system, or a virtual machine? Mu.&quot;</span>
<span class="Comment">;   (with apologies to Robert Pirsig: <a href="http://en.wikipedia.org/wiki/Mu_%28negative%29#In_popular_culture">http://en.wikipedia.org/wiki/Mu_%28negative%29#In_popular_culture</a>)</span>
<span class="Comment">;</span>
<span class="SalientComment">;; Motivation</span>
<span class="Comment">;</span>
<span class="Comment">; I want to live in a world where I can have an itch to tweak a program, clone</span>
<span class="Comment">; its open-source repository, orient myself on how it's organized, and make</span>
<span class="Comment">; the simple change I envisioned, all in an afternoon. This codebase tries to</span>
<span class="Comment">; make this possible for its readers. (More details: <a href="http://akkartik.name/about">http://akkartik.name/about</a>)</span>
<span class="Comment">;</span>
<span class="Comment">; What helps comprehend the global structure of programs? For starters, let's</span>
<span class="Comment">; enumerate what doesn't: idiomatic code, adherence to a style guide or naming</span>
<span class="Comment">; convention, consistent indentation, API documentation for each class, etc.</span>
<span class="Comment">; These conventional considerations improve matters in the small, but don't</span>
<span class="Comment">; help understand global organization. They help existing programmers manage</span>
<span class="Comment">; day-to-day operations, but they can't turn outsider programmers into</span>
<span class="Comment">; insiders. (Elaboration: <a href="http://akkartik.name/post/readable-bad">http://akkartik.name/post/readable-bad</a>)</span>
<span class="Comment">;</span>
<span class="Comment">; In my experience, two things have improved matters so far: version control</span>
<span class="Comment">; and automated tests. Version control lets me rewind back to earlier, simpler</span>
<span class="Comment">; times when the codebase was simpler, when its core skeleton was easier to</span>
<span class="Comment">; ascertain. Indeed, arguably what came first is by definition the skeleton of</span>
<span class="Comment">; a program, modulo major rewrites. Once you understand the skeleton, it</span>
<span class="Comment">; becomes tractable to 'play back' later major features one by one. (Previous</span>
<span class="Comment">; project that fleshed out this idea: <a href="http://akkartik.name/post/wart-layers">http://akkartik.name/post/wart-layers</a>)</span>
<span class="Comment">;</span>
<span class="Comment">; The second and biggest boost to comprehension comes from tests. Tests are</span>
<span class="Comment">; good for writers for well-understood reasons: they avoid regressions, and</span>
<span class="Comment">; they can influence code to be more decoupled and easier to change. In</span>
<span class="Comment">; addition, tests are also good for the outsider reader because they permit</span>
<span class="Comment">; active reading. If you can't build a program and run its tests it can't help</span>
<span class="Comment">; you understand it. It hangs limp at best, and might even be actively</span>
<span class="Comment">; misleading. If you can run its tests, however, it comes alive. You can step</span>
<span class="Comment">; through scenarios in a debugger. You can add logging and scan logs to make</span>
<span class="Comment">; sense of them. You can run what-if scenarios: &quot;why is this line not written</span>
<span class="Comment">; like this?&quot; Make a change, rerun tests: &quot;Oh, that's why.&quot; (Elaboration:</span>
<span class="Comment">; <a href="http://akkartik.name/post/literate-programming">http://akkartik.name/post/literate-programming</a>)</span>
<span class="Comment">;</span>
<span class="Comment">; However, tests are only useful to the extent that they exist. Think back to</span>
<span class="Comment">; your most recent codebase. Do you feel comfortable releasing a new version</span>
<span class="Comment">; just because the tests pass? I'm not aware of any such project. There's just</span>
<span class="Comment">; too many situations envisaged by the authors that were never encoded in a</span>
<span class="Comment">; test. Even disciplined authors can't test for performance or race conditions</span>
<span class="Comment">; or fault tolerance. If a line is phrased just so because of some subtle</span>
<span class="Comment">; performance consideration, it's hard to communicate to newcomers.</span>
<span class="Comment">;</span>
<span class="Comment">; This isn't an arcane problem, and it isn't just a matter of altruism. As</span>
<span class="Comment">; more and more such implicit considerations proliferate, and as the original</span>
<span class="Comment">; authors are replaced by latecomers for day-to-day operations, knowledge is</span>
<span class="Comment">; actively forgotten and lost. The once-pristine codebase turns into legacy</span>
<span class="Comment">; code that is hard to modify without expensive and stress-inducing</span>
<span class="Comment">; regressions.</span>
<span class="Comment">;</span>
<span class="Comment">; How to write tests for performance, fault tolerance, race conditions, etc.?</span>
<span class="Comment">; How can we state and verify that a codepath doesn't ever perform memory</span>
<span class="Comment">; allocation, or write to disk? It requires better, more observable primitives</span>
<span class="Comment">; than we currently have. Modern operating systems have their roots in the</span>
<span class="Comment">; 70s. Their interfaces were not designed to be testable. They provide no way</span>
<span class="Comment">; to simulate a full disk, or a specific sequence of writes from different</span>
<span class="Comment">; threads. We need something better.</span>
<span class="Comment">;</span>
<span class="Comment">; This project tries to move, groping, towards that 'something better', a</span>
<span class="Comment">; platform that is both thoroughly tested and allows programs written for it</span>
<span class="Comment">; to be thoroughly tested. It tries to answer the question:</span>
<span class="Comment">;</span>
<span class="Comment">;   If Denis Ritchie and Ken Thompson were to set out today to co-design unix</span>
<span class="Comment">;   and C, knowing what we know about automated tests, what would they do</span>
<span class="Comment">;   differently?</span>
<span class="Comment">;</span>
<span class="Comment">; To try to impose *some* constraints on this gigantic yak-shave, we'll try to</span>
<span class="Comment">; keep both language and OS as simple as possible, focused entirely on</span>
<span class="Comment">; permitting more kinds of tests, on first *collecting* all the information</span>
<span class="Comment">; about implicit considerations in some form so that readers and tools can</span>
<span class="Comment">; have at least some hope of making sense of it.</span>
<span class="Comment">;</span>
<span class="Comment">; The initial language will be just assembly. We'll try to make it convenient</span>
<span class="Comment">; to program in with some simple localized rewrite rules inspired by lisp</span>
<span class="Comment">; macros and literate programming. Programmers will have to do their own</span>
<span class="Comment">; memory management and register allocation, but we'll provide libraries to</span>
<span class="Comment">; help with them.</span>
<span class="Comment">;</span>
<span class="Comment">; The initial OS will provide just memory management and concurrency</span>
<span class="Comment">; primitives. No users or permissions (we don't live on mainframes anymore),</span>
<span class="Comment">; no kernel- vs user-mode, no virtual memory or process abstraction, all</span>
<span class="Comment">; threads sharing a single address space (use VMs for security and</span>
<span class="Comment">; sandboxing). The only use case we care about is getting a test harness to</span>
<span class="Comment">; run some code, feed it data through blocking channels, stop it and observe</span>
<span class="Comment">; its internals. The code under test is expected to cooperate in such testing,</span>
<span class="Comment">; by logging important events for the test harness to observe. (More info:</span>
<span class="Comment">; <a href="http://akkartik.name/post/tracing-tests">http://akkartik.name/post/tracing-tests</a>)</span>
<span class="Comment">;</span>
<span class="Comment">; The common thread here is elimination of abstractions, and it's not an</span>
<span class="Comment">; accident. Abstractions help insiders manage the evolution of a codebase, but</span>
<span class="Comment">; they actively hinder outsiders in understanding it from scratch. This</span>
<span class="Comment">; matters, because the funnel to turn outsiders into insiders is critical to</span>
<span class="Comment">; the long-term life of a codebase. Perhaps authors should raise their</span>
<span class="Comment">; estimation of the costs of abstraction, and go against their instincts for</span>
<span class="Comment">; introducing it. That's what I'll be trying to do: question every abstraction</span>
<span class="Comment">; before I introduce it. We'll see how it goes.</span>

<span class="Comment">; ---</span>

<span class="SalientComment">;; Getting started</span>
<span class="Comment">;</span>
<span class="Comment">; Mu is currently built atop Racket and Arc, but this is temporary and</span>
<span class="Comment">; contingent. We want to keep our options open, whether to port to a different</span>
<span class="Comment">; host language, and easy to rewrite to native code for any platform. So we'll</span>
<span class="Comment">; try to avoid 'cheating': relying on the host platform for advanced</span>
<span class="Comment">; functionality.</span>
<span class="Comment">;</span>
<span class="Comment">; Other than that, we'll say no more about the code, and focus in the rest of</span>
<span class="Comment">; this file on the scenarios the code cares about.</span>

<span class="Delimiter">(</span>selective-load <span class="Constant">&quot;mu.arc&quot;</span> section-level<span class="Delimiter">)</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>section <span class="Constant">20</span>

<span class="Comment">; Our language is assembly-like in that functions consist of series of</span>
<span class="Comment">; statements, and statements consist of an operation and its arguments (input</span>
<span class="Comment">; and output).</span>
<span class="Comment">;</span>
<span class="Comment">;   oarg1, oarg2, ... <span class="Op">&lt;-</span> op arg1, arg2, ...</span>
<span class="Comment">;</span>
<span class="Comment">; Args must be atomic, like an integer or a memory address, they can't be</span>
<span class="Comment">; expressions doing arithmetic or function calls. But we can have any number</span>
<span class="Comment">; of them.</span>
<span class="Comment">;</span>
<span class="Comment">; Since we're building on lisp, our code samples won't look quite like the</span>
<span class="Comment">; idealized syntax above. For now they will look like this:</span>
<span class="Comment">;</span>
<span class="Comment">;   (function f [</span>
<span class="Comment">;     (oarg1 oarg2 ... <span class="Op">&lt;-</span> op arg1 arg2 ...)</span>
<span class="Comment">;     ...</span>
<span class="Comment">;     ...</span>
<span class="Comment">;    ])</span>
<span class="Comment">;</span>
<span class="Comment">; Each arg/oarg can contain metadata separated by slashes and colons. In this</span>
<span class="Comment">; first example below, the only metadata is types: 'integer' for a memory</span>
<span class="Comment">; location containing an integer, and 'literal' for a value included directly</span>
<span class="Comment">; in code. (Assembly languages traditionally call them 'immediate' operands.)</span>
<span class="Comment">; In the future a simple tool will check that the types line up as expected in</span>
<span class="Comment">; each op. A different tool might add types where they aren't provided.</span>
<span class="Comment">; Instead of a monolithic compiler I want to build simple, lightweight tools</span>
<span class="Comment">; that can be combined in various ways, say for using different typecheckers</span>
<span class="Comment">; in different subsystems.</span>
<span class="Comment">;</span>
<span class="Comment">; In our tests we'll define such mu functions using a call to 'add-code', so</span>
<span class="Comment">; look for it when reading the code examples. Everything outside 'add-code' is</span>
<span class="Comment">; just test-harness details that can be skipped at first.</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;literal&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">23</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.1</span> <span class="Constant">23</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'copy' writes its lone 'arg' after the instruction name to its lone 'oarg' or output arg before the arrow. After this test, the value 23 is stored in memory address 1.&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Comment">; Our basic arithmetic ops can operate on memory locations or literals.</span>
<span class="Comment">; (Ignore hardware details like registers for now.)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;add&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> add <span class="Constant">1</span>:integer <span class="Constant">2</span>:integer<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">1</span> <span class="Constant">1</span>  <span class="Constant">2</span> <span class="Constant">3</span>  <span class="Constant">3</span> <span class="Constant">4</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'add' operates on two addresses&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;add-literal&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> add <span class="MuConstant">2</span>:literal <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.1</span> <span class="Constant">5</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - ops can take 'literal' operands (but not return them)&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;sub-literal&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> subtract <span class="MuConstant">1</span>:literal <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.1</span> <span class="Constant">-2</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'subtract'&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;mul-literal&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> multiply <span class="MuConstant">2</span>:literal <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.1</span> <span class="Constant">6</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'multiply'&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;div-literal&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> divide <span class="MuConstant">8</span>:literal <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.1</span> <span class="Delimiter">(</span>/ real.8 <span class="Constant">3</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'divide'&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;idiv-literal&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Constant">2</span>:integer <span class="Op">&lt;-</span> divide-with-remainder <span class="MuConstant">23</span>:literal <span class="MuConstant">6</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">1</span> <span class="Constant">3</span>  <span class="Constant">2</span> <span class="Constant">5</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'divide-with-remainder' performs integer division&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;dummy-oarg&quot;</span><span class="Delimiter">)</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span>_ <span class="Constant">2</span>:integer <span class="Op">&lt;-</span> divide-with-remainder <span class="MuConstant">23</span>:literal <span class="MuConstant">6</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">2</span> <span class="Constant">5</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - '_' oarg can ignore some results&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Comment">; Basic boolean operations: and, or, not</span>
<span class="Comment">; There are easy ways to encode booleans in binary, but we'll skip past those</span>
<span class="Comment">; details for now.</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;and-literal&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:boolean <span class="Op">&lt;-</span> and <span class="MuConstant">t</span>:literal <span class="MuConstant">nil</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.1</span> nil<span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - logical 'and' for booleans&quot;</span><span class="Delimiter">))</span>

<span class="Comment">; Basic comparison operations</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;lt-literal&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:boolean <span class="Op">&lt;-</span> less-than <span class="MuConstant">4</span>:literal <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.1</span> nil<span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'less-than' inequality operator&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;le-literal-false&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:boolean <span class="Op">&lt;-</span> lesser-or-equal <span class="MuConstant">4</span>:literal <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.1</span> nil<span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'lesser-or-equal'&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;le-literal-true&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:boolean <span class="Op">&lt;-</span> lesser-or-equal <span class="MuConstant">4</span>:literal <span class="MuConstant">4</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.1</span> t<span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'lesser-or-equal' returns true for equal operands&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;le-literal-true-2&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:boolean <span class="Op">&lt;-</span> lesser-or-equal <span class="MuConstant">4</span>:literal <span class="MuConstant">5</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.1</span> t<span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'lesser-or-equal' - 2&quot;</span><span class="Delimiter">))</span>

<span class="Comment">; Control flow operations: jump, jump-if, jump-unless</span>
<span class="Comment">; These introduce a new type -- 'offset' -- for literals that refer to memory</span>
<span class="Comment">; locations relative to the current location.</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;jump-skip&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">8</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">jump</span> <span class="MuConstant">1</span>:offset<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span>  <span class="Comment">; should be skipped</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span><span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">1</span> <span class="Constant">8</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'jump' skips some instructions&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;jump-target&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">8</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">jump</span> <span class="MuConstant">1</span>:offset<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span>  <span class="Comment">; should be skipped</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>  <span class="Comment">; never reached</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">1</span> <span class="Constant">8</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'jump' doesn't skip too many instructions&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;jump-if-skip&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:boolean <span class="Op">&lt;-</span> equal <span class="MuConstant">1</span>:literal <span class="Constant">2</span>:integer<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">jump-if</span> <span class="Constant">1</span>:boolean <span class="MuConstant">1</span>:offset<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">1</span> t  <span class="Constant">2</span> <span class="Constant">1</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'jump-if' is a conditional 'jump'&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;jump-if-fallthrough&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:boolean <span class="Op">&lt;-</span> equal <span class="MuConstant">1</span>:literal <span class="MuConstant">2</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">jump-if</span> <span class="Constant">3</span>:boolean <span class="MuConstant">1</span>:offset<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">1</span> nil  <span class="Constant">2</span> <span class="Constant">3</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - if 'jump-if's first arg is false, it doesn't skip any instructions&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;jump-if-backward&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">2</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Comment">; loop</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> add <span class="Constant">2</span>:integer <span class="Constant">2</span>:integer<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:boolean <span class="Op">&lt;-</span> equal <span class="Constant">1</span>:integer <span class="Constant">2</span>:integer<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">jump-if</span> <span class="Constant">3</span>:boolean <span class="MuConstant">-3</span>:offset<span class="Delimiter">)</span>  <span class="Comment">; to loop</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">1</span> <span class="Constant">2</span>  <span class="Constant">2</span> <span class="Constant">4</span>  <span class="Constant">3</span> nil  <span class="Constant">4</span> <span class="Constant">3</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'jump-if' can take a negative offset to make backward jumps&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;jump-label&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">2</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Identifier">loop</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> add <span class="Constant">2</span>:integer <span class="Constant">2</span>:integer<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:boolean <span class="Op">&lt;-</span> equal <span class="Constant">1</span>:integer <span class="Constant">2</span>:integer<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">jump-if</span> <span class="Constant">3</span>:boolean <span class="Identifier">loop</span>:offset<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;-&quot;)))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">1</span> <span class="Constant">2</span>  <span class="Constant">2</span> <span class="Constant">4</span>  <span class="Constant">3</span> nil  <span class="Constant">4</span> <span class="Constant">3</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'jump-if' can take a negative offset to make backward jumps&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Comment">; Data movement relies on addressing modes:</span>
<span class="Comment">;   'direct' - refers to a memory location; default for most types.</span>
<span class="Comment">;   'literal' - directly encoded in the code; implicit for some types like 'offset'.</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;direct-addressing&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="Constant">1</span>:integer<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">1</span> <span class="Constant">34</span>  <span class="Constant">2</span> <span class="Constant">34</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'copy' performs direct addressing&quot;</span><span class="Delimiter">))</span>

<span class="Comment">; 'Indirect' addressing refers to an address stored in a memory location.</span>
<span class="Comment">; Indicated by the metadata 'deref'. Usually requires an address type.</span>
<span class="Comment">; In the test below, the memory location 1 contains '2', so an indirect read</span>
<span class="Comment">; of location 1 returns the value of location 2.</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;indirect-addressing&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer-address <span class="Op">&lt;-</span> copy <span class="MuConstant">2</span>:literal<span class="Delimiter">)</span>  <span class="Comment">; unsafe; can't do this in general</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="Constant">1</span>:integer-address/deref<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">1</span> <span class="Constant">2</span>  <span class="Constant">2</span> <span class="Constant">34</span>  <span class="Constant">3</span> <span class="Constant">34</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'copy' performs indirect addressing&quot;</span><span class="Delimiter">))</span>

<span class="Comment">; Output args can use indirect addressing. In the test below the value is</span>
<span class="Comment">; stored at the location stored in location 1 (i.e. location 2).</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;indirect-addressing-oarg&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer-address <span class="Op">&lt;-</span> copy <span class="MuConstant">2</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer-address/deref <span class="Op">&lt;-</span> add <span class="Constant">2</span>:integer <span class="MuConstant">2</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">1</span> <span class="Constant">2</span>  <span class="Constant">2</span> <span class="Constant">36</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - instructions can perform indirect addressing on output arg&quot;</span><span class="Delimiter">))</span>

<span class="SalientComment">;; Compound data types</span>
<span class="Comment">;</span>
<span class="Comment">; Until now we've dealt with scalar types like integers and booleans and</span>
<span class="Comment">; addresses, where mu looks like other assembly languages. In addition, mu</span>
<span class="Comment">; provides first-class support for compound types: arrays and and-records.</span>
<span class="Comment">;</span>
<span class="Comment">; 'get' accesses fields in and-records</span>
<span class="Comment">; 'index' accesses indices in arrays</span>
<span class="Comment">;</span>
<span class="Comment">; Both operations require knowledge about the types being worked on, so all</span>
<span class="Comment">; types used in mu programs are defined in a single global system-wide table</span>
<span class="Comment">; (see type* in mu.arc for the complete list of types; we'll add to it over</span>
<span class="Comment">; time).</span>

<span class="Comment">; first a sanity check that the table of types is consistent</span>
<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>each <span class="Delimiter">(</span>typ typeinfo<span class="Delimiter">)</span> <span class="Global">type*</span>
  <span class="Delimiter">(</span>when typeinfo!and-record
    <span class="Delimiter">(</span>assert <span class="Delimiter">(</span>is typeinfo!size <span class="Delimiter">(</span>len typeinfo!elems<span class="Delimiter">)))</span>
    <span class="Delimiter">(</span>when typeinfo!fields
      <span class="Delimiter">(</span>assert <span class="Delimiter">(</span>is typeinfo!size <span class="Delimiter">(</span>len typeinfo!fields<span class="Delimiter">))))))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;get-record&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:boolean <span class="Op">&lt;-</span> copy <span class="MuConstant">nil</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:boolean <span class="Op">&lt;-</span> get <span class="Constant">1</span>:integer-boolean-pair <span class="MuConstant">1</span>:offset<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> get <span class="Constant">1</span>:integer-boolean-pair <span class="MuConstant">0</span>:offset<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">1</span> <span class="Constant">34</span>  <span class="Constant">2</span> nil  <span class="Constant">3</span> nil  <span class="Constant">4</span> <span class="Constant">34</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'get' accesses fields of and-records&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;get-indirect&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:boolean <span class="Op">&lt;-</span> copy <span class="MuConstant">nil</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer-boolean-pair-address <span class="Op">&lt;-</span> copy <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:boolean <span class="Op">&lt;-</span> get <span class="Constant">3</span>:integer-boolean-pair-address/deref <span class="MuConstant">1</span>:offset<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:integer <span class="Op">&lt;-</span> get <span class="Constant">3</span>:integer-boolean-pair-address/deref <span class="MuConstant">0</span>:offset<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">1</span> <span class="Constant">34</span>  <span class="Constant">2</span> nil  <span class="Constant">3</span> <span class="Constant">1</span>  <span class="Constant">4</span> nil  <span class="Constant">5</span> <span class="Constant">34</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'get' accesses fields of and-record address&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;get-indirect-repeated&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">35</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">36</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer-point-pair-address <span class="Op">&lt;-</span> copy <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span>  <span class="Comment">; unsafe</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:integer-point-pair-address-address <span class="Op">&lt;-</span> copy <span class="MuConstant">4</span>:literal<span class="Delimiter">)</span>  <span class="Comment">; unsafe</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">6</span>:integer-integer-pair <span class="Op">&lt;-</span> get <span class="Constant">5</span>:integer-point-pair-address-address/deref/deref <span class="MuConstant">1</span>:offset<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">8</span>:integer <span class="Op">&lt;-</span> get <span class="Constant">5</span>:integer-point-pair-address-address/deref/deref <span class="MuConstant">0</span>:offset<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~memory-contains <span class="Constant">6</span> <span class="Delimiter">'(</span><span class="Constant">35</span> <span class="Constant">36</span> <span class="Constant">34</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'get' can deref multiple times&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;get-compound-field&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">35</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">36</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer-integer-pair <span class="Op">&lt;-</span> get <span class="Constant">1</span>:integer-point-pair <span class="MuConstant">1</span>:offset<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">1</span> <span class="Constant">34</span>  <span class="Constant">2</span> <span class="Constant">35</span>  <span class="Constant">3</span> <span class="Constant">36</span>  <span class="Constant">4</span> <span class="Constant">35</span>  <span class="Constant">5</span> <span class="Constant">36</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'get' accesses fields spanning multiple locations&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;get-address&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:boolean <span class="Op">&lt;-</span> copy <span class="MuConstant">t</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:boolean-address <span class="Op">&lt;-</span> get-address <span class="Constant">1</span>:integer-boolean-pair <span class="MuConstant">1</span>:offset<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">1</span> <span class="Constant">34</span>  <span class="Constant">2</span> t  <span class="Constant">3</span> <span class="Constant">2</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'get-address' returns address of fields of and-records&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;get-address-indirect&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:boolean <span class="Op">&lt;-</span> copy <span class="MuConstant">t</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer-boolean-pair-address <span class="Op">&lt;-</span> copy <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:boolean-address <span class="Op">&lt;-</span> get-address <span class="Constant">3</span>:integer-boolean-pair-address/deref <span class="MuConstant">1</span>:offset<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">1</span> <span class="Constant">34</span>  <span class="Constant">2</span> t  <span class="Constant">3</span> <span class="Constant">1</span>  <span class="Constant">4</span> <span class="Constant">2</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'get-address' accesses fields of and-record address&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;index-literal&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">2</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">23</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:boolean <span class="Op">&lt;-</span> copy <span class="MuConstant">nil</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">24</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:boolean <span class="Op">&lt;-</span> copy <span class="MuConstant">t</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">6</span>:integer-boolean-pair <span class="Op">&lt;-</span> index <span class="Constant">1</span>:integer-boolean-pair-array <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">1</span> <span class="Constant">2</span>  <span class="Constant">2</span> <span class="Constant">23</span> <span class="Constant">3</span> nil  <span class="Constant">4</span> <span class="Constant">24</span> <span class="Constant">5</span> t  <span class="Constant">6</span> <span class="Constant">24</span> <span class="Constant">7</span> t<span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'index' accesses indices of arrays&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;index-direct&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">2</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">23</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:boolean <span class="Op">&lt;-</span> copy <span class="MuConstant">nil</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">24</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:boolean <span class="Op">&lt;-</span> copy <span class="MuConstant">t</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">6</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">7</span>:integer-boolean-pair <span class="Op">&lt;-</span> index <span class="Constant">1</span>:integer-boolean-pair-array <span class="Constant">6</span>:integer<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">1</span> <span class="Constant">2</span>  <span class="Constant">2</span> <span class="Constant">23</span> <span class="Constant">3</span> nil  <span class="Constant">4</span> <span class="Constant">24</span> <span class="Constant">5</span> t  <span class="Constant">6</span> <span class="Constant">1</span>  <span class="Constant">7</span> <span class="Constant">24</span> <span class="Constant">8</span> t<span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'index' accesses indices of arrays&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;index-indirect&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">2</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">23</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:boolean <span class="Op">&lt;-</span> copy <span class="MuConstant">nil</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">24</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:boolean <span class="Op">&lt;-</span> copy <span class="MuConstant">t</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">6</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">7</span>:integer-boolean-pair-array-address <span class="Op">&lt;-</span> copy <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">8</span>:integer-boolean-pair <span class="Op">&lt;-</span> index <span class="Constant">7</span>:integer-boolean-pair-array-address/deref <span class="Constant">6</span>:integer<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (= dump-trace* (obj blacklist '(&quot;sz&quot; &quot;m&quot; &quot;setm&quot; &quot;addr&quot; &quot;cvt0&quot; &quot;cvt1&quot;)))</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">1</span> <span class="Constant">2</span>  <span class="Constant">2</span> <span class="Constant">23</span> <span class="Constant">3</span> nil  <span class="Constant">4</span> <span class="Constant">24</span> <span class="Constant">5</span> t  <span class="Constant">6</span> <span class="Constant">1</span>  <span class="Constant">7</span> <span class="Constant">1</span>  <span class="Constant">8</span> <span class="Constant">24</span> <span class="Constant">9</span> t<span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'index' accesses indices of array address&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;index-indirect-multiple&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">4</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">23</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">24</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">25</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">26</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">6</span>:integer-array-address <span class="Op">&lt;-</span> copy <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span>  <span class="Comment">; unsafe</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">7</span>:integer-array-address-address <span class="Op">&lt;-</span> copy <span class="MuConstant">6</span>:literal<span class="Delimiter">)</span>  <span class="Comment">; unsafe</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">8</span>:integer <span class="Op">&lt;-</span> index <span class="Constant">7</span>:integer-array-address-address/deref/deref <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.8</span> <span class="Constant">24</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'index' can deref multiple times&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;index-address&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">2</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">23</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:boolean <span class="Op">&lt;-</span> copy <span class="MuConstant">nil</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">24</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:boolean <span class="Op">&lt;-</span> copy <span class="MuConstant">t</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">6</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">7</span>:integer-boolean-pair-address <span class="Op">&lt;-</span> index-address <span class="Constant">1</span>:integer-boolean-pair-array <span class="Constant">6</span>:integer<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">1</span> <span class="Constant">2</span>  <span class="Constant">2</span> <span class="Constant">23</span> <span class="Constant">3</span> nil  <span class="Constant">4</span> <span class="Constant">24</span> <span class="Constant">5</span> t  <span class="Constant">6</span> <span class="Constant">1</span>  <span class="Constant">7</span> <span class="Constant">4</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'index-address' returns addresses of indices of arrays&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;index-address-indirect&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">2</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">23</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:boolean <span class="Op">&lt;-</span> copy <span class="MuConstant">nil</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">24</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:boolean <span class="Op">&lt;-</span> copy <span class="MuConstant">t</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">6</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">7</span>:integer-boolean-pair-array-address <span class="Op">&lt;-</span> copy <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">8</span>:integer-boolean-pair-address <span class="Op">&lt;-</span> index-address <span class="Constant">7</span>:integer-boolean-pair-array-address/deref <span class="Constant">6</span>:integer<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">1</span> <span class="Constant">2</span>  <span class="Constant">2</span> <span class="Constant">23</span> <span class="Constant">3</span> nil  <span class="Constant">4</span> <span class="Constant">24</span> <span class="Constant">5</span> t  <span class="Constant">6</span> <span class="Constant">1</span>  <span class="Constant">7</span> <span class="Constant">1</span>  <span class="Constant">8</span> <span class="Constant">4</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'index-address' returns addresses of indices of array addresses&quot;</span><span class="Delimiter">))</span>

<span class="Comment">; Array values know their length. Record lengths are saved in the types table.</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;len-array&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">2</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">23</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:boolean <span class="Op">&lt;-</span> copy <span class="MuConstant">nil</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">24</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:boolean <span class="Op">&lt;-</span> copy <span class="MuConstant">t</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">6</span>:integer <span class="Op">&lt;-</span> length <span class="Constant">1</span>:integer-boolean-pair-array<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.6</span> <span class="Constant">2</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'length' of array&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;len-array-indirect&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">2</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">23</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:boolean <span class="Op">&lt;-</span> copy <span class="MuConstant">nil</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">24</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:boolean <span class="Op">&lt;-</span> copy <span class="MuConstant">t</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">6</span>:integer-address <span class="Op">&lt;-</span> copy <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">7</span>:integer <span class="Op">&lt;-</span> length <span class="Constant">6</span>:integer-boolean-pair-array-address/deref<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="CommentedCode">;? (= dump-trace* (obj blacklist '(&quot;sz&quot; &quot;m&quot; &quot;setm&quot; &quot;addr&quot; &quot;cvt0&quot; &quot;cvt1&quot;)))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.7</span> <span class="Constant">2</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'length' of array address&quot;</span><span class="Delimiter">))</span>

<span class="Comment">; 'sizeof' is a helper to determine the amount of memory required by a type.</span>
<span class="Comment">; Only for non-arrays.</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;sizeof-record&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> sizeof integer-boolean-pair:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.1</span> <span class="Constant">2</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'sizeof' returns space required by arg&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;sizeof-record-not-len&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> sizeof integer-point-pair:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>is <span class="Global">memory*</span><span class="Constant">.1</span> <span class="Constant">2</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'sizeof' is different from number of elems&quot;</span><span class="Delimiter">))</span>

<span class="Comment">; Regardless of a type's length, you can move it around just like a primitive.</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;copy-record&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:boolean <span class="Op">&lt;-</span> copy <span class="MuConstant">nil</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:boolean <span class="Op">&lt;-</span> copy <span class="MuConstant">t</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer-boolean-pair <span class="Op">&lt;-</span> copy <span class="Constant">1</span>:integer-boolean-pair<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">1</span> <span class="Constant">34</span>  <span class="Constant">2</span> nil  <span class="Constant">3</span> <span class="Constant">34</span>  <span class="Constant">4</span> nil<span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - ops can operate on records spanning multiple locations&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;copy-record2&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">35</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">36</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">6</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer-point-pair <span class="Op">&lt;-</span> copy <span class="Constant">1</span>:integer-point-pair<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;run&quot; &quot;sizeof&quot;)))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">1</span> <span class="Constant">34</span>  <span class="Constant">2</span> <span class="Constant">35</span>  <span class="Constant">3</span> <span class="Constant">36</span>
                       <span class="Comment">; result</span>
                       <span class="Constant">4</span> <span class="Constant">34</span>  <span class="Constant">5</span> <span class="Constant">35</span>  <span class="Constant">6</span> <span class="Constant">36</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - ops can operate on records with fields spanning multiple locations&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">)</span>  <span class="Comment">; section 20</span>

<span class="Delimiter">(</span>section <span class="Constant">100</span>

<span class="Comment">; A special kind of record is the 'tagged type'. It lets us represent</span>
<span class="Comment">; dynamically typed values, which save type information in memory rather than</span>
<span class="Comment">; in the code to use them. This will let us do things like create heterogenous</span>
<span class="Comment">; lists containing both integers and strings. Tagged values admit two</span>
<span class="Comment">; operations:</span>
<span class="Comment">;</span>
<span class="Comment">;   'save-type' - turns a regular value into a tagged-value of the appropriate type</span>
<span class="Comment">;   'maybe-coerce' - turns a tagged value into a regular value if the type matches</span>
<span class="Comment">;</span>
<span class="Comment">; The payload of a tagged value must occupy just one location. Save pointers</span>
<span class="Comment">; to records.</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;tagged-value&quot;</span><span class="Delimiter">)</span>
<span class="CommentedCode">;? (= dump-trace* (obj blacklist '(&quot;sz&quot; &quot;m&quot; &quot;setm&quot; &quot;addr&quot; &quot;cvt0&quot; &quot;cvt1&quot;)))</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:type <span class="Op">&lt;-</span> copy integer:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Constant">4</span>:boolean <span class="Op">&lt;-</span> maybe-coerce <span class="Constant">1</span>:tagged-value integer:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn completed-routines*)</span>
<span class="Delimiter">(</span>each routine <span class="Global">completed-routines*</span>
  <span class="Delimiter">(</span>aif rep.routine!error <span class="Delimiter">(</span>prn <span class="Constant">&quot;error - &quot;</span> it<span class="Delimiter">)))</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span><span class="Normal">or</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.3</span> <span class="Constant">34</span><span class="Delimiter">)</span>
        <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.4</span> t<span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'maybe-coerce' copies value only if type tag matches&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;tagged-value-2&quot;</span><span class="Delimiter">)</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:type <span class="Op">&lt;-</span> copy integer-address:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:boolean <span class="Constant">4</span>:boolean <span class="Op">&lt;-</span> maybe-coerce <span class="Constant">1</span>:tagged-value boolean:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span><span class="Normal">or</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.3</span> <span class="Constant">0</span><span class="Delimiter">)</span>
        <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.4</span> nil<span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'maybe-coerce' doesn't copy value when type tag doesn't match&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;save-type&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:tagged-value <span class="Op">&lt;-</span> save-type <span class="Constant">1</span>:integer<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj  <span class="Constant">1</span> <span class="Constant">34</span>  <span class="Constant">2</span> <span class="Delimiter">'</span>integer  <span class="Constant">3</span> <span class="Constant">34</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'save-type' saves the type of a value at runtime, turning it into a tagged-value&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;init-tagged-value&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:tagged-value-address <span class="Op">&lt;-</span> init-tagged-value integer:literal <span class="Constant">1</span>:integer<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Constant">4</span>:boolean <span class="Op">&lt;-</span> maybe-coerce <span class="Constant">2</span>:tagged-value-address/deref integer:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (= dump-trace* (obj blacklist '(&quot;sz&quot; &quot;m&quot; &quot;setm&quot; &quot;addr&quot; &quot;cvt0&quot; &quot;cvt1&quot; &quot;sizeof&quot;)))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span><span class="Normal">or</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.3</span> <span class="Constant">34</span><span class="Delimiter">)</span>
        <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.4</span> t<span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'init-tagged-value' is the converse of 'maybe-coerce'&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Comment">; Now that we can package values together with their types, we can construct a</span>
<span class="Comment">; dynamically typed list.</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;list&quot;</span><span class="Delimiter">)</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Comment">; 1 points at first node: tagged-value (int 34)</span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:list-address <span class="Op">&lt;-</span> new list:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:tagged-value-address <span class="Op">&lt;-</span> list-value-address <span class="Constant">1</span>:list-address<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:type-address <span class="Op">&lt;-</span> get-address <span class="Constant">2</span>:tagged-value-address/deref type:offset<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:type-address/deref <span class="Op">&lt;-</span> copy integer:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:location <span class="Op">&lt;-</span> get-address <span class="Constant">2</span>:tagged-value-address/deref payload:offset<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:location/deref <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:list-address-address <span class="Op">&lt;-</span> get-address <span class="Constant">1</span>:list-address/deref cdr:offset<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:list-address-address/deref <span class="Op">&lt;-</span> new list:literal<span class="Delimiter">)</span></span>
      <span class="Comment">; 6 points at second node: tagged-value (boolean t)</span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">6</span>:list-address <span class="Op">&lt;-</span> copy <span class="Constant">5</span>:list-address-address/deref<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">7</span>:tagged-value-address <span class="Op">&lt;-</span> list-value-address <span class="Constant">6</span>:list-address<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">8</span>:type-address <span class="Op">&lt;-</span> get-address <span class="Constant">7</span>:tagged-value-address/deref type:offset<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">8</span>:type-address/deref <span class="Op">&lt;-</span> copy boolean:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">9</span>:location <span class="Op">&lt;-</span> get-address <span class="Constant">7</span>:tagged-value-address/deref payload:offset<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">9</span>:location/deref <span class="Op">&lt;-</span> copy <span class="MuConstant">t</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">10</span>:list-address <span class="Op">&lt;-</span> get <span class="Constant">6</span>:list-address/deref <span class="MuConstant">1</span>:offset<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span><span class="Normal">let</span> routine make-routine!main
  <span class="Delimiter">(</span>enq routine <span class="Global">running-routines*</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span><span class="Normal">let</span> first rep.routine!alloc
<span class="CommentedCode">;?     (= dump-trace* (obj whitelist '(&quot;run&quot;)))</span>
<span class="CommentedCode">;?     (set dump-trace*)</span>
    <span class="Delimiter">(</span>run<span class="Delimiter">)</span>
<span class="CommentedCode">;?     (prn memory*)</span>
    <span class="Delimiter">(</span>each routine <span class="Global">completed-routines*</span>
      <span class="Delimiter">(</span>aif rep.routine!error <span class="Delimiter">(</span>prn <span class="Constant">&quot;error - &quot;</span> it<span class="Delimiter">)))</span>
    <span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span><span class="Normal">or</span> <span class="Delimiter">(</span>~all first <span class="Delimiter">(</span>map <span class="Global">memory*</span> <span class="Delimiter">'(</span><span class="Constant">1</span> <span class="Constant">2</span> <span class="Constant">3</span><span class="Delimiter">)))</span>
            <span class="Delimiter">(</span>~is <span class="Global">memory*</span>.first  <span class="Delimiter">'</span>integer<span class="Delimiter">)</span>
            <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.4</span> <span class="Delimiter">(</span>+ first <span class="Constant">1</span><span class="Delimiter">))</span>
            <span class="Delimiter">(</span>~is <span class="Delimiter">(</span><span class="Global">memory*</span> <span class="Delimiter">(</span>+ first <span class="Constant">1</span><span class="Delimiter">))</span>  <span class="Constant">34</span><span class="Delimiter">)</span>
            <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.5</span> <span class="Delimiter">(</span>+ first <span class="Constant">2</span><span class="Delimiter">))</span>
            <span class="Delimiter">(</span><span class="Normal">let</span> second <span class="Global">memory*</span><span class="Constant">.6</span>
              <span class="Delimiter">(</span><span class="Normal">or</span>
                <span class="Delimiter">(</span>~is <span class="Delimiter">(</span><span class="Global">memory*</span> <span class="Delimiter">(</span>+ first <span class="Constant">2</span><span class="Delimiter">))</span> second<span class="Delimiter">)</span>
                <span class="Delimiter">(</span>~all second <span class="Delimiter">(</span>map <span class="Global">memory*</span> <span class="Delimiter">'(</span><span class="Constant">6</span> <span class="Constant">7</span> <span class="Constant">8</span><span class="Delimiter">)))</span>
                <span class="Delimiter">(</span>~is <span class="Global">memory*</span>.second <span class="Delimiter">'</span>boolean<span class="Delimiter">)</span>
                <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.9</span> <span class="Delimiter">(</span>+ second <span class="Constant">1</span><span class="Delimiter">))</span>
                <span class="Delimiter">(</span>~is <span class="Delimiter">(</span><span class="Global">memory*</span> <span class="Delimiter">(</span>+ second <span class="Constant">1</span><span class="Delimiter">))</span> t<span class="Delimiter">)</span>
                <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.10</span> nil<span class="Delimiter">))))</span>
      <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - lists can contain elements of different types&quot;</span><span class="Delimiter">))))</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function test2 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">10</span>:list-address <span class="Op">&lt;-</span> list-next <span class="Constant">1</span>:list-address<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>test2<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span>each routine <span class="Global">completed-routines*</span>
  <span class="Delimiter">(</span>aif rep.routine!error <span class="Delimiter">(</span>prn <span class="Constant">&quot;error - &quot;</span> it<span class="Delimiter">)))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.10</span> <span class="Global">memory*</span><span class="Constant">.6</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'list-next can move a list pointer to the next node&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Comment">; 'init-list' takes a variable number of args and constructs a list containing</span>
<span class="Comment">; them. Just integers for now.</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;init-list&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> init-list <span class="MuConstant">3</span>:literal <span class="MuConstant">4</span>:literal <span class="MuConstant">5</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (= dump-trace* (obj blacklist '(&quot;sz&quot; &quot;m&quot; &quot;setm&quot; &quot;addr&quot; &quot;cvt0&quot; &quot;cvt1&quot; &quot;sizeof&quot;)))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">let</span> first <span class="Global">memory*</span><span class="Constant">.1</span>
<span class="CommentedCode">;?   (prn first)</span>
  <span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span><span class="Normal">or</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span>.first  <span class="Delimiter">'</span>integer<span class="Delimiter">)</span>
          <span class="Delimiter">(</span>~is <span class="Delimiter">(</span><span class="Global">memory*</span> <span class="Delimiter">(</span>+ first <span class="Constant">1</span><span class="Delimiter">))</span>  <span class="Constant">3</span><span class="Delimiter">)</span>
          <span class="Delimiter">(</span><span class="Normal">let</span> second <span class="Delimiter">(</span><span class="Global">memory*</span> <span class="Delimiter">(</span>+ first <span class="Constant">2</span><span class="Delimiter">))</span>
<span class="CommentedCode">;?             (prn second)</span>
            <span class="Delimiter">(</span><span class="Normal">or</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span>.second <span class="Delimiter">'</span>integer<span class="Delimiter">)</span>
                <span class="Delimiter">(</span>~is <span class="Delimiter">(</span><span class="Global">memory*</span> <span class="Delimiter">(</span>+ second <span class="Constant">1</span><span class="Delimiter">))</span> <span class="Constant">4</span><span class="Delimiter">)</span>
                <span class="Delimiter">(</span><span class="Normal">let</span> third <span class="Delimiter">(</span><span class="Global">memory*</span> <span class="Delimiter">(</span>+ second <span class="Constant">2</span><span class="Delimiter">))</span>
<span class="CommentedCode">;?                   (prn third)</span>
                  <span class="Delimiter">(</span><span class="Normal">or</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span>.third <span class="Delimiter">'</span>integer<span class="Delimiter">)</span>
                      <span class="Delimiter">(</span>~is <span class="Delimiter">(</span><span class="Global">memory*</span> <span class="Delimiter">(</span>+ third <span class="Constant">1</span><span class="Delimiter">))</span> <span class="Constant">5</span><span class="Delimiter">)</span>
                      <span class="Delimiter">(</span>~is <span class="Delimiter">(</span><span class="Global">memory*</span> <span class="Delimiter">(</span>+ third <span class="Constant">2</span><span class="Delimiter">)</span> nil<span class="Delimiter">)))))))</span>
    <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'init-list' can construct a list of integers&quot;</span><span class="Delimiter">)))</span>

<span class="Delimiter">)</span>  <span class="Comment">; section 100</span>

<span class="Delimiter">(</span>section <span class="Constant">20</span>

<span class="SalientComment">;; Functions</span>
<span class="Comment">;</span>
<span class="Comment">; Just like the table of types is centralized, functions are conceptualized as</span>
<span class="Comment">; a centralized table of operations just like the &quot;primitives&quot; we've seen so</span>
<span class="Comment">; far. If you create a function you can call it like any other op.</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;new-fn&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function test1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> add <span class="Constant">1</span>:integer <span class="Constant">2</span>:integer<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span>test1<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">1</span> <span class="Constant">1</span>  <span class="Constant">2</span> <span class="Constant">3</span>  <span class="Constant">3</span> <span class="Constant">4</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - calling a user-defined function runs its instructions&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;new-fn-once&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function test1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span>test1<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;run&quot;)))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">2</span> <span class="Global">curr-cycle*</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - calling a user-defined function runs its instructions exactly once &quot;</span> <span class="Global">curr-cycle*</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Comment">; User-defined functions communicate with their callers through two</span>
<span class="Comment">; primitives:</span>
<span class="Comment">;</span>
<span class="Comment">;   'arg' - to access inputs</span>
<span class="Comment">;   'reply' - to return outputs</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;new-fn-reply&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function test1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> add <span class="Constant">1</span>:integer <span class="Constant">2</span>:integer<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span>test1<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">1</span> <span class="Constant">1</span>  <span class="Constant">2</span> <span class="Constant">3</span>  <span class="Constant">3</span> <span class="Constant">4</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'reply' stops executing the current function&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;new-fn-reply-nested&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function test1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> test2<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function test2 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span> <span class="Constant">2</span>:integer<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span>test1<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">2</span> <span class="Constant">34</span>  <span class="Constant">3</span> <span class="Constant">34</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'reply' stops executing any callers as necessary&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;new-fn-reply-once&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function test1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> add <span class="Constant">1</span>:integer <span class="Constant">2</span>:integer<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span>test1<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;run&quot;)))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">5</span> <span class="Global">curr-cycle*</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'reply' executes instructions exactly once &quot;</span> <span class="Global">curr-cycle*</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;reply-increments-caller-pc&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function callee <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span><span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function caller <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>freeze <span class="Global">function*</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">routine*</span> <span class="Delimiter">(</span>make-routine <span class="Delimiter">'</span>caller<span class="Delimiter">))</span>
<span class="Delimiter">(</span>assert <span class="Delimiter">(</span>is <span class="Constant">0</span> pc.routine*<span class="Delimiter">))</span>
<span class="Delimiter">(</span>push-stack <span class="Global">routine*</span> <span class="Delimiter">'</span>callee<span class="Delimiter">)</span>  <span class="Comment">; pretend call was at first instruction of caller</span>
<span class="Delimiter">(</span>run-for-time-slice <span class="Constant">1</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">1</span> pc.routine*<span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'reply' should increment pc in caller (to move past calling instruction)&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;new-fn-arg-sequential&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function test1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:integer <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> add <span class="Constant">4</span>:integer <span class="Constant">5</span>:integer<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span>test1 <span class="Constant">1</span>:integer <span class="Constant">2</span>:integer<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">1</span> <span class="Constant">1</span>  <span class="Constant">2</span> <span class="Constant">3</span>  <span class="Constant">3</span> <span class="Constant">4</span>
                       <span class="Comment">; test1's temporaries</span>
                       <span class="Constant">4</span> <span class="Constant">1</span>  <span class="Constant">5</span> <span class="Constant">3</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'arg' accesses in order the operands of the most recent function call (the caller)&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;new-fn-arg-random-access&quot;</span><span class="Delimiter">)</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function test1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:integer <span class="Op">&lt;-</span> <span class="Identifier">input</span> <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> <span class="Identifier">input</span> <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> add <span class="Constant">4</span>:integer <span class="Constant">5</span>:integer<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span>  <span class="Comment">; should never run</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span>test1 <span class="Constant">1</span>:integer <span class="Constant">2</span>:integer<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">1</span> <span class="Constant">1</span>  <span class="Constant">2</span> <span class="Constant">3</span>  <span class="Constant">3</span> <span class="Constant">4</span>
                       <span class="Comment">; test's temporaries</span>
                       <span class="Constant">4</span> <span class="Constant">1</span>  <span class="Constant">5</span> <span class="Constant">3</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'arg' with index can access function call arguments out of order&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;new-fn-arg-random-then-sequential&quot;</span><span class="Delimiter">)</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function test1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span>_ <span class="Op">&lt;-</span> <span class="Identifier">input</span> <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span>  <span class="Comment">; takes next arg after index 1</span></span>
     <span class="Delimiter">])</span>  <span class="Comment">; should never run</span>
    <span class="Mu"><span class="Delimiter">(</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span>test1 <span class="MuConstant">1</span>:literal <span class="MuConstant">2</span>:literal <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">1</span> <span class="Constant">3</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'arg' with index resets index for later calls&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;new-fn-arg-status&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function test1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Constant">5</span>:boolean <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span>test1 <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">4</span> <span class="Constant">1</span>  <span class="Constant">5</span> t<span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'arg' sets a second oarg when arg exists&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;new-fn-arg-missing&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function test1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:integer <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span>test1 <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">4</span> <span class="Constant">1</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - missing 'arg' doesn't cause error&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;new-fn-arg-missing-2&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function test1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:integer <span class="Constant">6</span>:boolean <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span>test1 <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">4</span> <span class="Constant">1</span>  <span class="Constant">6</span> nil<span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - missing 'arg' wipes second oarg when provided&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;new-fn-arg-missing-3&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function test1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:integer <span class="Constant">6</span>:boolean <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
    <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span>test1 <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
    <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">4</span> <span class="Constant">1</span>  <span class="Constant">6</span> nil<span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - missing 'arg' consistently wipes its oarg&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;new-fn-arg-missing-4&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function test1 <span class="Delimiter">[</span></span>
      <span class="Comment">; if given two args, adds them; if given one arg, increments</span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:integer <span class="Constant">6</span>:boolean <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
      { <span class="CommentedCode">begin</span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">break-if</span> <span class="Constant">6</span>:boolean<span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
      }
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">7</span>:integer <span class="Op">&lt;-</span> add <span class="Constant">4</span>:integer <span class="Constant">5</span>:integer<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span>test1 <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">4</span> <span class="Constant">34</span>  <span class="Constant">5</span> <span class="Constant">1</span>  <span class="Constant">6</span> nil  <span class="Constant">7</span> <span class="Constant">35</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - function with optional second arg&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;new-fn-arg-by-value&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function test1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span>  <span class="Comment">; overwrite caller memory</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>  <span class="Comment">; arg not clobbered</span>
    <span class="Mu"><span class="Delimiter">(</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span>test1 <span class="Constant">1</span>:integer<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">1</span> <span class="Constant">0</span>  <span class="Constant">2</span> <span class="Constant">34</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'arg' passes by value&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;arg-record&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function test1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer-boolean-pair <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:boolean <span class="Op">&lt;-</span> copy <span class="MuConstant">nil</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span>test1 <span class="Constant">1</span>:integer-boolean-pair<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">1</span> <span class="Constant">34</span>  <span class="Constant">2</span> nil  <span class="Constant">4</span> <span class="Constant">34</span>  <span class="Constant">5</span> nil<span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'arg' can copy records spanning multiple locations&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;arg-record-indirect&quot;</span><span class="Delimiter">)</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function test1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer-boolean-pair <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:boolean <span class="Op">&lt;-</span> copy <span class="MuConstant">nil</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer-boolean-pair-address <span class="Op">&lt;-</span> copy <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span>test1 <span class="Constant">3</span>:integer-boolean-pair-address/deref<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">1</span> <span class="Constant">34</span>  <span class="Constant">2</span> nil  <span class="Constant">3</span> <span class="Constant">1</span>  <span class="Constant">4</span> <span class="Constant">34</span>  <span class="Constant">5</span> nil<span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'arg' can copy records spanning multiple locations in indirect mode&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;new-fn-reply-oarg&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function test1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:integer <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">6</span>:integer <span class="Op">&lt;-</span> add <span class="Constant">4</span>:integer <span class="Constant">5</span>:integer<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span> <span class="Constant">6</span>:integer<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> test1 <span class="Constant">1</span>:integer <span class="Constant">2</span>:integer<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">1</span> <span class="Constant">1</span>  <span class="Constant">2</span> <span class="Constant">3</span>  <span class="Constant">3</span> <span class="Constant">4</span>
                       <span class="Comment">; test1's temporaries</span>
                       <span class="Constant">4</span> <span class="Constant">1</span>  <span class="Constant">5</span> <span class="Constant">3</span>  <span class="Constant">6</span> <span class="Constant">4</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'reply' can take aguments that are returned, or written back into output args of caller&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;new-fn-reply-oarg-multiple&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function test1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:integer <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">6</span>:integer <span class="Op">&lt;-</span> add <span class="Constant">4</span>:integer <span class="Constant">5</span>:integer<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span> <span class="Constant">6</span>:integer <span class="Constant">5</span>:integer<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Constant">7</span>:integer <span class="Op">&lt;-</span> test1 <span class="Constant">1</span>:integer <span class="Constant">2</span>:integer<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">1</span> <span class="Constant">1</span>  <span class="Constant">2</span> <span class="Constant">3</span>  <span class="Constant">3</span> <span class="Constant">4</span>    <span class="Constant">7</span> <span class="Constant">3</span>
                         <span class="Comment">; test1's temporaries</span>
                         <span class="Constant">4</span> <span class="Constant">1</span>  <span class="Constant">5</span> <span class="Constant">3</span>  <span class="Constant">6</span> <span class="Constant">4</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'reply' permits a function to return multiple values at once&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;new-fn-prepare-reply&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function test1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:integer <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">6</span>:integer <span class="Op">&lt;-</span> add <span class="Constant">4</span>:integer <span class="Constant">5</span>:integer<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span>prepare-reply <span class="Constant">6</span>:integer <span class="Constant">5</span>:integer<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Constant">7</span>:integer <span class="Op">&lt;-</span> test1 <span class="Constant">1</span>:integer <span class="Constant">2</span>:integer<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">1</span> <span class="Constant">1</span>  <span class="Constant">2</span> <span class="Constant">3</span>  <span class="Constant">3</span> <span class="Constant">4</span>    <span class="Constant">7</span> <span class="Constant">3</span>
                         <span class="Comment">; test1's temporaries</span>
                         <span class="Constant">4</span> <span class="Constant">1</span>  <span class="Constant">5</span> <span class="Constant">3</span>  <span class="Constant">6</span> <span class="Constant">4</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - without args, 'reply' returns values from previous 'prepare-reply'.&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">)</span>  <span class="Comment">; section 20</span>

<span class="Delimiter">(</span>section <span class="Constant">11</span>

<span class="SalientComment">;; Structured programming</span>
<span class="Comment">;</span>
<span class="Comment">; Our jump operators are quite inconvenient to use, so mu provides a</span>
<span class="Comment">; lightweight tool called 'convert-braces' to work in a slightly more</span>
<span class="Comment">; convenient format with nested braces:</span>
<span class="Comment">;</span>
<span class="Comment">;   {</span>
<span class="Comment">;     some instructions</span>
<span class="Comment">;     {</span>
<span class="Comment">;       more instructions</span>
<span class="Comment">;     }</span>
<span class="Comment">;   }</span>
<span class="Comment">;</span>
<span class="Comment">; Braces are like labels in assembly language, they require no special</span>
<span class="Comment">; parsing. The operations 'loop' and 'break' jump to just after the enclosing</span>
<span class="Comment">; '{' and '}' respectively.</span>
<span class="Comment">;</span>
<span class="Comment">; Conditional and unconditional 'loop' and 'break' should give us 80% of the</span>
<span class="Comment">; benefits of the control-flow primitives we're used to in other languages,</span>
<span class="Comment">; like 'if', 'while', 'for', etc.</span>
<span class="Comment">;</span>
<span class="Comment">; Compare 'unquoted blocks' using {} with 'quoted blocks' using [] that we've</span>
<span class="Comment">; gotten used to seeing. Quoted blocks are used by top-level instructions to</span>
<span class="Comment">; provide code without running it.</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;convert-braces&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;c{0&quot; &quot;c{1&quot;)))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>convert-braces
            <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">2</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">3</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              { <span class="CommentedCode">begin</span>  <span class="Comment">; 'begin' is just a hack because racket turns braces into parens</span>
                <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">4</span> boolean<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>not-equal<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="Constant">3</span> integer<span class="Delimiter">)))</span></span>
                <span class="Mu"><span class="Delimiter">(((</span><span class="Identifier">break-if</span><span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="Constant">4</span> boolean<span class="Delimiter">)))</span></span>
                <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">5</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              }
              <span class="Mu"><span class="Delimiter">(((</span><span class="Identifier">reply</span><span class="Delimiter">)))))</span></span>
          <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">2</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">3</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">4</span> boolean<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>not-equal<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="Constant">3</span> integer<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Identifier">jump-if</span><span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="Constant">4</span> boolean<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">1</span> offset<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">5</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Identifier">reply</span><span class="Delimiter">)))))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - convert-braces replaces break-if with a jump-if to after the next close-brace&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;convert-braces-empty-block&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;c{0&quot; &quot;c{1&quot;)))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>convert-braces
            <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">2</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">3</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              { <span class="CommentedCode">begin</span>
                <span class="Mu"><span class="Delimiter">(((</span><span class="Identifier">break</span><span class="Delimiter">)))</span></span>
              }
              <span class="Mu"><span class="Delimiter">(((</span><span class="Identifier">reply</span><span class="Delimiter">)))))</span></span>
          <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">2</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">3</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Identifier">jump</span><span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> offset<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Identifier">reply</span><span class="Delimiter">)))))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - convert-braces works for degenerate blocks&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;convert-braces-nested-break&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>convert-braces
            <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">2</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">3</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              { <span class="CommentedCode">begin</span>
                <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">4</span> boolean<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>not-equal<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="Constant">3</span> integer<span class="Delimiter">)))</span></span>
                <span class="Mu"><span class="Delimiter">(((</span><span class="Identifier">break-if</span><span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="Constant">4</span> boolean<span class="Delimiter">)))</span></span>
                { <span class="CommentedCode">begin</span>
                  <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">5</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
                }
              }
              <span class="Mu"><span class="Delimiter">(((</span><span class="Identifier">reply</span><span class="Delimiter">)))))</span></span>
          <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">2</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">3</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">4</span> boolean<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>not-equal<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="Constant">3</span> integer<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Identifier">jump-if</span><span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="Constant">4</span> boolean<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">1</span> offset<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">5</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Identifier">reply</span><span class="Delimiter">)))))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - convert-braces balances braces when converting break&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;convert-braces-repeated-jump&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;c{0&quot; &quot;c{1&quot;)))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>convert-braces
            <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              { <span class="CommentedCode">begin</span>
                <span class="Mu"><span class="Delimiter">(((</span><span class="Identifier">break</span><span class="Delimiter">)))</span></span>
                <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">2</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              }
              { <span class="CommentedCode">begin</span>
                <span class="Mu"><span class="Delimiter">(((</span><span class="Identifier">break</span><span class="Delimiter">)))</span></span>
                <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">3</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              }
              <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">4</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))))</span></span>
          <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Identifier">jump</span><span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">1</span> offset<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">2</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Identifier">jump</span><span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">1</span> offset<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">3</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">4</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - convert-braces handles jumps on jumps&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;convert-braces-nested-loop&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>convert-braces
            <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">2</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              { <span class="CommentedCode">begin</span>
                <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">3</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
                { <span class="CommentedCode">begin</span>
                  <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">4</span> boolean<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>not-equal<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="Constant">3</span> integer<span class="Delimiter">)))</span></span>
                }
                <span class="Mu"><span class="Delimiter">(((</span><span class="Identifier">loop-if</span><span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="Constant">4</span> boolean<span class="Delimiter">)))</span></span>
                <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">5</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              }
              <span class="Mu"><span class="Delimiter">(((</span><span class="Identifier">reply</span><span class="Delimiter">)))))</span></span>
          <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">2</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">3</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">4</span> boolean<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>not-equal<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="Constant">3</span> integer<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Identifier">jump-if</span><span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="Constant">4</span> boolean<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">-3</span> offset<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">5</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Identifier">reply</span><span class="Delimiter">)))))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - convert-braces balances braces when converting 'loop'&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;convert-braces-label&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>convert-braces
            <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              foo
              <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">2</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))))</span></span>
          <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            foo
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">2</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - convert-braces skips past labels&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;convert-braces-label-increments-offset&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>convert-braces
            <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              { <span class="CommentedCode">begin</span>
                <span class="Mu"><span class="Delimiter">(((</span><span class="Identifier">break</span><span class="Delimiter">)))</span></span>
                foo
              }
              <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">2</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))))</span></span>
          <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Delimiter">(((</span><span class="Identifier">jump</span><span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">1</span> offset<span class="Delimiter">)))</span>
            foo
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">2</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - convert-braces treats labels as instructions&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;convert-braces-label-increments-offset2&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;c{0&quot; &quot;c{1&quot;)))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>convert-braces
            <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              { <span class="CommentedCode">begin</span>
                <span class="Mu"><span class="Delimiter">(((</span><span class="Identifier">break</span><span class="Delimiter">)))</span></span>
                foo
              }
              <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">2</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              { <span class="CommentedCode">begin</span>
                <span class="Mu"><span class="Delimiter">(((</span><span class="Identifier">break</span><span class="Delimiter">)))</span></span>
                <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">3</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              }
              <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">4</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))))</span></span>
          <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Identifier">jump</span><span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">1</span> offset<span class="Delimiter">)))</span></span>
            foo
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">2</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Identifier">jump</span><span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">1</span> offset<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">3</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">4</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - convert-braces treats labels as instructions - 2&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;break-multiple&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;-&quot;)))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>convert-braces
            <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              { <span class="CommentedCode">begin</span>
                { <span class="CommentedCode">begin</span>
                  <span class="Mu"><span class="Delimiter">(((</span><span class="Identifier">break</span><span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="Constant">2</span> blocks<span class="Delimiter">)))</span></span>
                }
                <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">2</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
                <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">3</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
                <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">4</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
                <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">5</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              }<span class="Delimiter">))</span>
          <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Identifier">jump</span><span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">4</span> offset<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">2</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">3</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">4</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">5</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'break' can take an extra arg with number of nested blocks to exit&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;loop&quot;</span><span class="Delimiter">)</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>convert-braces
            <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">2</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              { <span class="CommentedCode">begin</span>
                <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">3</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
                <span class="Mu"><span class="Delimiter">(((</span><span class="Identifier">loop</span><span class="Delimiter">)))</span></span>
              }<span class="Delimiter">))</span>
          <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">2</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">3</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Identifier">jump</span><span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">-2</span> offset<span class="Delimiter">)))))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'loop' jumps to start of containing block&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Comment">; todo: fuzz-test invariant: convert-braces offsets should be robust to any</span>
<span class="Comment">; number of inner blocks inside but not around the loop block.</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;loop-nested&quot;</span><span class="Delimiter">)</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>convert-braces
            <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">2</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              { <span class="CommentedCode">begin</span>
                <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">3</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
                { <span class="CommentedCode">begin</span>
                  <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">4</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
                }
                <span class="Mu"><span class="Delimiter">(((</span><span class="Identifier">loop</span><span class="Delimiter">)))</span></span>
              }<span class="Delimiter">))</span>
          <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">2</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">3</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">4</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Identifier">jump</span><span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">-3</span> offset<span class="Delimiter">)))))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'loop' correctly jumps back past nested braces&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;loop-multiple&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;-&quot;)))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>convert-braces
            <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              { <span class="CommentedCode">begin</span>
                <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">2</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
                <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">3</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
                { <span class="CommentedCode">begin</span>
                  <span class="Mu"><span class="Delimiter">(((</span><span class="Identifier">loop</span><span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="Constant">2</span> blocks<span class="Delimiter">)))</span></span>
                }
              }<span class="Delimiter">))</span>
          <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">2</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">3</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Identifier">jump</span><span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">-3</span> offset<span class="Delimiter">)))))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'loop' can take an extra arg with number of nested blocks to exit&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;convert-labels&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>convert-labels
            <span class="Mu"><span class="Delimiter">'(</span><span class="Identifier">loop</span></span>
              <span class="Mu"><span class="Delimiter">(((</span><span class="Identifier">jump</span><span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="Identifier">loop</span> offset<span class="Delimiter">)))))</span></span>
          <span class="Mu"><span class="Delimiter">'(</span><span class="Identifier">loop</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Identifier">jump</span><span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">-2</span> offset<span class="Delimiter">)))))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'convert-labels' rewrites jumps to labels&quot;</span><span class="Delimiter">))</span>

<span class="SalientComment">;; Variables</span>
<span class="Comment">;</span>
<span class="Comment">; A big convenience high-level languages provide is the ability to name memory</span>
<span class="Comment">; locations. In mu, a lightweight tool called 'convert-names' provides this</span>
<span class="Comment">; convenience.</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;convert-names&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>convert-names
            <span class="Mu"><span class="Delimiter">'((((</span>x integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              <span class="Mu"><span class="Delimiter">(((</span>y integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              <span class="Mu"><span class="Delimiter">(((</span>z integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))))</span></span>
          <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">2</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">3</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - convert-names renames symbolic names to integer locations&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;convert-names-compound&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>convert-names
            <span class="Comment">; copying 0 into pair is meaningless; just for testing</span>
            <span class="Mu"><span class="Delimiter">'((((</span>x integer-boolean-pair<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              <span class="Mu"><span class="Delimiter">(((</span>y integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))))</span></span>
          <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> integer-boolean-pair<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">3</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - convert-names increments integer locations by the size of the type of the previous var&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;convert-names-nil&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>convert-names
            <span class="Mu"><span class="Delimiter">'((((</span>x integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              <span class="Mu"><span class="Delimiter">(((</span>y integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              <span class="Comment">; nil location is meaningless; just for testing</span>
              <span class="Mu"><span class="Delimiter">(((</span>nil integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))))</span></span>
          <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">2</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span>nil integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - convert-names never renames nil&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;convert-names-string&quot;</span><span class="Delimiter">)</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>convert-names
            <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> integer-address<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>new<span class="Delimiter">))</span> <span class="Constant">&quot;foo&quot;</span><span class="Delimiter">)))</span></span>
          <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> integer-address<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>new<span class="Delimiter">))</span> <span class="Constant">&quot;foo&quot;</span><span class="Delimiter">)))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;convert-names passes through raw strings (just a convenience arg for 'new')&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;convert-names-raw&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>convert-names
            <span class="Mu"><span class="Delimiter">'((((</span>x integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              <span class="Mu"><span class="Delimiter">(((</span>y integer<span class="Delimiter">)</span> <span class="Delimiter">(</span>raw<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))))</span></span>
          <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span>y integer<span class="Delimiter">)</span> <span class="Delimiter">(</span>raw<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - convert-names never renames raw operands&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;convert-names-literal&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>convert-names
            <span class="Comment">; meaningless; just for testing</span>
            <span class="Mu"><span class="Delimiter">'((((</span>x literal<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))))</span></span>
          <span class="Mu"><span class="Delimiter">'((((</span>x literal<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - convert-names never renames literals&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;convert-names-literal-2&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>convert-names
            <span class="Mu"><span class="Delimiter">'((((</span>x boolean<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span>x literal<span class="Delimiter">)))))</span></span>
          <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> boolean<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span>x literal<span class="Delimiter">)))))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - convert-names never renames literals, even when the name matches a variable&quot;</span><span class="Delimiter">))</span>

<span class="Comment">; kludgy support for 'fork' below</span>
<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;convert-names-functions&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>convert-names
            <span class="Mu"><span class="Delimiter">'((((</span>x integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              <span class="Mu"><span class="Delimiter">(((</span>y integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              <span class="Comment">; meaningless; just for testing</span>
              <span class="Mu"><span class="Delimiter">(((</span>z fn<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))))</span></span>
          <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">2</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span>z fn<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - convert-names never renames fns&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;convert-names-record-fields&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;cn0&quot;)))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>convert-names
            <span class="Mu"><span class="Delimiter">'((((</span>x integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>get<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="Constant">34</span> integer-boolean-pair<span class="Delimiter">))</span> <span class="Delimiter">((</span>bool offset<span class="Delimiter">)))))</span></span>
          <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>get<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="Constant">34</span> integer-boolean-pair<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">1</span> offset<span class="Delimiter">)))))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - convert-names replaces record field offsets&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;convert-names-record-fields-ambiguous&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>errsafe <span class="Delimiter">(</span>convert-names
               <span class="Mu"><span class="Delimiter">'((((</span>bool boolean<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">t</span> literal<span class="Delimiter">)))</span></span>
                 <span class="Mu"><span class="Delimiter">(((</span>x integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>get<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="Constant">34</span> integer-boolean-pair<span class="Delimiter">))</span> <span class="Delimiter">((</span>bool offset<span class="Delimiter">))))))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - convert-names doesn't allow offsets and variables with the same name in a function&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;convert-names-record-fields-ambiguous-2&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>errsafe <span class="Delimiter">(</span>convert-names
               <span class="Mu"><span class="Delimiter">'((((</span>x integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>get<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="Constant">34</span> integer-boolean-pair<span class="Delimiter">))</span> <span class="Delimiter">((</span>bool offset<span class="Delimiter">)))</span></span>
                 <span class="Mu"><span class="Delimiter">(((</span>bool boolean<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">t</span> literal<span class="Delimiter">))))))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - convert-names doesn't allow offsets and variables with the same name in a function - 2&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;convert-names-record-fields-indirect&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;cn0&quot;)))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>convert-names
            <span class="Mu"><span class="Delimiter">'((((</span>x integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>get<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="Constant">34</span> integer-boolean-pair-address<span class="Delimiter">)</span> <span class="Delimiter">(</span>deref<span class="Delimiter">))</span> <span class="Delimiter">((</span>bool offset<span class="Delimiter">)))))</span></span>
          <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>get<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="Constant">34</span> integer-boolean-pair-address<span class="Delimiter">)</span> <span class="Delimiter">(</span>deref<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">1</span> offset<span class="Delimiter">)))))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - convert-names replaces field offsets for record addresses&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;convert-names-record-fields-multiple&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>convert-names
            <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">2</span> boolean<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>get<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="Constant">1</span> integer-boolean-pair<span class="Delimiter">))</span> <span class="Delimiter">((</span>bool offset<span class="Delimiter">)))</span></span>
              <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">3</span> boolean<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>get<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="Constant">1</span> integer-boolean-pair<span class="Delimiter">))</span> <span class="Delimiter">((</span>bool offset<span class="Delimiter">)))))</span></span>
          <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">2</span> boolean<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>get<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="Constant">1</span> integer-boolean-pair<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">1</span> offset<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">3</span> boolean<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>get<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="Constant">1</span> integer-boolean-pair<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">1</span> offset<span class="Delimiter">)))))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - convert-names replaces field offsets with multiple mentions&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;convert-names-label&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>convert-names
            <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
              foo<span class="Delimiter">))</span>
          <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            foo<span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - convert-names skips past labels&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">)</span>  <span class="Comment">; section 11</span>

<span class="Delimiter">(</span>section <span class="Constant">20</span>

<span class="Comment">; A rudimentary memory allocator. Eventually we want to write this in mu.</span>
<span class="Comment">;</span>
<span class="Comment">; No deallocation yet; let's see how much code we can build in mu before we</span>
<span class="Comment">; feel the need for it.</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;new-primitive&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer-address <span class="Op">&lt;-</span> new integer:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span><span class="Normal">let</span> routine make-routine!main
  <span class="Delimiter">(</span>enq routine <span class="Global">running-routines*</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span><span class="Normal">let</span> before rep.routine!alloc
<span class="CommentedCode">;?     (set dump-trace*)</span>
    <span class="Delimiter">(</span>run<span class="Delimiter">)</span>
<span class="CommentedCode">;?     (prn memory*)</span>
    <span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span><span class="Constant">.1</span> before<span class="Delimiter">)</span>
      <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'new' returns current high-water mark&quot;</span><span class="Delimiter">))</span>
    <span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso rep.routine!alloc <span class="Delimiter">(</span>+ before <span class="Constant">1</span><span class="Delimiter">))</span>
      <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'new' on primitive types increments high-water mark by their size&quot;</span><span class="Delimiter">))))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;new-array-literal&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:type-array-address <span class="Op">&lt;-</span> new type-array:literal <span class="MuConstant">5</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span><span class="Normal">let</span> routine make-routine!main
  <span class="Delimiter">(</span>enq routine <span class="Global">running-routines*</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span><span class="Normal">let</span> before rep.routine!alloc
    <span class="Delimiter">(</span>run<span class="Delimiter">)</span>
<span class="CommentedCode">;?     (prn memory*)</span>
    <span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span><span class="Constant">.1</span> before<span class="Delimiter">)</span>
      <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'new' on array with literal size returns current high-water mark&quot;</span><span class="Delimiter">))</span>
    <span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso rep.routine!alloc <span class="Delimiter">(</span>+ before <span class="Constant">6</span><span class="Delimiter">))</span>
      <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'new' on primitive arrays increments high-water mark by their size&quot;</span><span class="Delimiter">))))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;new-array-direct&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">5</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:type-array-address <span class="Op">&lt;-</span> new type-array:literal <span class="Constant">1</span>:integer<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span><span class="Normal">let</span> routine make-routine!main
  <span class="Delimiter">(</span>enq routine <span class="Global">running-routines*</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span><span class="Normal">let</span> before rep.routine!alloc
    <span class="Delimiter">(</span>run<span class="Delimiter">)</span>
<span class="CommentedCode">;?     (prn memory*)</span>
    <span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span><span class="Constant">.2</span> before<span class="Delimiter">)</span>
      <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'new' on array with variable size returns current high-water mark&quot;</span><span class="Delimiter">))</span>
    <span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso rep.routine!alloc <span class="Delimiter">(</span>+ before <span class="Constant">6</span><span class="Delimiter">))</span>
      <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'new' on primitive arrays increments high-water mark by their (variable) size&quot;</span><span class="Delimiter">))))</span>

<span class="Comment">; Even though our memory locations can now have names, the names are all</span>
<span class="Comment">; globals, accessible from any function. To isolate functions from their</span>
<span class="Comment">; callers we need local variables, and mu provides them using a special</span>
<span class="Comment">; variable called default-space. When you initialize such a variable (likely</span>
<span class="Comment">; with a call to our just-defined memory allocator) mu interprets memory</span>
<span class="Comment">; locations as offsets from its value. If default-space is set to 1000, for</span>
<span class="Comment">; example, reads and writes to memory location 1 will really go to 1001.</span>
<span class="Comment">;</span>
<span class="Comment">; 'default-space' is itself hard-coded to be function-local; it's nil in a new</span>
<span class="Comment">; function, and it's restored when functions return to their callers. But the</span>
<span class="Comment">; actual space allocation is independent. So you can define closures, or do</span>
<span class="Comment">; even more funky things like share locals between two coroutines.</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;set-default-space&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span>default-space:space-address <span class="Op">&lt;-</span> new space:literal <span class="MuConstant">2</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">23</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span><span class="Normal">let</span> routine make-routine!main
  <span class="Delimiter">(</span>enq routine <span class="Global">running-routines*</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span><span class="Normal">let</span> before rep.routine!alloc
<span class="CommentedCode">;?     (set dump-trace*)</span>
    <span class="Delimiter">(</span>run<span class="Delimiter">)</span>
<span class="CommentedCode">;?     (prn memory*)</span>
    <span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~and <span class="Delimiter">(</span>~is <span class="Constant">23</span> <span class="Global">memory*</span><span class="Constant">.1</span><span class="Delimiter">)</span>
              <span class="Delimiter">(</span>is <span class="Constant">23</span> <span class="Delimiter">(</span><span class="Global">memory*</span> <span class="Delimiter">(</span>+ before <span class="Constant">2</span><span class="Delimiter">))))</span>
      <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - default-space implicitly modifies variable locations&quot;</span><span class="Delimiter">))))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;set-default-space-skips-offset&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span>default-space:space-address <span class="Op">&lt;-</span> new space:literal <span class="MuConstant">2</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">23</span>:offset<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span><span class="Normal">let</span> routine make-routine!main
  <span class="Delimiter">(</span>enq routine <span class="Global">running-routines*</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span><span class="Normal">let</span> before rep.routine!alloc
<span class="CommentedCode">;?     (set dump-trace*)</span>
    <span class="Delimiter">(</span>run<span class="Delimiter">)</span>
<span class="CommentedCode">;?     (prn memory*)</span>
    <span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~and <span class="Delimiter">(</span>~is <span class="Constant">23</span> <span class="Global">memory*</span><span class="Constant">.1</span><span class="Delimiter">)</span>
              <span class="Delimiter">(</span>is <span class="Constant">23</span> <span class="Delimiter">(</span><span class="Global">memory*</span> <span class="Delimiter">(</span>+ before <span class="Constant">2</span><span class="Delimiter">))))</span>
      <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - default-space skips 'offset' types just like literals&quot;</span><span class="Delimiter">))))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;default-space-bounds-check&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span>default-space:space-address <span class="Op">&lt;-</span> new space:literal <span class="MuConstant">2</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">23</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">let</span> routine <span class="Delimiter">(</span>car <span class="Global">completed-routines*</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>no rep.routine!error<span class="Delimiter">)</span>
    <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - default-space checks bounds&quot;</span><span class="Delimiter">)))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;default-space-and-get-indirect&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span>default-space:space-address <span class="Op">&lt;-</span> new space:literal <span class="MuConstant">5</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer-boolean-pair-address <span class="Op">&lt;-</span> new integer-boolean-pair:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer-address <span class="Op">&lt;-</span> get-address <span class="Constant">1</span>:integer-boolean-pair-address/deref <span class="MuConstant">0</span>:offset<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer-address/deref <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer/raw <span class="Op">&lt;-</span> get <span class="Constant">1</span>:integer-boolean-pair-address/deref <span class="MuConstant">0</span>:offset<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (= dump-trace* (obj blacklist '(&quot;sz&quot; &quot;m&quot; &quot;setm&quot; &quot;addr&quot; &quot;cvt0&quot; &quot;cvt1&quot;)))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="CommentedCode">;? (prn completed-routines*)</span>
<span class="Delimiter">(</span>each routine <span class="Global">completed-routines*</span>
  <span class="Delimiter">(</span>aif rep.routine!error <span class="Delimiter">(</span>prn <span class="Constant">&quot;error - &quot;</span> it<span class="Delimiter">)))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">34</span> <span class="Global">memory*</span><span class="Constant">.3</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - indirect 'get' works in the presence of default-space&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;default-space-and-index-indirect&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span>default-space:space-address <span class="Op">&lt;-</span> new space:literal <span class="MuConstant">5</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer-array-address <span class="Op">&lt;-</span> new integer-array:literal <span class="MuConstant">4</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer-address <span class="Op">&lt;-</span> index-address <span class="Constant">1</span>:integer-array-address/deref <span class="MuConstant">2</span>:offset<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer-address/deref <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer/raw <span class="Op">&lt;-</span> index <span class="Constant">1</span>:integer-array-address/deref <span class="MuConstant">2</span>:offset<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;run&quot; &quot;array-info&quot;)))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="CommentedCode">;? (prn completed-routines*)</span>
<span class="Delimiter">(</span>each routine <span class="Global">completed-routines*</span>
  <span class="Delimiter">(</span>aif rep.routine!error <span class="Delimiter">(</span>prn <span class="Constant">&quot;error - &quot;</span> it<span class="Delimiter">)))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">34</span> <span class="Global">memory*</span><span class="Constant">.3</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - indirect 'index' works in the presence of default-space&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;convert-names-default-space&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>convert-names
            <span class="Mu"><span class="Delimiter">'((((</span>x integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">4</span> literal<span class="Delimiter">)))</span></span>
              <span class="Mu"><span class="Delimiter">(((</span>y integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">2</span> literal<span class="Delimiter">)))</span></span>
              <span class="Comment">; unsafe in general; don't write random values to 'default-space'</span>
              <span class="Mu"><span class="Delimiter">(((</span>default-space integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>add<span class="Delimiter">))</span> <span class="Delimiter">((</span>x integer<span class="Delimiter">))</span> <span class="Delimiter">((</span>y integer<span class="Delimiter">)))))</span></span>
          <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">4</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">2</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">2</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span>default-space integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>add<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="Constant">2</span> integer<span class="Delimiter">)))))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - convert-names never renames default-space&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;suppress-default-space&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span>default-space:space-address <span class="Op">&lt;-</span> new space:literal <span class="MuConstant">2</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer/raw <span class="Op">&lt;-</span> copy <span class="MuConstant">23</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span><span class="Normal">let</span> routine make-routine!main
  <span class="Delimiter">(</span>enq routine <span class="Global">running-routines*</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span><span class="Normal">let</span> before rep.routine!alloc
<span class="CommentedCode">;?     (set dump-trace*)</span>
    <span class="Delimiter">(</span>run<span class="Delimiter">)</span>
<span class="CommentedCode">;?     (prn memory*)</span>
    <span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~and <span class="Delimiter">(</span>is <span class="Constant">23</span> <span class="Global">memory*</span><span class="Constant">.1</span><span class="Delimiter">)</span>
              <span class="Delimiter">(</span>~is <span class="Constant">23</span> <span class="Delimiter">(</span><span class="Global">memory*</span> <span class="Delimiter">(</span>+ before <span class="Constant">1</span><span class="Delimiter">))))</span>
      <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - default-space skipped for locations with metadata 'raw'&quot;</span><span class="Delimiter">))))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;array-copy-indirect-scoped&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">10</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">30</span>:literal<span class="Delimiter">)</span>  <span class="Comment">; pretend allocation</span></span>
      <span class="Mu"><span class="Delimiter">(</span>default-space:space-address <span class="Op">&lt;-</span> copy <span class="MuConstant">10</span>:literal<span class="Delimiter">)</span>  <span class="Comment">; unsafe</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">2</span>:literal<span class="Delimiter">)</span>  <span class="Comment">; raw location 12</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">23</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:boolean <span class="Op">&lt;-</span> copy <span class="MuConstant">nil</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">24</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:boolean <span class="Op">&lt;-</span> copy <span class="MuConstant">t</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">6</span>:integer-boolean-pair-array-address <span class="Op">&lt;-</span> copy <span class="MuConstant">12</span>:literal<span class="Delimiter">)</span>  <span class="Comment">; unsafe</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">7</span>:integer-boolean-pair-array <span class="Op">&lt;-</span> copy <span class="Constant">6</span>:integer-boolean-pair-array-address/deref<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;run&quot; &quot;m&quot; &quot;sizeof&quot;)))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span>each routine <span class="Global">completed-routines*</span>
  <span class="Delimiter">(</span>aif rep.routine!error <span class="Delimiter">(</span>prn <span class="Constant">&quot;error - &quot;</span> it<span class="Delimiter">)))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span><span class="Constant">.18</span> <span class="Constant">2</span><span class="Delimiter">)</span>  <span class="Comment">; variable 7</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - indirect array copy in the presence of 'default-space'&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;len-array-indirect-scoped&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">10</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">30</span>:literal<span class="Delimiter">)</span>  <span class="Comment">; pretend allocation</span></span>
      <span class="Mu"><span class="Delimiter">(</span>default-space:space-address <span class="Op">&lt;-</span> copy <span class="MuConstant">10</span>:literal<span class="Delimiter">)</span>  <span class="Comment">; unsafe</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">2</span>:literal<span class="Delimiter">)</span>  <span class="Comment">; raw location 12</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">23</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:boolean <span class="Op">&lt;-</span> copy <span class="MuConstant">nil</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">24</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:boolean <span class="Op">&lt;-</span> copy <span class="MuConstant">t</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">6</span>:integer-address <span class="Op">&lt;-</span> copy <span class="MuConstant">12</span>:literal<span class="Delimiter">)</span>  <span class="Comment">; unsafe</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">7</span>:integer <span class="Op">&lt;-</span> length <span class="Constant">6</span>:integer-boolean-pair-array-address/deref<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;run&quot; &quot;addr&quot; &quot;sz&quot; &quot;array-len&quot;)))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span><span class="Constant">.18</span> <span class="Constant">2</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'len' accesses length of array address&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;default-space-shared&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function init-counter <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span>default-space:space-address <span class="Op">&lt;-</span> new space:literal <span class="MuConstant">30</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span>  <span class="Comment">; initialize to 3</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span> default-space:space-address<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function increment-counter <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span>default-space:space-address <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> add <span class="Constant">1</span>:integer <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span>  <span class="Comment">; increment</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span> <span class="Constant">1</span>:integer<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:space-address <span class="Op">&lt;-</span> init-counter<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> increment-counter <span class="Constant">1</span>:space-address<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> increment-counter <span class="Constant">1</span>:space-address<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="Delimiter">(</span>each routine <span class="Global">completed-routines*</span>
  <span class="Delimiter">(</span>aif rep.routine!error <span class="Delimiter">(</span>prn <span class="Constant">&quot;error - &quot;</span> it<span class="Delimiter">)))</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span><span class="Normal">or</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.2</span> <span class="Constant">4</span><span class="Delimiter">)</span>
        <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.3</span> <span class="Constant">5</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - multiple calls to a function can share locals&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;default-space-closure&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function init-counter <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span>default-space:space-address <span class="Op">&lt;-</span> new space:literal <span class="MuConstant">30</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span>  <span class="Comment">; initialize to 3</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span> default-space:space-address<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function increment-counter <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span>default-space:space-address <span class="Op">&lt;-</span> new space:literal <span class="MuConstant">30</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">0</span>:space-address <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span>  <span class="Comment">; share outer space</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer/space:1 <span class="Op">&lt;-</span> add <span class="Constant">1</span>:integer/space:1 <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span>  <span class="Comment">; increment</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span>  <span class="Comment">; dummy</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span> <span class="Constant">1</span>:integer/space:1<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:space-address <span class="Op">&lt;-</span> init-counter<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> increment-counter <span class="Constant">1</span>:space-address<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> increment-counter <span class="Constant">1</span>:space-address<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="Delimiter">(</span>each routine <span class="Global">completed-routines*</span>
  <span class="Delimiter">(</span>aif rep.routine!error <span class="Delimiter">(</span>prn <span class="Constant">&quot;error - &quot;</span> it<span class="Delimiter">)))</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span><span class="Normal">or</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.2</span> <span class="Constant">4</span><span class="Delimiter">)</span>
        <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.3</span> <span class="Constant">5</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - multiple calls to a function can share locals&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;default-space-closure-with-names&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function init-counter <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span>default-space:space-address <span class="Op">&lt;-</span> new space:literal <span class="MuConstant">30</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span>x:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">23</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span>y:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span>  <span class="Comment">; correct copy of y</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span> default-space:space-address<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function increment-counter <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span>default-space:space-address <span class="Op">&lt;-</span> new space:literal <span class="MuConstant">30</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">0</span>:space-address/names:init-counter <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span>  <span class="Comment">; outer space must be created by 'init-counter' above</span></span>
      <span class="Mu"><span class="Delimiter">(</span>y:integer/space:1 <span class="Op">&lt;-</span> add y:integer/space:1 <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span>  <span class="Comment">; increment</span></span>
      <span class="Mu"><span class="Delimiter">(</span>y:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span>  <span class="Comment">; dummy</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span> y:integer/space:1<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:space-address/names:init-counter <span class="Op">&lt;-</span> init-counter<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> increment-counter <span class="Constant">1</span>:space-address/names:init-counter<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> increment-counter <span class="Constant">1</span>:space-address/names:init-counter<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="Delimiter">(</span>each routine <span class="Global">completed-routines*</span>
  <span class="Delimiter">(</span>aif rep.routine!error <span class="Delimiter">(</span>prn <span class="Constant">&quot;error - &quot;</span> it<span class="Delimiter">)))</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span><span class="Normal">or</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.2</span> <span class="Constant">4</span><span class="Delimiter">)</span>
        <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.3</span> <span class="Constant">5</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - multiple calls to a function can share locals&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">)</span>  <span class="Comment">; section 20</span>

<span class="Delimiter">(</span>section <span class="Constant">100</span>

<span class="SalientComment">;; Dynamic dispatch</span>
<span class="Comment">;</span>
<span class="Comment">; Putting it all together, here's how you define generic functions that run</span>
<span class="Comment">; different code based on the types of their args.</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;dispatch-clause&quot;</span><span class="Delimiter">)</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function test1 <span class="Delimiter">[</span></span>
      <span class="Comment">; doesn't matter too much how many locals you allocate space for (here 20)</span>
      <span class="Comment">; if it's slightly too many -- memory is plentiful</span>
      <span class="Comment">; if it's too few -- mu will raise an error</span>
      <span class="Mu"><span class="Delimiter">(</span>default-space:space-address <span class="Op">&lt;-</span> new space:literal <span class="MuConstant">20</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span>first-arg-box:tagged-value-address <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
      <span class="Comment">; if given integers, add them</span>
      { <span class="CommentedCode">begin</span>
        <span class="Mu"><span class="Delimiter">(</span>first-arg:integer match?:boolean <span class="Op">&lt;-</span> maybe-coerce first-arg-box:tagged-value-address/deref integer:literal<span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">break-unless</span> match?:boolean<span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span>second-arg-box:tagged-value-address <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span>second-arg:integer <span class="Op">&lt;-</span> maybe-coerce second-arg-box:tagged-value-address/deref integer:literal<span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span>result:integer <span class="Op">&lt;-</span> add first-arg:integer second-arg:integer<span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span> result:integer<span class="Delimiter">)</span></span>
      }
      <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span> <span class="MuConstant">nil</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:tagged-value-address <span class="Op">&lt;-</span> init-tagged-value integer:literal <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:tagged-value-address <span class="Op">&lt;-</span> init-tagged-value integer:literal <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> test1 <span class="Constant">1</span>:tagged-value-address <span class="Constant">2</span>:tagged-value-address<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.3</span> <span class="Constant">37</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - an example function that checks that its oarg is an integer&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;dispatch-multiple-clauses&quot;</span><span class="Delimiter">)</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function test1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span>default-space:space-address <span class="Op">&lt;-</span> new space:literal <span class="MuConstant">20</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span>first-arg-box:tagged-value-address <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
      <span class="Comment">; if given integers, add them</span>
      { <span class="CommentedCode">begin</span>
        <span class="Mu"><span class="Delimiter">(</span>first-arg:integer match?:boolean <span class="Op">&lt;-</span> maybe-coerce first-arg-box:tagged-value-address/deref integer:literal<span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">break-unless</span> match?:boolean<span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span>second-arg-box:tagged-value-address <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span>second-arg:integer <span class="Op">&lt;-</span> maybe-coerce second-arg-box:tagged-value-address/deref integer:literal<span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span>result:integer <span class="Op">&lt;-</span> add first-arg:integer second-arg:integer<span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span> result:integer<span class="Delimiter">)</span></span>
      }
      <span class="Comment">; if given booleans, or them (it's a silly kind of generic function)</span>
      { <span class="CommentedCode">begin</span>
        <span class="Mu"><span class="Delimiter">(</span>first-arg:boolean match?:boolean <span class="Op">&lt;-</span> maybe-coerce first-arg-box:tagged-value-address/deref boolean:literal<span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">break-unless</span> match?:boolean<span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span>second-arg-box:tagged-value-address <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span>second-arg:boolean <span class="Op">&lt;-</span> maybe-coerce second-arg-box:tagged-value-address/deref boolean:literal<span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span>result:boolean <span class="Op">&lt;-</span> or first-arg:boolean second-arg:boolean<span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span> result:integer<span class="Delimiter">)</span></span>
      }
      <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span> <span class="MuConstant">nil</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:tagged-value-address <span class="Op">&lt;-</span> init-tagged-value boolean:literal <span class="MuConstant">t</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:tagged-value-address <span class="Op">&lt;-</span> init-tagged-value boolean:literal <span class="MuConstant">nil</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:boolean <span class="Op">&lt;-</span> test1 <span class="Constant">1</span>:tagged-value-address <span class="Constant">2</span>:tagged-value-address<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (each stmt function*!test-fn</span>
<span class="CommentedCode">;?   (prn &quot;  &quot; stmt))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (wipe dump-trace*)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.3</span> t<span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - an example function that can do different things (dispatch) based on the type of its args or oargs&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;dispatch-multiple-calls&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function test1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span>default-space:space-address <span class="Op">&lt;-</span> new space:literal <span class="MuConstant">20</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span>first-arg-box:tagged-value-address <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
      <span class="Comment">; if given integers, add them</span>
      { <span class="CommentedCode">begin</span>
        <span class="Mu"><span class="Delimiter">(</span>first-arg:integer match?:boolean <span class="Op">&lt;-</span> maybe-coerce first-arg-box:tagged-value-address/deref integer:literal<span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">break-unless</span> match?:boolean<span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span>second-arg-box:tagged-value-address <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span>second-arg:integer <span class="Op">&lt;-</span> maybe-coerce second-arg-box:tagged-value-address/deref integer:literal<span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span>result:integer <span class="Op">&lt;-</span> add first-arg:integer second-arg:integer<span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span> result:integer<span class="Delimiter">)</span></span>
      }
      <span class="Comment">; if given booleans, or them (it's a silly kind of generic function)</span>
      { <span class="CommentedCode">begin</span>
        <span class="Mu"><span class="Delimiter">(</span>first-arg:boolean match?:boolean <span class="Op">&lt;-</span> maybe-coerce first-arg-box:tagged-value-address/deref boolean:literal<span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">break-unless</span> match?:boolean<span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span>second-arg-box:tagged-value-address <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span>second-arg:boolean <span class="Op">&lt;-</span> maybe-coerce second-arg-box:tagged-value-address/deref boolean:literal<span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span>result:boolean <span class="Op">&lt;-</span> or first-arg:boolean second-arg:boolean<span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span> result:integer<span class="Delimiter">)</span></span>
      }
      <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span> <span class="MuConstant">nil</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:tagged-value-address <span class="Op">&lt;-</span> init-tagged-value boolean:literal <span class="MuConstant">t</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:tagged-value-address <span class="Op">&lt;-</span> init-tagged-value boolean:literal <span class="MuConstant">nil</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:boolean <span class="Op">&lt;-</span> test1 <span class="Constant">1</span>:tagged-value-address <span class="Constant">2</span>:tagged-value-address<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">10</span>:tagged-value-address <span class="Op">&lt;-</span> init-tagged-value integer:literal <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">11</span>:tagged-value-address <span class="Op">&lt;-</span> init-tagged-value integer:literal <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">12</span>:integer <span class="Op">&lt;-</span> test1 <span class="Constant">10</span>:tagged-value-address <span class="Constant">11</span>:tagged-value-address<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~and <span class="Delimiter">(</span>is <span class="Global">memory*</span><span class="Constant">.3</span> t<span class="Delimiter">)</span> <span class="Delimiter">(</span>is <span class="Global">memory*</span><span class="Constant">.12</span> <span class="Constant">37</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - different calls can exercise different clauses of the same function&quot;</span><span class="Delimiter">))</span>

<span class="Comment">; We can also dispatch based on the type of the operands or results at the</span>
<span class="Comment">; caller.</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;dispatch-otype&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function test1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:type <span class="Op">&lt;-</span> otype <span class="MuConstant">0</span>:offset<span class="Delimiter">)</span></span>
      { <span class="CommentedCode">begin</span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:boolean <span class="Op">&lt;-</span> equal <span class="Constant">4</span>:type integer:literal<span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">break-unless</span> <span class="Constant">5</span>:boolean<span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Constant">6</span>:integer <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Constant">7</span>:integer <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Constant">8</span>:integer <span class="Op">&lt;-</span> add <span class="Constant">6</span>:integer <span class="Constant">7</span>:integer<span class="Delimiter">)</span></span>
      }
      <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span> <span class="Constant">8</span>:integer<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> test1 <span class="MuConstant">1</span>:literal <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span><span class="Constant">.1</span> <span class="Constant">4</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - an example function that checks that its oarg is an integer&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;dispatch-otype-multiple-clauses&quot;</span><span class="Delimiter">)</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function test1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:type <span class="Op">&lt;-</span> otype <span class="MuConstant">0</span>:offset<span class="Delimiter">)</span></span>
      { <span class="CommentedCode">begin</span>
        <span class="Comment">; integer needed? add args</span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:boolean <span class="Op">&lt;-</span> equal <span class="Constant">4</span>:type integer:literal<span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">break-unless</span> <span class="Constant">5</span>:boolean<span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Constant">6</span>:integer <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Constant">7</span>:integer <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Constant">8</span>:integer <span class="Op">&lt;-</span> add <span class="Constant">6</span>:integer <span class="Constant">7</span>:integer<span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span> <span class="Constant">8</span>:integer<span class="Delimiter">)</span></span>
      }
      { <span class="CommentedCode">begin</span>
        <span class="Comment">; boolean needed? 'or' args</span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:boolean <span class="Op">&lt;-</span> equal <span class="Constant">4</span>:type boolean:literal<span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">break-unless</span> <span class="Constant">5</span>:boolean <span class="MuConstant">4</span>:offset<span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Constant">6</span>:boolean <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Constant">7</span>:boolean <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Constant">8</span>:boolean <span class="Op">&lt;-</span> or <span class="Constant">6</span>:boolean <span class="Constant">7</span>:boolean<span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span> <span class="Constant">8</span>:boolean<span class="Delimiter">)</span></span>
      }<span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:boolean <span class="Op">&lt;-</span> test1 <span class="MuConstant">t</span>:literal <span class="MuConstant">t</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (each stmt function*!test1</span>
<span class="CommentedCode">;?   (prn &quot;  &quot; stmt))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (wipe dump-trace*)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.1</span> t<span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - an example function that can do different things (dispatch) based on the type of its args or oargs&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;dispatch-otype-multiple-calls&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function test1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:type <span class="Op">&lt;-</span> otype <span class="MuConstant">0</span>:offset<span class="Delimiter">)</span></span>
      { <span class="CommentedCode">begin</span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:boolean <span class="Op">&lt;-</span> equal <span class="Constant">4</span>:type integer:literal<span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">break-unless</span> <span class="Constant">5</span>:boolean<span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Constant">6</span>:integer <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Constant">7</span>:integer <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Constant">8</span>:integer <span class="Op">&lt;-</span> add <span class="Constant">6</span>:integer <span class="Constant">7</span>:integer<span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span> <span class="Constant">8</span>:integer<span class="Delimiter">)</span></span>
      }
      { <span class="CommentedCode">begin</span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:boolean <span class="Op">&lt;-</span> equal <span class="Constant">4</span>:type boolean:literal<span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">break-unless</span> <span class="Constant">5</span>:boolean<span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Constant">6</span>:boolean <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Constant">7</span>:boolean <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Constant">8</span>:boolean <span class="Op">&lt;-</span> or <span class="Constant">6</span>:boolean <span class="Constant">7</span>:boolean<span class="Delimiter">)</span></span>
        <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span> <span class="Constant">8</span>:boolean<span class="Delimiter">)</span></span>
      }<span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:boolean <span class="Op">&lt;-</span> test1 <span class="MuConstant">t</span>:literal <span class="MuConstant">t</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> test1 <span class="MuConstant">3</span>:literal <span class="MuConstant">4</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~and <span class="Delimiter">(</span>is <span class="Global">memory*</span><span class="Constant">.1</span> t<span class="Delimiter">)</span> <span class="Delimiter">(</span>is <span class="Global">memory*</span><span class="Constant">.2</span> <span class="Constant">7</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - different calls can exercise different clauses of the same function&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">)</span>  <span class="Comment">; section 100</span>

<span class="Delimiter">(</span>section <span class="Constant">20</span>

<span class="SalientComment">;; Concurrency</span>
<span class="Comment">;</span>
<span class="Comment">; A rudimentary process scheduler. You can 'run' multiple functions at once,</span>
<span class="Comment">; and they share the virtual processor.</span>
<span class="Comment">;</span>
<span class="Comment">; There's also a 'fork' primitive to let functions create new threads of</span>
<span class="Comment">; execution (we call them routines).</span>
<span class="Comment">;</span>
<span class="Comment">; Eventually we want to allow callers to influence how much of their CPU they</span>
<span class="Comment">; give to their 'children', or to rescind a child's running privileges.</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;scheduler&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function f1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function f2 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">4</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>f1 <span class="Delimiter">'</span>f2<span class="Delimiter">)</span>
<span class="Delimiter">(</span>when <span class="Delimiter">(</span>~iso <span class="Constant">2</span> <span class="Global">curr-cycle*</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - scheduler didn't run the right number of instructions: &quot;</span> <span class="Global">curr-cycle*</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span> <span class="Delimiter">(</span>obj <span class="Constant">1</span> <span class="Constant">3</span>  <span class="Constant">2</span> <span class="Constant">4</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - scheduler runs multiple functions: &quot;</span> <span class="Global">memory*</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span>check-trace-contents <span class="Constant">&quot;scheduler orders functions correctly&quot;</span>
  <span class="Delimiter">'((</span><span class="Constant">&quot;schedule&quot;</span> <span class="Constant">&quot;f1&quot;</span><span class="Delimiter">)</span>
    <span class="Delimiter">(</span><span class="Constant">&quot;schedule&quot;</span> <span class="Constant">&quot;f2&quot;</span><span class="Delimiter">)</span>
  <span class="Delimiter">))</span>
<span class="Delimiter">(</span>check-trace-contents <span class="Constant">&quot;scheduler orders schedule and run events correctly&quot;</span>
  <span class="Delimiter">'((</span><span class="Constant">&quot;schedule&quot;</span> <span class="Constant">&quot;f1&quot;</span><span class="Delimiter">)</span>
    <span class="Delimiter">(</span><span class="Constant">&quot;run&quot;</span> <span class="Constant">&quot;f1 0&quot;</span><span class="Delimiter">)</span>
    <span class="Delimiter">(</span><span class="Constant">&quot;schedule&quot;</span> <span class="Constant">&quot;f2&quot;</span><span class="Delimiter">)</span>
    <span class="Delimiter">(</span><span class="Constant">&quot;run&quot;</span> <span class="Constant">&quot;f2 0&quot;</span><span class="Delimiter">)</span>
  <span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;scheduler-alternate&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function f1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function f2 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>= <span class="Global">scheduling-interval*</span> <span class="Constant">1</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>f1 <span class="Delimiter">'</span>f2<span class="Delimiter">)</span>
<span class="Delimiter">(</span>check-trace-contents <span class="Constant">&quot;scheduler alternates between routines&quot;</span>
  <span class="Delimiter">'((</span><span class="Constant">&quot;run&quot;</span> <span class="Constant">&quot;f1 0&quot;</span><span class="Delimiter">)</span>
    <span class="Delimiter">(</span><span class="Constant">&quot;run&quot;</span> <span class="Constant">&quot;f2 0&quot;</span><span class="Delimiter">)</span>
    <span class="Delimiter">(</span><span class="Constant">&quot;run&quot;</span> <span class="Constant">&quot;f1 1&quot;</span><span class="Delimiter">)</span>
    <span class="Delimiter">(</span><span class="Constant">&quot;run&quot;</span> <span class="Constant">&quot;f2 1&quot;</span><span class="Delimiter">)</span>
  <span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;scheduler-sleep&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function f1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function f2 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Comment">; add one baseline routine to run (empty running-routines* handled below)</span>
<span class="Delimiter">(</span>enq make-routine!f1 <span class="Global">running-routines*</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>assert <span class="Delimiter">(</span>is <span class="Constant">1</span> len.running-routines*<span class="Delimiter">))</span>
<span class="Comment">; sleeping routine</span>
<span class="Delimiter">(</span><span class="Normal">let</span> routine make-routine!f2
  <span class="Mu"><span class="Delimiter">(</span>= rep.routine!sleep <span class="Delimiter">'(</span>for-some-cycles <span class="Constant">23</span><span class="Delimiter">))</span></span>
  <span class="Delimiter">(</span>set <span class="Global">sleeping-routines*</span>.routine<span class="Delimiter">))</span>
<span class="Comment">; not yet time for it to wake up</span>
<span class="Delimiter">(</span>= <span class="Global">curr-cycle*</span> <span class="Constant">23</span><span class="Delimiter">)</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;run&quot; &quot;schedule&quot;)))</span>
<span class="Delimiter">(</span>update-scheduler-state<span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">1</span> len.running-routines*<span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - scheduler lets routines sleep&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;scheduler-wakeup&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function f1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function f2 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Comment">; add one baseline routine to run (empty running-routines* handled below)</span>
<span class="Delimiter">(</span>enq make-routine!f1 <span class="Global">running-routines*</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>assert <span class="Delimiter">(</span>is <span class="Constant">1</span> len.running-routines*<span class="Delimiter">))</span>
<span class="Comment">; sleeping routine</span>
<span class="Delimiter">(</span><span class="Normal">let</span> routine make-routine!f2
  <span class="Delimiter">(</span>= rep.routine!sleep <span class="Delimiter">'(</span>for-some-cycles <span class="Constant">23</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>set <span class="Global">sleeping-routines*</span>.routine<span class="Delimiter">))</span>
<span class="Comment">; time for it to wake up</span>
<span class="Delimiter">(</span>= <span class="Global">curr-cycle*</span> <span class="Constant">24</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>update-scheduler-state<span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">2</span> len.running-routines*<span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - scheduler wakes up sleeping routines at the right time&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;scheduler-sleep-location&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function f1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function f2 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Comment">; add one baseline routine to run (empty running-routines* handled below)</span>
<span class="Delimiter">(</span>enq make-routine!f1 <span class="Global">running-routines*</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>assert <span class="Delimiter">(</span>is <span class="Constant">1</span> len.running-routines*<span class="Delimiter">))</span>
<span class="Comment">; blocked routine waiting for location 23 to change</span>
<span class="Delimiter">(</span><span class="Normal">let</span> routine make-routine!f2
  <span class="Delimiter">(</span>= rep.routine!sleep <span class="Delimiter">'(</span>until-location-changes <span class="Constant">23</span> <span class="Constant">0</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>set <span class="Global">sleeping-routines*</span>.routine<span class="Delimiter">))</span>
<span class="Comment">; leave memory location 23 unchanged</span>
<span class="Delimiter">(</span>= <span class="Global">memory*</span><span class="Constant">.23</span> <span class="Constant">0</span><span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="CommentedCode">;? (prn running-routines*)</span>
<span class="CommentedCode">;? (prn sleeping-routines*)</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;run&quot; &quot;schedule&quot;)))</span>
<span class="Delimiter">(</span>update-scheduler-state<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn running-routines*)</span>
<span class="CommentedCode">;? (prn sleeping-routines*)</span>
<span class="Comment">; routine remains blocked</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">1</span> len.running-routines*<span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - scheduler lets routines block on locations&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;scheduler-wakeup-location&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function f1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function f2 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Comment">; add one baseline routine to run (empty running-routines* handled below)</span>
<span class="Delimiter">(</span>enq make-routine!f1 <span class="Global">running-routines*</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>assert <span class="Delimiter">(</span>is <span class="Constant">1</span> len.running-routines*<span class="Delimiter">))</span>
<span class="Comment">; blocked routine waiting for location 23 to change</span>
<span class="Delimiter">(</span><span class="Normal">let</span> routine make-routine!f2
  <span class="Delimiter">(</span>= rep.routine!sleep <span class="Delimiter">'(</span>until-location-changes <span class="Constant">23</span> <span class="Constant">0</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>set <span class="Global">sleeping-routines*</span>.routine<span class="Delimiter">))</span>
<span class="Comment">; change memory location 23</span>
<span class="Delimiter">(</span>= <span class="Global">memory*</span><span class="Constant">.23</span> <span class="Constant">1</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>update-scheduler-state<span class="Delimiter">)</span>
<span class="Comment">; routine unblocked</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">2</span> len.running-routines*<span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - scheduler unblocks routines blocked on locations&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;scheduler-skip&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function f1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Comment">; running-routines* is empty</span>
<span class="Delimiter">(</span>assert <span class="Delimiter">(</span>empty <span class="Global">running-routines*</span><span class="Delimiter">))</span>
<span class="Comment">; sleeping routine</span>
<span class="Delimiter">(</span><span class="Normal">let</span> routine make-routine!f1
  <span class="Delimiter">(</span>= rep.routine!sleep <span class="Delimiter">'(</span>for-some-cycles <span class="Constant">34</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>set <span class="Global">sleeping-routines*</span>.routine<span class="Delimiter">))</span>
<span class="Comment">; long time left for it to wake up</span>
<span class="Delimiter">(</span>= <span class="Global">curr-cycle*</span> <span class="Constant">0</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>update-scheduler-state<span class="Delimiter">)</span>
<span class="Delimiter">(</span>assert <span class="Delimiter">(</span>is <span class="Global">curr-cycle*</span> <span class="Constant">35</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">1</span> len.running-routines*<span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - scheduler skips ahead to earliest sleeping routines when nothing to run&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;scheduler-deadlock&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function f1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>assert <span class="Delimiter">(</span>empty <span class="Global">running-routines*</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span>assert <span class="Delimiter">(</span>empty <span class="Global">completed-routines*</span><span class="Delimiter">))</span>
<span class="Comment">; blocked routine</span>
<span class="Delimiter">(</span><span class="Normal">let</span> routine make-routine!f1
  <span class="Delimiter">(</span>= rep.routine!sleep <span class="Delimiter">'(</span>until-location-changes <span class="Constant">23</span> <span class="Constant">0</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>set <span class="Global">sleeping-routines*</span>.routine<span class="Delimiter">))</span>
<span class="Comment">; location it's waiting on is 'unchanged'</span>
<span class="Delimiter">(</span>= <span class="Global">memory*</span><span class="Constant">.23</span> <span class="Constant">0</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>update-scheduler-state<span class="Delimiter">)</span>
<span class="Delimiter">(</span>assert <span class="Delimiter">(</span>~empty <span class="Global">completed-routines*</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (prn completed-routines*)</span>
<span class="Delimiter">(</span><span class="Normal">let</span> routine <span class="Global">completed-routines*</span><span class="Constant">.0</span>
  <span class="Delimiter">(</span>when <span class="Delimiter">(</span>~posmatch <span class="Constant">&quot;deadlock&quot;</span> rep.routine!error<span class="Delimiter">)</span>
    <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - scheduler detects deadlock&quot;</span><span class="Delimiter">)))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;scheduler-deadlock2&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function f1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Comment">; running-routines* is empty</span>
<span class="Delimiter">(</span>assert <span class="Delimiter">(</span>empty <span class="Global">running-routines*</span><span class="Delimiter">))</span>
<span class="Comment">; blocked routine</span>
<span class="Delimiter">(</span><span class="Normal">let</span> routine make-routine!f1
  <span class="Delimiter">(</span>= rep.routine!sleep <span class="Delimiter">'(</span>until-location-changes <span class="Constant">23</span> <span class="Constant">0</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>set <span class="Global">sleeping-routines*</span>.routine<span class="Delimiter">))</span>
<span class="Comment">; but is about to become ready</span>
<span class="Delimiter">(</span>= <span class="Global">memory*</span><span class="Constant">.23</span> <span class="Constant">1</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>update-scheduler-state<span class="Delimiter">)</span>
<span class="Delimiter">(</span>when <span class="Delimiter">(</span>~empty <span class="Global">completed-routines*</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - scheduler ignores sleeping but ready threads when detecting deadlock&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;sleep&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function f1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span>sleep for-some-cycles:literal <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function f2 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;run&quot; &quot;schedule&quot;)))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>f1 <span class="Delimiter">'</span>f2<span class="Delimiter">)</span>
<span class="Delimiter">(</span>check-trace-contents <span class="Constant">&quot;scheduler handles sleeping routines&quot;</span>
  <span class="Delimiter">'((</span><span class="Constant">&quot;run&quot;</span> <span class="Constant">&quot;f1 0&quot;</span><span class="Delimiter">)</span>
    <span class="Delimiter">(</span><span class="Constant">&quot;run&quot;</span> <span class="Constant">&quot;sleeping until 2&quot;</span><span class="Delimiter">)</span>
    <span class="Delimiter">(</span><span class="Constant">&quot;schedule&quot;</span> <span class="Constant">&quot;pushing f1 to sleep queue&quot;</span><span class="Delimiter">)</span>
    <span class="Delimiter">(</span><span class="Constant">&quot;run&quot;</span> <span class="Constant">&quot;f2 0&quot;</span><span class="Delimiter">)</span>
    <span class="Delimiter">(</span><span class="Constant">&quot;run&quot;</span> <span class="Constant">&quot;f2 1&quot;</span><span class="Delimiter">)</span>
    <span class="Delimiter">(</span><span class="Constant">&quot;schedule&quot;</span> <span class="Constant">&quot;waking up f1&quot;</span><span class="Delimiter">)</span>
    <span class="Delimiter">(</span><span class="Constant">&quot;run&quot;</span> <span class="Constant">&quot;f1 1&quot;</span><span class="Delimiter">)</span>
    <span class="Delimiter">(</span><span class="Constant">&quot;run&quot;</span> <span class="Constant">&quot;f1 2&quot;</span><span class="Delimiter">)</span>
  <span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;sleep-long&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function f1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span>sleep for-some-cycles:literal <span class="MuConstant">20</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function f2 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;run&quot; &quot;schedule&quot;)))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>f1 <span class="Delimiter">'</span>f2<span class="Delimiter">)</span>
<span class="Delimiter">(</span>check-trace-contents <span class="Constant">&quot;scheduler progresses sleeping routines when there are no routines left to run&quot;</span>
  <span class="Delimiter">'((</span><span class="Constant">&quot;run&quot;</span> <span class="Constant">&quot;f1 0&quot;</span><span class="Delimiter">)</span>
    <span class="Delimiter">(</span><span class="Constant">&quot;run&quot;</span> <span class="Constant">&quot;sleeping until 21&quot;</span><span class="Delimiter">)</span>
    <span class="Delimiter">(</span><span class="Constant">&quot;schedule&quot;</span> <span class="Constant">&quot;pushing f1 to sleep queue&quot;</span><span class="Delimiter">)</span>
    <span class="Delimiter">(</span><span class="Constant">&quot;run&quot;</span> <span class="Constant">&quot;f2 0&quot;</span><span class="Delimiter">)</span>
    <span class="Delimiter">(</span><span class="Constant">&quot;run&quot;</span> <span class="Constant">&quot;f2 1&quot;</span><span class="Delimiter">)</span>
    <span class="Delimiter">(</span><span class="Constant">&quot;schedule&quot;</span> <span class="Constant">&quot;waking up f1&quot;</span><span class="Delimiter">)</span>
    <span class="Delimiter">(</span><span class="Constant">&quot;run&quot;</span> <span class="Constant">&quot;f1 1&quot;</span><span class="Delimiter">)</span>
    <span class="Delimiter">(</span><span class="Constant">&quot;run&quot;</span> <span class="Constant">&quot;f1 2&quot;</span><span class="Delimiter">)</span>
  <span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;sleep-location&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function f1 <span class="Delimiter">[</span></span>
      <span class="Comment">; waits for memory location 1 to be set, before computing its successor</span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span>sleep until-location-changes:literal <span class="Constant">1</span>:integer<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> add <span class="Constant">1</span>:integer <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function f2 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span>sleep for-some-cycles:literal <span class="MuConstant">30</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span>  <span class="Comment">; set to value</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;run&quot; &quot;schedule&quot;)))</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>f1 <span class="Delimiter">'</span>f2<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn int-canon.memory*)</span>
<span class="Delimiter">(</span>each routine <span class="Global">completed-routines*</span>
  <span class="Delimiter">(</span>aif rep.routine!error <span class="Delimiter">(</span>prn <span class="Constant">&quot;error - &quot;</span> it<span class="Delimiter">)))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.2</span> <span class="Constant">4</span><span class="Delimiter">)</span>  <span class="Comment">; successor of value</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - sleep can block on a memory location&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;sleep-scoped-location&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function f1 <span class="Delimiter">[</span></span>
      <span class="Comment">; waits for memory location 1 to be changed, before computing its successor</span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">10</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">5</span>:literal<span class="Delimiter">)</span>  <span class="Comment">; array of locals</span></span>
      <span class="Mu"><span class="Delimiter">(</span>default-space:space-address <span class="Op">&lt;-</span> copy <span class="MuConstant">10</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">23</span>:literal<span class="Delimiter">)</span>  <span class="Comment">; really location 12</span></span>
      <span class="Mu"><span class="Delimiter">(</span>sleep until-location-changes:literal <span class="Constant">1</span>:integer<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> add <span class="Constant">1</span>:integer <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function f2 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span>sleep for-some-cycles:literal <span class="MuConstant">30</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">12</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span>  <span class="Comment">; set to value</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;run&quot; &quot;schedule&quot;)))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>f1 <span class="Delimiter">'</span>f2<span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.13</span> <span class="Constant">4</span><span class="Delimiter">)</span>  <span class="Comment">; successor of value</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - sleep can block on a scoped memory location&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;fork&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function f1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span>fork f2:fn<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function f2 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">4</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>f1<span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span><span class="Constant">.2</span> <span class="Constant">4</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - fork works&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;fork-with-args&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function f1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span>fork f2:fn <span class="MuConstant">nil</span>:literal <span class="MuConstant">4</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function f2 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>f1<span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span><span class="Constant">.2</span> <span class="Constant">4</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - fork can pass args&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;fork-copies-args&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function f1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span>default-space:space-address <span class="Op">&lt;-</span> new space:literal <span class="MuConstant">5</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span>x:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">4</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span>fork f2:fn <span class="MuConstant">nil</span>:literal x:integer<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span>x:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span>  <span class="Comment">; should be ignored</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function f2 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>f1<span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span><span class="Constant">.2</span> <span class="Constant">4</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - fork passes args by value&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;fork-global&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function f1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer/raw <span class="Op">&lt;-</span> copy <span class="Constant">2</span>:integer/space:global<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span>default-space:space-address <span class="Op">&lt;-</span> new space:literal <span class="MuConstant">5</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">4</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span>fork f1:fn default-space:space-address<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="Delimiter">(</span>each routine <span class="Global">completed-routines*</span>
  <span class="Delimiter">(</span>awhen rep.routine!error <span class="Delimiter">(</span>prn <span class="Constant">&quot;error - &quot;</span> it<span class="Delimiter">)))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">memory*</span><span class="Constant">.1</span> <span class="Constant">4</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - fork can take a space of global variables to access&quot;</span><span class="Delimiter">))</span>

<span class="Comment">; The scheduler needs to keep track of the call stack for each routine.</span>
<span class="Comment">; Eventually we'll want to save this information in mu's address space itself,</span>
<span class="Comment">; along with the types array, the magic buffers for args and oargs, and so on.</span>
<span class="Comment">;</span>
<span class="Comment">; Eventually we want the right stack-management primitives to build delimited</span>
<span class="Comment">; continuations in mu.</span>

<span class="Comment">; Routines can throw errors.</span>
<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;array-bounds-check&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">2</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">23</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">24</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> index <span class="Constant">1</span>:integer-array <span class="MuConstant">2</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">let</span> routine <span class="Delimiter">(</span>car <span class="Global">completed-routines*</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>no rep.routine!error<span class="Delimiter">)</span>
    <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'index' throws an error if out of bounds&quot;</span><span class="Delimiter">)))</span>

<span class="Delimiter">)</span>  <span class="Comment">; section 20</span>

<span class="Delimiter">(</span>section <span class="Constant">100</span>

<span class="SalientComment">;; Synchronization</span>
<span class="Comment">;</span>
<span class="Comment">; Mu synchronizes using channels rather than locks, like Erlang and Go.</span>
<span class="Comment">;</span>
<span class="Comment">; The two ends of a channel will usually belong to different routines, but</span>
<span class="Comment">; each end should only be used by a single one. Don't try to read from or</span>
<span class="Comment">; write to it from multiple routines at once.</span>
<span class="Comment">;</span>
<span class="Comment">; To avoid locking, writer and reader will never write to the same location.</span>
<span class="Comment">; So channels will include fields in pairs, one for the writer and one for the</span>
<span class="Comment">; reader.</span>

<span class="Comment">; The core circular buffer contains values at index 'first-full' up to (but</span>
<span class="Comment">; not including) index 'first-empty'. The reader always modifies it at</span>
<span class="Comment">; first-full, while the writer always modifies it at first-empty.</span>
<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;channel-new&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:channel-address <span class="Op">&lt;-</span> init-channel <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> get <span class="Constant">1</span>:channel-address/deref first-full:offset<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> get <span class="Constant">1</span>:channel-address/deref first-free:offset<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span><span class="Normal">or</span> <span class="Delimiter">(</span>~is <span class="Constant">0</span> <span class="Global">memory*</span><span class="Constant">.2</span><span class="Delimiter">)</span>
        <span class="Delimiter">(</span>~is <span class="Constant">0</span> <span class="Global">memory*</span><span class="Constant">.3</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'init-channel' initializes 'first-full and 'first-free to 0&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;channel-write&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:channel-address <span class="Op">&lt;-</span> init-channel <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:tagged-value <span class="Op">&lt;-</span> save-type <span class="Constant">2</span>:integer<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:channel-address/deref <span class="Op">&lt;-</span> write <span class="Constant">1</span>:channel-address <span class="Constant">3</span>:tagged-value<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:integer <span class="Op">&lt;-</span> get <span class="Constant">1</span>:channel-address/deref first-full:offset<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">6</span>:integer <span class="Op">&lt;-</span> get <span class="Constant">1</span>:channel-address/deref first-free:offset<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (prn function*!write)</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="CommentedCode">;? (= dump-trace* (obj blacklist '(&quot;sz&quot; &quot;m&quot; &quot;setm&quot; &quot;addr&quot; &quot;array-len&quot; &quot;cvt0&quot; &quot;cvt1&quot;)))</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;jump&quot;)))</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;run&quot; &quot;reply&quot;)))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="Delimiter">(</span>each routine <span class="Global">completed-routines*</span>
  <span class="Delimiter">(</span>aif rep.routine!error <span class="Delimiter">(</span>prn <span class="Constant">&quot;error - &quot;</span> it<span class="Delimiter">)))</span>
<span class="CommentedCode">;? (prn canon.memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span><span class="Normal">or</span> <span class="Delimiter">(</span>~is <span class="Constant">0</span> <span class="Global">memory*</span><span class="Constant">.5</span><span class="Delimiter">)</span>
        <span class="Delimiter">(</span>~is <span class="Constant">1</span> <span class="Global">memory*</span><span class="Constant">.6</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'write' enqueues item to channel&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;channel-read&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:channel-address <span class="Op">&lt;-</span> init-channel <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:tagged-value <span class="Op">&lt;-</span> save-type <span class="Constant">2</span>:integer<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:channel-address/deref <span class="Op">&lt;-</span> write <span class="Constant">1</span>:channel-address <span class="Constant">3</span>:tagged-value<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:tagged-value <span class="Constant">1</span>:channel-address/deref <span class="Op">&lt;-</span> read <span class="Constant">1</span>:channel-address<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">7</span>:integer <span class="Op">&lt;-</span> maybe-coerce <span class="Constant">5</span>:tagged-value integer:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">8</span>:integer <span class="Op">&lt;-</span> get <span class="Constant">1</span>:channel-address/deref first-full:offset<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">9</span>:integer <span class="Op">&lt;-</span> get <span class="Constant">1</span>:channel-address/deref first-free:offset<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="CommentedCode">;? (= dump-trace* (obj blacklist '(&quot;sz&quot; &quot;m&quot; &quot;setm&quot; &quot;addr&quot; &quot;array-len&quot; &quot;cvt0&quot; &quot;cvt1&quot;)))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn int-canon.memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.7</span> <span class="Constant">34</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'read' returns written value&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span><span class="Normal">or</span> <span class="Delimiter">(</span>~is <span class="Constant">1</span> <span class="Global">memory*</span><span class="Constant">.8</span><span class="Delimiter">)</span>
        <span class="Delimiter">(</span>~is <span class="Constant">1</span> <span class="Global">memory*</span><span class="Constant">.9</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'read' dequeues item from channel&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;channel-write-wrap&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Comment">; channel with 1 slot</span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:channel-address <span class="Op">&lt;-</span> init-channel <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
      <span class="Comment">; write a value</span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:tagged-value <span class="Op">&lt;-</span> save-type <span class="Constant">2</span>:integer<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:channel-address/deref <span class="Op">&lt;-</span> write <span class="Constant">1</span>:channel-address <span class="Constant">3</span>:tagged-value<span class="Delimiter">)</span></span>
      <span class="Comment">; first-free will now be 1</span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:integer <span class="Op">&lt;-</span> get <span class="Constant">1</span>:channel-address/deref first-free:offset<span class="Delimiter">)</span></span>
      <span class="Comment">; read one value</span>
      <span class="Mu"><span class="Delimiter">(</span>_ <span class="Constant">1</span>:channel-address/deref <span class="Op">&lt;-</span> read <span class="Constant">1</span>:channel-address<span class="Delimiter">)</span></span>
      <span class="Comment">; write a second value; verify that first-free wraps around to 0.</span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:channel-address/deref <span class="Op">&lt;-</span> write <span class="Constant">1</span>:channel-address <span class="Constant">3</span>:tagged-value<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">6</span>:integer <span class="Op">&lt;-</span> get <span class="Constant">1</span>:channel-address/deref first-free:offset<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="CommentedCode">;? (= dump-trace* (obj blacklist '(&quot;sz&quot; &quot;m&quot; &quot;setm&quot; &quot;addr&quot; &quot;array-len&quot; &quot;cvt0&quot; &quot;cvt1&quot;)))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn canon.memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span><span class="Normal">or</span> <span class="Delimiter">(</span>~is <span class="Constant">1</span> <span class="Global">memory*</span><span class="Constant">.5</span><span class="Delimiter">)</span>
        <span class="Delimiter">(</span>~is <span class="Constant">0</span> <span class="Global">memory*</span><span class="Constant">.6</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'write' can wrap pointer back to start&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;channel-read-wrap&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Comment">; channel with 1 slot</span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:channel-address <span class="Op">&lt;-</span> init-channel <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
      <span class="Comment">; write a value</span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:tagged-value <span class="Op">&lt;-</span> save-type <span class="Constant">2</span>:integer<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:channel-address/deref <span class="Op">&lt;-</span> write <span class="Constant">1</span>:channel-address <span class="Constant">3</span>:tagged-value<span class="Delimiter">)</span></span>
      <span class="Comment">; read one value</span>
      <span class="Mu"><span class="Delimiter">(</span>_ <span class="Constant">1</span>:channel-address/deref <span class="Op">&lt;-</span> read <span class="Constant">1</span>:channel-address<span class="Delimiter">)</span></span>
      <span class="Comment">; first-full will now be 1</span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:integer <span class="Op">&lt;-</span> get <span class="Constant">1</span>:channel-address/deref first-full:offset<span class="Delimiter">)</span></span>
      <span class="Comment">; write a second value</span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:channel-address/deref <span class="Op">&lt;-</span> write <span class="Constant">1</span>:channel-address <span class="Constant">3</span>:tagged-value<span class="Delimiter">)</span></span>
      <span class="Comment">; read second value; verify that first-full wraps around to 0.</span>
      <span class="Mu"><span class="Delimiter">(</span>_ <span class="Constant">1</span>:channel-address/deref <span class="Op">&lt;-</span> read <span class="Constant">1</span>:channel-address<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">6</span>:integer <span class="Op">&lt;-</span> get <span class="Constant">1</span>:channel-address/deref first-full:offset<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="CommentedCode">;? (= dump-trace* (obj blacklist '(&quot;sz&quot; &quot;m&quot; &quot;setm&quot; &quot;addr&quot; &quot;array-len&quot; &quot;cvt0&quot; &quot;cvt1&quot;)))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn canon.memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span><span class="Normal">or</span> <span class="Delimiter">(</span>~is <span class="Constant">1</span> <span class="Global">memory*</span><span class="Constant">.5</span><span class="Delimiter">)</span>
        <span class="Delimiter">(</span>~is <span class="Constant">0</span> <span class="Global">memory*</span><span class="Constant">.6</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'read' can wrap pointer back to start&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;channel-new-empty-not-full&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:channel-address <span class="Op">&lt;-</span> init-channel <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:boolean <span class="Op">&lt;-</span> empty? <span class="Constant">1</span>:channel-address/deref<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:boolean <span class="Op">&lt;-</span> full? <span class="Constant">1</span>:channel-address/deref<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span><span class="Normal">or</span> <span class="Delimiter">(</span>~is t <span class="Global">memory*</span><span class="Constant">.2</span><span class="Delimiter">)</span>
        <span class="Delimiter">(</span>~is nil <span class="Global">memory*</span><span class="Constant">.3</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - a new channel is always empty, never full&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;channel-write-not-empty&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:channel-address <span class="Op">&lt;-</span> init-channel <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:tagged-value <span class="Op">&lt;-</span> save-type <span class="Constant">2</span>:integer<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:channel-address/deref <span class="Op">&lt;-</span> write <span class="Constant">1</span>:channel-address <span class="Constant">3</span>:tagged-value<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:boolean <span class="Op">&lt;-</span> empty? <span class="Constant">1</span>:channel-address/deref<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">6</span>:boolean <span class="Op">&lt;-</span> full? <span class="Constant">1</span>:channel-address/deref<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span><span class="Normal">or</span> <span class="Delimiter">(</span>~is nil <span class="Global">memory*</span><span class="Constant">.5</span><span class="Delimiter">)</span>
        <span class="Delimiter">(</span>~is nil <span class="Global">memory*</span><span class="Constant">.6</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - a channel after writing is never empty&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;channel-write-full&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:channel-address <span class="Op">&lt;-</span> init-channel <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:tagged-value <span class="Op">&lt;-</span> save-type <span class="Constant">2</span>:integer<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:channel-address/deref <span class="Op">&lt;-</span> write <span class="Constant">1</span>:channel-address <span class="Constant">3</span>:tagged-value<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:boolean <span class="Op">&lt;-</span> empty? <span class="Constant">1</span>:channel-address/deref<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">6</span>:boolean <span class="Op">&lt;-</span> full? <span class="Constant">1</span>:channel-address/deref<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span><span class="Normal">or</span> <span class="Delimiter">(</span>~is nil <span class="Global">memory*</span><span class="Constant">.5</span><span class="Delimiter">)</span>
        <span class="Delimiter">(</span>~is t <span class="Global">memory*</span><span class="Constant">.6</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - a channel after writing may be full&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;channel-read-not-full&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:channel-address <span class="Op">&lt;-</span> init-channel <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:tagged-value <span class="Op">&lt;-</span> save-type <span class="Constant">2</span>:integer<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:channel-address/deref <span class="Op">&lt;-</span> write <span class="Constant">1</span>:channel-address <span class="Constant">3</span>:tagged-value<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:channel-address/deref <span class="Op">&lt;-</span> write <span class="Constant">1</span>:channel-address <span class="Constant">3</span>:tagged-value<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span>_ <span class="Constant">1</span>:channel-address/deref <span class="Op">&lt;-</span> read <span class="Constant">1</span>:channel-address<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:boolean <span class="Op">&lt;-</span> empty? <span class="Constant">1</span>:channel-address/deref<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">6</span>:boolean <span class="Op">&lt;-</span> full? <span class="Constant">1</span>:channel-address/deref<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span><span class="Normal">or</span> <span class="Delimiter">(</span>~is nil <span class="Global">memory*</span><span class="Constant">.5</span><span class="Delimiter">)</span>
        <span class="Delimiter">(</span>~is nil <span class="Global">memory*</span><span class="Constant">.6</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - a channel after reading is never full&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;channel-read-empty&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:channel-address <span class="Op">&lt;-</span> init-channel <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:tagged-value <span class="Op">&lt;-</span> save-type <span class="Constant">2</span>:integer<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:channel-address/deref <span class="Op">&lt;-</span> write <span class="Constant">1</span>:channel-address <span class="Constant">3</span>:tagged-value<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span>_ <span class="Constant">1</span>:channel-address/deref <span class="Op">&lt;-</span> read <span class="Constant">1</span>:channel-address<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:boolean <span class="Op">&lt;-</span> empty? <span class="Constant">1</span>:channel-address/deref<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">6</span>:boolean <span class="Op">&lt;-</span> full? <span class="Constant">1</span>:channel-address/deref<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span><span class="Normal">or</span> <span class="Delimiter">(</span>~is t <span class="Global">memory*</span><span class="Constant">.5</span><span class="Delimiter">)</span>
        <span class="Delimiter">(</span>~is nil <span class="Global">memory*</span><span class="Constant">.6</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - a channel after reading may be empty&quot;</span><span class="Delimiter">))</span>

<span class="Comment">; The key property of channels; writing to a full channel blocks the current</span>
<span class="Comment">; routine until it creates space. Ditto reading from an empty channel.</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;channel-read-block&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:channel-address <span class="Op">&lt;-</span> init-channel <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span></span>
      <span class="Comment">; channel is empty, but receives a read</span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:tagged-value <span class="Constant">1</span>:channel-address/deref <span class="Op">&lt;-</span> read <span class="Constant">1</span>:channel-address<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;run&quot; &quot;schedule&quot;)))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn int-canon.memory*)</span>
<span class="CommentedCode">;? (prn sleeping-routines*)</span>
<span class="CommentedCode">;? (prn completed-routines*)</span>
<span class="Comment">; read should cause the routine to sleep, and</span>
<span class="Comment">; the sole sleeping routine should trigger the deadlock detector</span>
<span class="Delimiter">(</span><span class="Normal">let</span> routine <span class="Delimiter">(</span>car <span class="Global">completed-routines*</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>when <span class="Delimiter">(</span><span class="Normal">or</span> <span class="Delimiter">(</span>no routine<span class="Delimiter">)</span>
            <span class="Delimiter">(</span>no rep.routine!error<span class="Delimiter">)</span>
            <span class="Delimiter">(</span>~posmatch <span class="Constant">&quot;deadlock&quot;</span> rep.routine!error<span class="Delimiter">))</span>
    <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'read' on empty channel blocks (puts the routine to sleep until the channel gets data)&quot;</span><span class="Delimiter">)))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;channel-write-block&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:channel-address <span class="Op">&lt;-</span> init-channel <span class="MuConstant">1</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">34</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:tagged-value <span class="Op">&lt;-</span> save-type <span class="Constant">2</span>:integer<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:channel-address/deref <span class="Op">&lt;-</span> write <span class="Constant">1</span>:channel-address <span class="Constant">3</span>:tagged-value<span class="Delimiter">)</span></span>
      <span class="Comment">; channel has capacity 1, but receives a second write</span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:channel-address/deref <span class="Op">&lt;-</span> write <span class="Constant">1</span>:channel-address <span class="Constant">3</span>:tagged-value<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;run&quot; &quot;schedule&quot; &quot;addr&quot;)))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn int-canon.memory*)</span>
<span class="CommentedCode">;? (prn running-routines*)</span>
<span class="CommentedCode">;? (prn sleeping-routines*)</span>
<span class="CommentedCode">;? (prn completed-routines*)</span>
<span class="Comment">; second write should cause the routine to sleep, and</span>
<span class="Comment">; the sole sleeping routine should trigger the deadlock detector</span>
<span class="Delimiter">(</span><span class="Normal">let</span> routine <span class="Delimiter">(</span>car <span class="Global">completed-routines*</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>when <span class="Delimiter">(</span><span class="Normal">or</span> <span class="Delimiter">(</span>no routine<span class="Delimiter">)</span>
            <span class="Delimiter">(</span>no rep.routine!error<span class="Delimiter">)</span>
            <span class="Delimiter">(</span>~posmatch <span class="Constant">&quot;deadlock&quot;</span> rep.routine!error<span class="Delimiter">))</span>
    <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'write' on full channel blocks (puts the routine to sleep until the channel gets data)&quot;</span><span class="Delimiter">)))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;channel-handoff&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function consumer <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span>default-space:space-address <span class="Op">&lt;-</span> new space:literal <span class="MuConstant">30</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span>chan:channel-address <span class="Op">&lt;-</span> init-channel <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span>  <span class="Comment">; create a channel</span></span>
      <span class="Mu"><span class="Delimiter">(</span>fork producer:fn <span class="MuConstant">nil</span>:literal chan:channel-address<span class="Delimiter">)</span>  <span class="Comment">; fork a routine to produce a value in it</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:tagged-value/raw <span class="Op">&lt;-</span> read chan:channel-address<span class="Delimiter">)</span>  <span class="Comment">; wait for input on channel</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function producer <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span>default-space:space-address <span class="Op">&lt;-</span> new space:literal <span class="MuConstant">30</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span>n:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">24</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span>ochan:channel-address <span class="Op">&lt;-</span> <span class="Identifier">next-input</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span>x:tagged-value <span class="Op">&lt;-</span> save-type n:integer<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span>ochan:channel-address/deref <span class="Op">&lt;-</span> write ochan:channel-address x:tagged-value<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;schedule&quot; &quot;run&quot; &quot;addr&quot;)))</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;-&quot;)))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>consumer<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*)</span>
<span class="Delimiter">(</span>each routine <span class="Global">completed-routines*</span>
  <span class="Delimiter">(</span>aif rep.routine!error <span class="Delimiter">(</span>prn <span class="Constant">&quot;error - &quot;</span> it<span class="Delimiter">)))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">24</span> <span class="Global">memory*</span><span class="Constant">.2</span><span class="Delimiter">)</span>  <span class="Comment">; location 1 contains tagged-value x above</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - channels are meant to be shared between routines&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;channel-handoff-routine&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function consumer <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span>default-space:space-address <span class="Op">&lt;-</span> new space:literal <span class="MuConstant">30</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:channel-address <span class="Op">&lt;-</span> init-channel <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span>  <span class="Comment">; create a channel</span></span>
      <span class="Mu"><span class="Delimiter">(</span>fork producer:fn default-space:space-address<span class="Delimiter">)</span>  <span class="Comment">; pass it as a global to another routine</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:tagged-value/raw <span class="Op">&lt;-</span> read <span class="Constant">1</span>:channel-address<span class="Delimiter">)</span>  <span class="Comment">; wait for input on channel</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function producer <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span>default-space:space-address <span class="Op">&lt;-</span> new space:literal <span class="MuConstant">30</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span>n:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">24</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span>x:tagged-value <span class="Op">&lt;-</span> save-type n:integer<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:channel-address/space:global/deref <span class="Op">&lt;-</span> write <span class="Constant">1</span>:channel-address/space:global x:tagged-value<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>consumer<span class="Delimiter">)</span>
<span class="Delimiter">(</span>each routine <span class="Global">completed-routines*</span>
  <span class="Delimiter">(</span>aif rep.routine!error <span class="Delimiter">(</span>prn <span class="Constant">&quot;error - &quot;</span> it<span class="Delimiter">)))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">24</span> <span class="Global">memory*</span><span class="Constant">.2</span><span class="Delimiter">)</span>  <span class="Comment">; location 1 contains tagged-value x above</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - channels are meant to be shared between routines&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">)</span>  <span class="Comment">; section 100</span>

<span class="Delimiter">(</span>section <span class="Constant">10</span>

<span class="SalientComment">;; Separating concerns</span>
<span class="Comment">;</span>
<span class="Comment">; Lightweight tools can also operate on quoted lists of statements surrounded</span>
<span class="Comment">; by square brackets. In the example below, we mimic Go's 'defer' keyword</span>
<span class="Comment">; using 'convert-quotes'. It lets us write code anywhere in a function, but</span>
<span class="Comment">; have it run just before the function exits. Great for keeping code to</span>
<span class="Comment">; reclaim memory or other resources close to the code to allocate it. (C++</span>
<span class="Comment">; programmers know this as RAII.) We'll use 'defer' when we build a memory</span>
<span class="Comment">; deallocation routine like C's 'free'.</span>
<span class="Comment">;</span>
<span class="Comment">; More powerful reorderings are also possible like in Literate Programming or</span>
<span class="Comment">; Aspect-Oriented Programming; one advantage of prohibiting arbitrarily nested</span>
<span class="Comment">; code is that we can naturally name 'join points' wherever we want.</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;convert-quotes-defer&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>convert-quotes
            <span class="Mu"><span class="Delimiter">'((</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">4</span>:literal<span class="Delimiter">)</span></span>
              <span class="Mu"><span class="Delimiter">(</span>defer <span class="Delimiter">[</span></span>
                       <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">6</span>:literal<span class="Delimiter">)</span></span>
                     <span class="Delimiter">])</span>
              <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">5</span>:literal<span class="Delimiter">)))</span></span>
          <span class="Mu"><span class="Delimiter">'((</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">4</span>:literal<span class="Delimiter">)</span></span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">5</span>:literal<span class="Delimiter">)</span></span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">6</span>:literal<span class="Delimiter">)))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - convert-quotes can handle 'defer'&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;convert-quotes-defer-reply&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>convert-quotes
            <span class="Mu"><span class="Delimiter">'((</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
              <span class="Mu"><span class="Delimiter">(</span>defer <span class="Delimiter">[</span></span>
                       <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
                     <span class="Delimiter">])</span>
              <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
              <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span><span class="Delimiter">)</span></span>
              <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
              <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)))</span></span>
          <span class="Mu"><span class="Delimiter">'((</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span><span class="Delimiter">)</span></span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - convert-quotes inserts code at early exits&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;convert-quotes-defer-reply-arg&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>convert-quotes
            <span class="Mu"><span class="Delimiter">'((</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
              <span class="Mu"><span class="Delimiter">(</span>defer <span class="Delimiter">[</span></span>
                       <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
                     <span class="Delimiter">])</span>
              <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
              <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span> <span class="MuConstant">2</span>:literal<span class="Delimiter">)</span></span>
              <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
              <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)))</span></span>
          <span class="Mu"><span class="Delimiter">'((</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
            <span class="Mu"><span class="Delimiter">(</span>prepare-reply <span class="MuConstant">2</span>:literal<span class="Delimiter">)</span></span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Identifier">reply</span><span class="Delimiter">)</span></span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - convert-quotes inserts code at early exits&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;convert-quotes-label&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>convert-quotes
            <span class="Mu"><span class="Delimiter">'((</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">4</span>:literal<span class="Delimiter">)</span></span>
              foo
              <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">5</span>:literal<span class="Delimiter">)))</span></span>
          <span class="Mu"><span class="Delimiter">'((</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">4</span>:literal<span class="Delimiter">)</span></span>
            foo
            <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">5</span>:literal<span class="Delimiter">)))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - convert-quotes can handle labels&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;before&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>before label1 <span class="Delimiter">[</span></span>
     <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
    <span class="Delimiter">])))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>as cons <span class="Global">before*</span>!label1<span class="Delimiter">)</span>
          <span class="Delimiter">'(</span><span class="Comment">; fragment</span>
            <span class="Delimiter">(</span>
              <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">))))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'before' records fragments of code to insert before labels&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>insert-code
            <span class="Mu"><span class="Delimiter">'((</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
              <span class="Mu">label1</span>
              <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)))</span></span>
          <span class="Mu"><span class="Delimiter">'((</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
            <span class="Mu">label1</span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'insert-code' can insert fragments before labels&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;before-multiple&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>before label1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>before label1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>as cons <span class="Global">before*</span>!label1<span class="Delimiter">)</span>
          <span class="Delimiter">'(</span><span class="Comment">; fragment</span>
            <span class="Delimiter">(</span>
              <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">))</span></span>
            <span class="Delimiter">(</span>
              <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">))))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'before' records fragments in order&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>insert-code
            <span class="Mu"><span class="Delimiter">'((</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
              <span class="Mu">label1</span>
              <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)))</span></span>
          <span class="Mu"><span class="Delimiter">'((</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
            <span class="Mu">label1</span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'insert-code' can insert multiple fragments in order before label&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;before-scoped&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>before f/label1 <span class="Delimiter">[</span>  <span class="Comment">; label1 only inside function f</span></span>
     <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
    <span class="Delimiter">])))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>insert-code
            <span class="Mu"><span class="Delimiter">'((</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
              <span class="Mu">label1</span>
              <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">))</span></span>
            <span class="Delimiter">'</span>f<span class="Delimiter">)</span>
          <span class="Mu"><span class="Delimiter">'((</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
            <span class="Mu">label1</span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'insert-code' can insert fragments before labels just in specified functions&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;before-scoped2&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>before f/label1 <span class="Delimiter">[</span>  <span class="Comment">; label1 only inside function f</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>insert-code
            <span class="Mu"><span class="Delimiter">'((</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
              <span class="Mu">label1</span>
              <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)))</span></span>
          <span class="Mu"><span class="Delimiter">'((</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
            <span class="Mu">label1</span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'insert-code' ignores labels not in specified functions&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;after&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>after label1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>as cons <span class="Global">after*</span>!label1<span class="Delimiter">)</span>
          <span class="Delimiter">'(</span><span class="Comment">; fragment</span>
            <span class="Delimiter">(</span>
              <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">))))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'after' records fragments of code to insert after labels&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>insert-code
            <span class="Mu"><span class="Delimiter">'((</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
              <span class="Mu">label1</span>
              <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)))</span></span>
          <span class="Mu"><span class="Delimiter">'((</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
            <span class="Mu">label1</span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'insert-code' can insert fragments after labels&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;after-multiple&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>after label1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>after label1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>as cons <span class="Global">after*</span>!label1<span class="Delimiter">)</span>
          <span class="Delimiter">'(</span><span class="Comment">; fragment</span>
            <span class="Delimiter">(</span>
              <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">))</span></span>
            <span class="Delimiter">(</span>
              <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">))))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'after' records fragments in *reverse* order&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>insert-code
            <span class="Mu"><span class="Delimiter">'((</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
              <span class="Mu">label1</span>
              <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)))</span></span>
          <span class="Mu"><span class="Delimiter">'((</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
            <span class="Mu">label1</span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'insert-code' can insert multiple fragments in order after label&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;before-after&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>before label1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>after label1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span><span class="Normal">and</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>as cons <span class="Global">before*</span>!label1<span class="Delimiter">)</span>
               <span class="Delimiter">'(</span><span class="Comment">; fragment</span>
                 <span class="Delimiter">(</span>
                   <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">))))</span></span>
         <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>as cons <span class="Global">after*</span>!label1<span class="Delimiter">)</span>
               <span class="Delimiter">'(</span><span class="Comment">; fragment</span>
                 <span class="Delimiter">(</span>
                   <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)))))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'before' and 'after' fragments work together&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>insert-code
            <span class="Mu"><span class="Delimiter">'((</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
              <span class="Mu">label1</span>
              <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)))</span></span>
          <span class="Mu"><span class="Delimiter">'((</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
            <span class="Mu">label1</span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'insert-code' can insert multiple fragments around label&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;before-after-multiple&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>before label1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>after label1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>before label1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>after label1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">6</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">7</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span><span class="Normal">or</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>as cons <span class="Global">before*</span>!label1<span class="Delimiter">)</span>
              <span class="Delimiter">'(</span><span class="Comment">; fragment</span>
                <span class="Delimiter">(</span>
                  <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
                  <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">))</span></span>
                <span class="Delimiter">(</span>
                  <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">))))</span></span>
        <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>as cons <span class="Global">after*</span>!label1<span class="Delimiter">)</span>
              <span class="Delimiter">'(</span><span class="Comment">; fragment</span>
                <span class="Delimiter">(</span>
                  <span class="Mu"><span class="Delimiter">(</span><span class="Constant">6</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
                  <span class="Mu"><span class="Delimiter">(</span><span class="Constant">7</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">))</span></span>
                <span class="Delimiter">(</span>
                  <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)))))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - multiple 'before' and 'after' fragments at once&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>insert-code
            <span class="Mu"><span class="Delimiter">'((</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
              <span class="Mu">label1</span>
              <span class="Mu"><span class="Delimiter">(</span><span class="Constant">8</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)))</span></span>
          <span class="Mu"><span class="Delimiter">'((</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
            <span class="Mu">label1</span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Constant">6</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Constant">7</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
            <span class="Mu"><span class="Delimiter">(</span><span class="Constant">8</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'insert-code' can insert multiple fragments around label - 2&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;before-after-independent&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span><span class="Normal">do</span>
            <span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
            <span class="Delimiter">(</span>add-code
              <span class="Mu"><span class="Delimiter">'((</span>before label1 <span class="Delimiter">[</span></span>
                  <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
                 <span class="Delimiter">])</span>
                <span class="Mu"><span class="Delimiter">(</span>after label1 <span class="Delimiter">[</span></span>
                  <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
                 <span class="Delimiter">])</span>
                <span class="Mu"><span class="Delimiter">(</span>before label1 <span class="Delimiter">[</span></span>
                  <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
                 <span class="Delimiter">])</span>
                <span class="Mu"><span class="Delimiter">(</span>after label1 <span class="Delimiter">[</span></span>
                  <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
                 <span class="Delimiter">])))</span>
            <span class="Delimiter">(</span>list <span class="Global">before*</span>!label1 <span class="Global">after*</span>!label1<span class="Delimiter">))</span>
          <span class="Delimiter">(</span><span class="Normal">do</span>
            <span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
            <span class="Delimiter">(</span>add-code
              <span class="Mu"><span class="Delimiter">'((</span>before label1 <span class="Delimiter">[</span></span>
                  <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
                 <span class="Delimiter">])</span>
                <span class="Mu"><span class="Delimiter">(</span>before label1 <span class="Delimiter">[</span></span>
                  <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
                 <span class="Delimiter">])</span>
                <span class="Mu"><span class="Delimiter">(</span>after label1 <span class="Delimiter">[</span></span>
                  <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
                 <span class="Delimiter">])</span>
                <span class="Mu"><span class="Delimiter">(</span>after label1 <span class="Delimiter">[</span></span>
                  <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
                 <span class="Delimiter">])))</span>
            <span class="Delimiter">(</span>list <span class="Global">before*</span>!label1 <span class="Global">after*</span>!label1<span class="Delimiter">)))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - order matters between 'before' and between 'after' fragments, but not *across* 'before' and 'after' fragments&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;before-after-braces&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span>= <span class="Global">function*</span> <span class="Delimiter">(</span>table<span class="Delimiter">))</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>after label1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function f1 <span class="Delimiter">[</span></span>
      { <span class="CommentedCode">begin</span>
        <span class="Mu">label1</span>
      }
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;cn0&quot;)))</span>
<span class="Delimiter">(</span>freeze <span class="Global">function*</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">function*</span>!f1
          <span class="Mu"><span class="Delimiter">'(</span>label1</span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - before/after works inside blocks&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;before-after-any-order&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span>= <span class="Global">function*</span> <span class="Delimiter">(</span>table<span class="Delimiter">))</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function f1 <span class="Delimiter">[</span></span>
      { <span class="CommentedCode">begin</span>
        <span class="Mu">label1</span>
      }
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>after label1 <span class="Delimiter">[</span></span>
       <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>freeze <span class="Global">function*</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">function*</span>!f1
          <span class="Mu"><span class="Delimiter">'(</span>label1</span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - before/after can come after the function they need to modify&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;multiple-defs&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span>= <span class="Global">function*</span> <span class="Delimiter">(</span>table<span class="Delimiter">))</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function f1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function f1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>freeze <span class="Global">function*</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">function*</span>!f1
          <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">2</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))</span></span>
            <span class="Mu"><span class="Delimiter">(((</span><span class="Constant">1</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - multiple 'def' of the same function add clauses&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;def!&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">traces*</span> <span class="Delimiter">(</span>queue<span class="Delimiter">))</span>
<span class="Delimiter">(</span>= <span class="Global">function*</span> <span class="Delimiter">(</span>table<span class="Delimiter">))</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function f1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])</span>
    <span class="Mu"><span class="Delimiter">(</span>function! f1 <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> copy <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>freeze <span class="Global">function*</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">function*</span>!f1
          <span class="Mu"><span class="Delimiter">'((((</span><span class="Constant">2</span> integer<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>copy<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">0</span> literal<span class="Delimiter">)))))</span></span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'def!' clears all previous clauses&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">)</span>  <span class="Comment">; section 10</span>

<span class="SalientComment">;; ---</span>

<span class="Delimiter">(</span>section <span class="Constant">100</span>  <span class="Comment">; string utilities</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;string-new&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:string-address <span class="Op">&lt;-</span> new string:literal <span class="MuConstant">5</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span><span class="Normal">let</span> routine make-routine!main
  <span class="Delimiter">(</span>enq routine <span class="Global">running-routines*</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span><span class="Normal">let</span> before rep.routine!alloc
    <span class="Delimiter">(</span>run<span class="Delimiter">)</span>
    <span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso rep.routine!alloc <span class="Delimiter">(</span>+ before <span class="Constant">5</span> <span class="Constant">1</span><span class="Delimiter">))</span>
      <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'new' allocates arrays of bytes for strings&quot;</span><span class="Delimiter">))))</span>

<span class="Comment">; Convenience: initialize strings using string literals</span>
<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;string-literal&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:string-address <span class="Op">&lt;-</span> new <span class="Constant">&quot;hello&quot;</span><span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span><span class="Normal">let</span> routine make-routine!main
  <span class="Delimiter">(</span>enq routine <span class="Global">running-routines*</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span><span class="Normal">let</span> before rep.routine!alloc
<span class="CommentedCode">;?     (set dump-trace*)</span>
<span class="CommentedCode">;?     (= dump-trace* (obj whitelist '(&quot;schedule&quot; &quot;run&quot; &quot;addr&quot;)))</span>
    <span class="Delimiter">(</span>run<span class="Delimiter">)</span>
    <span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso rep.routine!alloc <span class="Delimiter">(</span>+ before <span class="Constant">5</span> <span class="Constant">1</span><span class="Delimiter">))</span>
      <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'new' allocates arrays of bytes for string literals&quot;</span><span class="Delimiter">))</span>
    <span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~memory-contains-array before <span class="Constant">&quot;hello&quot;</span><span class="Delimiter">)</span>
      <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'new' initializes allocated memory to string literal&quot;</span><span class="Delimiter">))))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;strcat&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:string-address <span class="Op">&lt;-</span> new <span class="Constant">&quot;hello,&quot;</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:string-address <span class="Op">&lt;-</span> new <span class="Constant">&quot; world!&quot;</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:string-address <span class="Op">&lt;-</span> strcat <span class="Constant">1</span>:string-address <span class="Constant">2</span>:string-address<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~memory-contains-array <span class="Global">memory*</span><span class="Constant">.3</span> <span class="Constant">&quot;hello, world!&quot;</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'strcat' concatenates strings&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;interpolate&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:string-address <span class="Op">&lt;-</span> new <span class="Constant">&quot;hello, _!&quot;</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:string-address <span class="Op">&lt;-</span> new <span class="Constant">&quot;abc&quot;</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:string-address <span class="Op">&lt;-</span> interpolate <span class="Constant">1</span>:string-address <span class="Constant">2</span>:string-address<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;run&quot;)))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~memory-contains-array <span class="Global">memory*</span><span class="Constant">.3</span> <span class="Constant">&quot;hello, abc!&quot;</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'interpolate' splices strings&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;interpolate-empty&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:string-address <span class="Op">&lt;-</span> new <span class="Constant">&quot;hello!&quot;</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:string-address <span class="Op">&lt;-</span> new <span class="Constant">&quot;abc&quot;</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:string-address <span class="Op">&lt;-</span> interpolate <span class="Constant">1</span>:string-address <span class="Constant">2</span>:string-address<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;run&quot;)))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~memory-contains-array <span class="Global">memory*</span><span class="Constant">.3</span> <span class="Constant">&quot;hello!&quot;</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'interpolate' without underscore returns template&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;interpolate-at-start&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:string-address <span class="Op">&lt;-</span> new <span class="Constant">&quot;_, hello!&quot;</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:string-address <span class="Op">&lt;-</span> new <span class="Constant">&quot;abc&quot;</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:string-address <span class="Op">&lt;-</span> interpolate <span class="Constant">1</span>:string-address <span class="Constant">2</span>:string-address<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;run&quot;)))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~memory-contains-array <span class="Global">memory*</span><span class="Constant">.3</span> <span class="Constant">&quot;abc, hello&quot;</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'interpolate' splices strings at start&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;interpolate-at-end&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:string-address <span class="Op">&lt;-</span> new <span class="Constant">&quot;hello, _&quot;</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:string-address <span class="Op">&lt;-</span> new <span class="Constant">&quot;abc&quot;</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:string-address <span class="Op">&lt;-</span> interpolate <span class="Constant">1</span>:string-address <span class="Constant">2</span>:string-address<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;run&quot;)))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~memory-contains-array <span class="Global">memory*</span><span class="Constant">.3</span> <span class="Constant">&quot;hello, abc&quot;</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'interpolate' splices strings at start&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;interpolate-varargs&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:string-address <span class="Op">&lt;-</span> new <span class="Constant">&quot;hello, _, _, and _!&quot;</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:string-address <span class="Op">&lt;-</span> new <span class="Constant">&quot;abc&quot;</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">3</span>:string-address <span class="Op">&lt;-</span> new <span class="Constant">&quot;def&quot;</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">4</span>:string-address <span class="Op">&lt;-</span> new <span class="Constant">&quot;ghi&quot;</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">5</span>:string-address <span class="Op">&lt;-</span> interpolate <span class="Constant">1</span>:string-address <span class="Constant">2</span>:string-address <span class="Constant">3</span>:string-address <span class="Constant">4</span>:string-address<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;run&quot;)))</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;run&quot; &quot;array-info&quot;)))</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (quit)</span>
<span class="CommentedCode">;? (up i 1 (+ 1 (memory* memory*.5))</span>
<span class="CommentedCode">;?   (prn (memory* (+ memory*.5 i))))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~memory-contains-array <span class="Global">memory*</span><span class="Constant">.5</span> <span class="Constant">&quot;hello, abc, def, and ghi!&quot;</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'interpolate' splices in any number of strings&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;string-find-next&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:string-address <span class="Op">&lt;-</span> new <span class="Constant">&quot;a/b&quot;</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> find-next <span class="Constant">1</span>:string-address <span class="Delimiter">((</span><span class="MuConstant">#\/</span> literal<span class="Delimiter">))</span> <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.2</span> <span class="Constant">1</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'find-next' finds first location of a character&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;string-find-next-empty&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:string-address <span class="Op">&lt;-</span> new <span class="Constant">&quot;&quot;</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> find-next <span class="Constant">1</span>:string-address <span class="Delimiter">((</span><span class="MuConstant">#\/</span> literal<span class="Delimiter">))</span> <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="Delimiter">(</span>each routine <span class="Global">completed-routines*</span>
  <span class="Delimiter">(</span>aif rep.routine!error <span class="Delimiter">(</span>prn <span class="Constant">&quot;error - &quot;</span> it<span class="Delimiter">)))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.2</span> <span class="Constant">0</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'find-next' finds first location of a character&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;string-find-next-initial&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:string-address <span class="Op">&lt;-</span> new <span class="Constant">&quot;/abc&quot;</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> find-next <span class="Constant">1</span>:string-address <span class="Delimiter">((</span><span class="MuConstant">#\/</span> literal<span class="Delimiter">))</span> <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.2</span> <span class="Constant">0</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'find-next' handles prefix match&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;string-find-next-final&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:string-address <span class="Op">&lt;-</span> new <span class="Constant">&quot;abc/&quot;</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> find-next <span class="Constant">1</span>:string-address <span class="Delimiter">((</span><span class="MuConstant">#\/</span> literal<span class="Delimiter">))</span> <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*.2)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.2</span> <span class="Constant">3</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'find-next' handles suffix match&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;string-find-next-missing&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:string-address <span class="Op">&lt;-</span> new <span class="Constant">&quot;abc&quot;</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> find-next <span class="Constant">1</span>:string-address <span class="Delimiter">((</span><span class="MuConstant">#\/</span> literal<span class="Delimiter">))</span> <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn memory*.2)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.2</span> <span class="Constant">3</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'find-next' handles no match&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;string-find-next-invalid-index&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:string-address <span class="Op">&lt;-</span> new <span class="Constant">&quot;abc&quot;</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> find-next <span class="Constant">1</span>:string-address <span class="Delimiter">((</span><span class="MuConstant">#\/</span> literal<span class="Delimiter">))</span> <span class="MuConstant">4</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;run&quot;)))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="Delimiter">(</span>each routine <span class="Global">completed-routines*</span>
  <span class="Delimiter">(</span>aif rep.routine!error <span class="Delimiter">(</span>prn <span class="Constant">&quot;error - &quot;</span> it<span class="Delimiter">)))</span>
<span class="CommentedCode">;? (prn memory*.2)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.2</span> <span class="Constant">4</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'find-next' skips invalid index (past end of string)&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;string-find-next-first&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:string-address <span class="Op">&lt;-</span> new <span class="Constant">&quot;ab/c/&quot;</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> find-next <span class="Constant">1</span>:string-address <span class="Delimiter">((</span><span class="MuConstant">#\/</span> literal<span class="Delimiter">))</span> <span class="MuConstant">0</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.2</span> <span class="Constant">2</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'find-next' finds first of multiple options&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;string-find-next-second&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:string-address <span class="Op">&lt;-</span> new <span class="Constant">&quot;ab/c/&quot;</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:integer <span class="Op">&lt;-</span> find-next <span class="Constant">1</span>:string-address <span class="Delimiter">((</span><span class="MuConstant">#\/</span> literal<span class="Delimiter">))</span> <span class="MuConstant">3</span>:literal<span class="Delimiter">)</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span><span class="Constant">.2</span> <span class="Constant">4</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'find-next' finds second of multiple options&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;string-split&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:string-address <span class="Op">&lt;-</span> new <span class="Constant">&quot;a/b&quot;</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:string-address-array-address <span class="Op">&lt;-</span> split <span class="Constant">1</span>:string-address <span class="Delimiter">((</span><span class="MuConstant">#\/</span> literal<span class="Delimiter">)))</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="Delimiter">(</span>each routine <span class="Global">completed-routines*</span>
  <span class="Delimiter">(</span>aif rep.routine!error <span class="Delimiter">(</span>prn <span class="Constant">&quot;error - &quot;</span> it<span class="Delimiter">)))</span>
<span class="Delimiter">(</span><span class="Normal">let</span> base <span class="Global">memory*</span><span class="Constant">.2</span>
<span class="CommentedCode">;?   (prn base &quot; &quot; memory*.base)</span>
  <span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span><span class="Normal">or</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span>.base <span class="Constant">2</span><span class="Delimiter">)</span>
<span class="CommentedCode">;?           (do1 nil prn.111)</span>
          <span class="Delimiter">(</span>~memory-contains-array <span class="Delimiter">(</span><span class="Global">memory*</span> <span class="Delimiter">(</span>+ base <span class="Constant">1</span><span class="Delimiter">))</span> <span class="Constant">&quot;a&quot;</span><span class="Delimiter">)</span>
<span class="CommentedCode">;?           (do1 nil prn.111)</span>
          <span class="Delimiter">(</span>~memory-contains-array <span class="Delimiter">(</span><span class="Global">memory*</span> <span class="Delimiter">(</span>+ base <span class="Constant">2</span><span class="Delimiter">))</span> <span class="Constant">&quot;b&quot;</span><span class="Delimiter">))</span>
    <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'split' cuts string at delimiter&quot;</span><span class="Delimiter">)))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;string-split2&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:string-address <span class="Op">&lt;-</span> new <span class="Constant">&quot;a/b/c&quot;</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:string-address-array-address <span class="Op">&lt;-</span> split <span class="Constant">1</span>:string-address <span class="Delimiter">((</span><span class="MuConstant">#\/</span> literal<span class="Delimiter">)))</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="Delimiter">(</span>each routine <span class="Global">completed-routines*</span>
  <span class="Delimiter">(</span>aif rep.routine!error <span class="Delimiter">(</span>prn <span class="Constant">&quot;error - &quot;</span> it<span class="Delimiter">)))</span>
<span class="Delimiter">(</span><span class="Normal">let</span> base <span class="Global">memory*</span><span class="Constant">.2</span>
<span class="CommentedCode">;?   (prn base &quot; &quot; memory*.base)</span>
  <span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span><span class="Normal">or</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span>.base <span class="Constant">3</span><span class="Delimiter">)</span>
<span class="CommentedCode">;?           (do1 nil prn.111)</span>
          <span class="Delimiter">(</span>~memory-contains-array <span class="Delimiter">(</span><span class="Global">memory*</span> <span class="Delimiter">(</span>+ base <span class="Constant">1</span><span class="Delimiter">))</span> <span class="Constant">&quot;a&quot;</span><span class="Delimiter">)</span>
<span class="CommentedCode">;?           (do1 nil prn.111)</span>
          <span class="Delimiter">(</span>~memory-contains-array <span class="Delimiter">(</span><span class="Global">memory*</span> <span class="Delimiter">(</span>+ base <span class="Constant">2</span><span class="Delimiter">))</span> <span class="Constant">&quot;b&quot;</span><span class="Delimiter">)</span>
<span class="CommentedCode">;?           (do1 nil prn.111)</span>
          <span class="Delimiter">(</span>~memory-contains-array <span class="Delimiter">(</span><span class="Global">memory*</span> <span class="Delimiter">(</span>+ base <span class="Constant">3</span><span class="Delimiter">))</span> <span class="Constant">&quot;c&quot;</span><span class="Delimiter">))</span>
    <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'split' cuts string at two delimiters&quot;</span><span class="Delimiter">)))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;string-split-missing&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:string-address <span class="Op">&lt;-</span> new <span class="Constant">&quot;abc&quot;</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:string-address-array-address <span class="Op">&lt;-</span> split <span class="Constant">1</span>:string-address <span class="Delimiter">((</span><span class="MuConstant">#\/</span> literal<span class="Delimiter">)))</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="Delimiter">(</span>each routine <span class="Global">completed-routines*</span>
  <span class="Delimiter">(</span>aif rep.routine!error <span class="Delimiter">(</span>prn <span class="Constant">&quot;error - &quot;</span> it<span class="Delimiter">)))</span>
<span class="Delimiter">(</span><span class="Normal">let</span> base <span class="Global">memory*</span><span class="Constant">.2</span>
  <span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span><span class="Normal">or</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span>.base <span class="Constant">1</span><span class="Delimiter">)</span>
          <span class="Delimiter">(</span>~memory-contains-array <span class="Delimiter">(</span><span class="Global">memory*</span> <span class="Delimiter">(</span>+ base <span class="Constant">1</span><span class="Delimiter">))</span> <span class="Constant">&quot;abc&quot;</span><span class="Delimiter">))</span>
    <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'split' handles missing delimiter&quot;</span><span class="Delimiter">)))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;string-split-empty&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:string-address <span class="Op">&lt;-</span> new <span class="Constant">&quot;&quot;</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:string-address-array-address <span class="Op">&lt;-</span> split <span class="Constant">1</span>:string-address <span class="Delimiter">((</span><span class="MuConstant">#\/</span> literal<span class="Delimiter">)))</span></span>
     <span class="Delimiter">])))</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;run&quot;)))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="Delimiter">(</span>each routine <span class="Global">completed-routines*</span>
  <span class="Delimiter">(</span>aif rep.routine!error <span class="Delimiter">(</span>prn <span class="Constant">&quot;error - &quot;</span> it<span class="Delimiter">)))</span>
<span class="Delimiter">(</span><span class="Normal">let</span> base <span class="Global">memory*</span><span class="Constant">.2</span>
<span class="CommentedCode">;?   (prn base &quot; &quot; memory*.base)</span>
  <span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span>.base <span class="Constant">0</span><span class="Delimiter">)</span>
    <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'split' handles empty string&quot;</span><span class="Delimiter">)))</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;string-split-empty-piece&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Mu"><span class="Delimiter">'((</span>function main <span class="Delimiter">[</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">1</span>:string-address <span class="Op">&lt;-</span> new <span class="Constant">&quot;a/b//c&quot;</span><span class="Delimiter">)</span></span>
      <span class="Mu"><span class="Delimiter">(</span><span class="Constant">2</span>:string-address-array-address <span class="Op">&lt;-</span> split <span class="Constant">1</span>:string-address <span class="Delimiter">((</span><span class="MuConstant">#\/</span> literal<span class="Delimiter">)))</span></span>
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span>run <span class="Delimiter">'</span>main<span class="Delimiter">)</span>
<span class="Delimiter">(</span>each routine <span class="Global">completed-routines*</span>
  <span class="Delimiter">(</span>aif rep.routine!error <span class="Delimiter">(</span>prn <span class="Constant">&quot;error - &quot;</span> it<span class="Delimiter">)))</span>
<span class="Delimiter">(</span><span class="Normal">let</span> base <span class="Global">memory*</span><span class="Constant">.2</span>
  <span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span><span class="Normal">or</span> <span class="Delimiter">(</span>~is <span class="Global">memory*</span>.base <span class="Constant">4</span><span class="Delimiter">)</span>
          <span class="Delimiter">(</span>~memory-contains-array <span class="Delimiter">(</span><span class="Global">memory*</span> <span class="Delimiter">(</span>+ base <span class="Constant">1</span><span class="Delimiter">))</span> <span class="Constant">&quot;a&quot;</span><span class="Delimiter">)</span>
          <span class="Delimiter">(</span>~memory-contains-array <span class="Delimiter">(</span><span class="Global">memory*</span> <span class="Delimiter">(</span>+ base <span class="Constant">2</span><span class="Delimiter">))</span> <span class="Constant">&quot;b&quot;</span><span class="Delimiter">)</span>
          <span class="Delimiter">(</span>~memory-contains-array <span class="Delimiter">(</span><span class="Global">memory*</span> <span class="Delimiter">(</span>+ base <span class="Constant">3</span><span class="Delimiter">))</span> <span class="Constant">&quot;&quot;</span><span class="Delimiter">)</span>
          <span class="Delimiter">(</span>~memory-contains-array <span class="Delimiter">(</span><span class="Global">memory*</span> <span class="Delimiter">(</span>+ base <span class="Constant">4</span><span class="Delimiter">))</span> <span class="Constant">&quot;c&quot;</span><span class="Delimiter">))</span>
    <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'split' cuts string at two delimiters&quot;</span><span class="Delimiter">)))</span>

<span class="Delimiter">)</span>  <span class="Comment">; section 100 for string utilities</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>new-trace <span class="Constant">&quot;parse-and-record&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>add-code
  <span class="Delimiter">'((</span>and-record foo <span class="Delimiter">[</span>
      x:string
      y:integer
      z:boolean
     <span class="Delimiter">])))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Global">type*</span>!foo <span class="Delimiter">(</span>obj size <span class="Constant">3</span>  and-record t  elems <span class="Delimiter">'((</span>string<span class="Delimiter">)</span> <span class="Delimiter">(</span>integer<span class="Delimiter">)</span> <span class="Delimiter">(</span>boolean<span class="Delimiter">))</span>  <span class="Normal">fields</span> <span class="Delimiter">'(</span>x y z<span class="Delimiter">)))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'add-code' can add new and-records&quot;</span><span class="Delimiter">))</span>

<span class="SalientComment">;; unit tests for various helpers</span>

<span class="Comment">; tokenize-args</span>
<span class="Delimiter">(</span>prn <span class="Constant">&quot;== tokenize-args&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>assert:iso <span class="Delimiter">'((</span>a b<span class="Delimiter">)</span> <span class="Delimiter">(</span>c d<span class="Delimiter">))</span>
            <span class="Delimiter">(</span>tokenize-arg <span class="Delimiter">'</span>a:b/c:d<span class="Delimiter">))</span>
<span class="Comment">; numbers are not symbols</span>
<span class="Delimiter">(</span>assert:iso <span class="Delimiter">'((</span>a b<span class="Delimiter">)</span> <span class="Delimiter">(</span><span class="Constant">1</span> d<span class="Delimiter">))</span>
            <span class="Delimiter">(</span>tokenize-arg <span class="Delimiter">'</span>a:b/1:d<span class="Delimiter">))</span>
<span class="Comment">; special symbols are skipped</span>
<span class="Mu"><span class="Delimiter">(</span>assert:iso <span class="Delimiter">'</span><span class="Op">&lt;-</span></span>
            <span class="Mu"><span class="Delimiter">(</span>tokenize-arg <span class="Delimiter">'</span><span class="Op">&lt;-</span><span class="Delimiter">))</span></span>
<span class="Delimiter">(</span>assert:iso <span class="Delimiter">'</span>_
            <span class="Delimiter">(</span>tokenize-arg <span class="Delimiter">'</span>_<span class="Delimiter">))</span>

<span class="Comment">; idempotent</span>
<span class="Delimiter">(</span>assert:iso <span class="Delimiter">(</span>tokenize-arg:tokenize-arg <span class="Delimiter">'</span>a:b/c:d<span class="Delimiter">)</span>
            <span class="Delimiter">(</span>tokenize-arg              <span class="Delimiter">'</span>a:b/c:d<span class="Delimiter">))</span>

<span class="Comment">; support labels</span>
<span class="Mu"><span class="Delimiter">(</span>assert:iso <span class="Delimiter">'((((</span>default-space space-address<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>new<span class="Delimiter">))</span> <span class="Delimiter">((</span>space literal<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">30</span> literal<span class="Delimiter">)))</span></span>
              foo<span class="Delimiter">)</span>
            <span class="Delimiter">(</span>tokenize-args
              <span class="Mu"><span class="Delimiter">'((</span>default-space:space-address <span class="Op">&lt;-</span> new space:literal <span class="MuConstant">30</span>:literal<span class="Delimiter">)</span></span>
                foo<span class="Delimiter">)))</span>

<span class="Comment">; support braces</span>
<span class="Mu"><span class="Delimiter">(</span>assert:iso <span class="Delimiter">'((((</span>default-space space-address<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>new<span class="Delimiter">))</span> <span class="Delimiter">((</span>space literal<span class="Delimiter">))</span> <span class="Delimiter">((</span><span class="MuConstant">30</span> literal<span class="Delimiter">)))</span></span>
              foo
              { <span class="CommentedCode">begin</span>
                bar
                <span class="Mu"><span class="Delimiter">(((</span>a b<span class="Delimiter">))</span> <span class="Op">&lt;-</span> <span class="Delimiter">((</span>op<span class="Delimiter">))</span> <span class="Delimiter">((</span>c d<span class="Delimiter">))</span> <span class="Delimiter">((</span>e f<span class="Delimiter">)))</span></span>
              }<span class="Delimiter">)</span>
            <span class="Delimiter">(</span>tokenize-args
              <span class="Mu"><span class="Delimiter">'((</span>default-space:space-address <span class="Op">&lt;-</span> new space:literal <span class="MuConstant">30</span>:literal<span class="Delimiter">)</span></span>
                foo
                { <span class="CommentedCode">begin</span>
                  bar
                  <span class="Mu"><span class="Delimiter">(</span>a:b <span class="Op">&lt;-</span> op c:d e:f<span class="Delimiter">)</span></span>
                }<span class="Delimiter">)))</span>

<span class="Comment">; space</span>
<span class="Delimiter">(</span>prn <span class="Constant">&quot;== space&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Constant">0</span> <span class="Delimiter">(</span>space <span class="Delimiter">'((</span><span class="Constant">4</span> integer<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'space' is 0 by default&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Constant">1</span> <span class="Delimiter">(</span>space <span class="Delimiter">'((</span><span class="Constant">4</span> integer<span class="Delimiter">)</span> <span class="Delimiter">(</span>space <span class="Constant">1</span><span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'space' picks up space when available&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">'</span>global <span class="Delimiter">(</span>space <span class="Delimiter">'((</span><span class="Constant">4</span> integer<span class="Delimiter">)</span> <span class="Delimiter">(</span>space global<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'space' understands routine-global space&quot;</span><span class="Delimiter">))</span>

<span class="Comment">; absolutize</span>
<span class="Delimiter">(</span>prn <span class="Constant">&quot;== absolutize&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">'((</span><span class="Constant">4</span> integer<span class="Delimiter">))</span> <span class="Delimiter">(</span>absolutize <span class="Delimiter">'((</span><span class="Constant">4</span> integer<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'absolutize' works without routine&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span>= <span class="Global">routine*</span> make-routine!foo<span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">'((</span><span class="Constant">4</span> integer<span class="Delimiter">))</span> <span class="Delimiter">(</span>absolutize <span class="Delimiter">'((</span><span class="Constant">4</span> integer<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'absolutize' works without default-space&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span>= rep.routine*!call-stack.0!default-space <span class="Constant">10</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">memory*</span><span class="Constant">.10</span> <span class="Constant">5</span><span class="Delimiter">)</span>  <span class="Comment">; bounds check for default-space</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">'((</span><span class="Constant">15</span> integer<span class="Delimiter">)</span> <span class="Delimiter">(</span>raw<span class="Delimiter">))</span>
          <span class="Delimiter">(</span>absolutize <span class="Delimiter">'((</span><span class="Constant">4</span> integer<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'absolutize' works with default-space&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span>absolutize <span class="Delimiter">'((</span><span class="Constant">5</span> integer<span class="Delimiter">)))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~posmatch <span class="Constant">&quot;no room&quot;</span> rep.routine*!error<span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'absolutize' checks against default-space bounds&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">'((</span>_ integer<span class="Delimiter">))</span> <span class="Delimiter">(</span>absolutize <span class="Delimiter">'((</span>_ integer<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'absolutize' passes dummy args right through&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>= <span class="Global">memory*</span><span class="Constant">.20</span> <span class="Constant">5</span><span class="Delimiter">)</span>  <span class="Comment">; pretend array</span>
<span class="Delimiter">(</span>= rep.routine*!globals <span class="Constant">20</span><span class="Delimiter">)</span>  <span class="Comment">; provide it to routine global</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">'((</span><span class="Constant">22</span> integer<span class="Delimiter">)</span> <span class="Delimiter">(</span>raw<span class="Delimiter">))</span>
          <span class="Delimiter">(</span>absolutize <span class="Delimiter">'((</span><span class="Constant">1</span> integer<span class="Delimiter">)</span> <span class="Delimiter">(</span>space global<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'absolutize' handles variables in the global space&quot;</span><span class="Delimiter">))</span>

<span class="Comment">; deref</span>
<span class="Delimiter">(</span>prn <span class="Constant">&quot;== deref&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">memory*</span><span class="Constant">.3</span> <span class="Constant">4</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">'((</span><span class="Constant">4</span> integer<span class="Delimiter">))</span>
          <span class="Delimiter">(</span>deref <span class="Delimiter">'((</span><span class="Constant">3</span> integer-address<span class="Delimiter">)</span>
                   <span class="Delimiter">(</span>deref<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'deref' handles simple addresses&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">'((</span><span class="Constant">4</span> integer<span class="Delimiter">)</span> <span class="Delimiter">(</span>deref<span class="Delimiter">))</span>
          <span class="Delimiter">(</span>deref <span class="Delimiter">'((</span><span class="Constant">3</span> integer-address<span class="Delimiter">)</span>
                   <span class="Delimiter">(</span>deref<span class="Delimiter">)</span>
                   <span class="Delimiter">(</span>deref<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'deref' deletes just one deref&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span>= <span class="Global">memory*</span><span class="Constant">.4</span> <span class="Constant">5</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">'((</span><span class="Constant">5</span> integer<span class="Delimiter">))</span>
          <span class="Delimiter">(</span>deref:deref <span class="Delimiter">'((</span><span class="Constant">3</span> integer-address-address<span class="Delimiter">)</span>
                         <span class="Delimiter">(</span>deref<span class="Delimiter">)</span>
                         <span class="Delimiter">(</span>deref<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'deref' can be chained&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">'((</span><span class="Constant">5</span> integer<span class="Delimiter">)</span> <span class="Delimiter">(</span>foo<span class="Delimiter">))</span>
          <span class="Delimiter">(</span>deref:deref <span class="Delimiter">'((</span><span class="Constant">3</span> integer-address-address<span class="Delimiter">)</span>
                         <span class="Delimiter">(</span>deref<span class="Delimiter">)</span>
                         <span class="Delimiter">(</span>foo<span class="Delimiter">)</span>
                         <span class="Delimiter">(</span>deref<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'deref' skips junk&quot;</span><span class="Delimiter">))</span>

<span class="Comment">; addr</span>
<span class="Delimiter">(</span>prn <span class="Constant">&quot;== addr&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">routine*</span> nil<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn 111)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">4</span> <span class="Delimiter">(</span>addr <span class="Delimiter">'((</span><span class="Constant">4</span> integer<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - directly addressed operands are their own address&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">4</span> <span class="Delimiter">(</span>addr <span class="Delimiter">'((</span><span class="Constant">4</span> integer-address<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - directly addressed operands are their own address - 2&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">4</span> <span class="Delimiter">(</span>addr <span class="Delimiter">'((</span><span class="MuConstant">4</span> literal<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'addr' doesn't understand literals&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (prn 201)</span>
<span class="Delimiter">(</span>= <span class="Global">memory*</span><span class="Constant">.4</span> <span class="Constant">23</span><span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn 202)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">23</span> <span class="Delimiter">(</span>addr <span class="Delimiter">'((</span><span class="Constant">4</span> integer-address<span class="Delimiter">)</span> <span class="Delimiter">(</span>deref<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'addr' works with indirectly-addressed 'deref'&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>
<span class="Delimiter">(</span>= <span class="Global">memory*</span><span class="Constant">.3</span> <span class="Constant">4</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">23</span> <span class="Delimiter">(</span>addr <span class="Delimiter">'((</span><span class="Constant">3</span> integer-address-address<span class="Delimiter">)</span> <span class="Delimiter">(</span>deref<span class="Delimiter">)</span> <span class="Delimiter">(</span>deref<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'addr' works with multiple 'deref'&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>= <span class="Global">routine*</span> make-routine!foo<span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">4</span> <span class="Delimiter">(</span>addr <span class="Delimiter">'((</span><span class="Constant">4</span> integer<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - directly addressed operands are their own address inside routines&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">4</span> <span class="Delimiter">(</span>addr <span class="Delimiter">'((</span><span class="Constant">4</span> integer-address<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - directly addressed operands are their own address inside routines - 2&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">4</span> <span class="Delimiter">(</span>addr <span class="Delimiter">'((</span><span class="MuConstant">4</span> literal<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'addr' doesn't understand literals inside routines&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span>= <span class="Global">memory*</span><span class="Constant">.4</span> <span class="Constant">23</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">23</span> <span class="Delimiter">(</span>addr <span class="Delimiter">'((</span><span class="Constant">4</span> integer-address<span class="Delimiter">)</span> <span class="Delimiter">(</span>deref<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'addr' works with indirectly-addressed 'deref' inside routines&quot;</span><span class="Delimiter">))</span>

<span class="CommentedCode">;? (prn 301)</span>
<span class="Delimiter">(</span>= rep.routine*!call-stack.0!default-space <span class="Constant">10</span><span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn 302)</span>
<span class="Delimiter">(</span>= <span class="Global">memory*</span><span class="Constant">.10</span> <span class="Constant">5</span><span class="Delimiter">)</span>  <span class="Comment">; bounds check for default-space</span>
<span class="CommentedCode">;? (prn 303)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">15</span> <span class="Delimiter">(</span>addr <span class="Delimiter">'((</span><span class="Constant">4</span> integer<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - directly addressed operands in routines add default-space&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">15</span> <span class="Delimiter">(</span>addr <span class="Delimiter">'((</span><span class="Constant">4</span> integer-address<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - directly addressed operands in routines add default-space - 2&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">15</span> <span class="Delimiter">(</span>addr <span class="Delimiter">'((</span><span class="MuConstant">4</span> literal<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'addr' doesn't understand literals&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span>= <span class="Global">memory*</span><span class="Constant">.15</span> <span class="Constant">23</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">23</span> <span class="Delimiter">(</span>addr <span class="Delimiter">'((</span><span class="Constant">4</span> integer-address<span class="Delimiter">)</span> <span class="Delimiter">(</span>deref<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'addr' adds default-space before 'deref', not after&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Comment">; array-len</span>
<span class="Delimiter">(</span>prn <span class="Constant">&quot;== array-len&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">memory*</span><span class="Constant">.35</span> <span class="Constant">4</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">4</span> <span class="Delimiter">(</span>array-len <span class="Delimiter">'((</span><span class="Constant">35</span> integer-boolean-pair-array<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'array-len'&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span>= <span class="Global">memory*</span><span class="Constant">.34</span> <span class="Constant">35</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">4</span> <span class="Delimiter">(</span>array-len <span class="Delimiter">'((</span><span class="Constant">34</span> integer-boolean-pair-array-address<span class="Delimiter">)</span> <span class="Delimiter">(</span>deref<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'array-len'&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Comment">; sizeof</span>
<span class="Delimiter">(</span>prn <span class="Constant">&quot;== sizeof&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="CommentedCode">;? (set dump-trace*)</span>
<span class="CommentedCode">;? (prn 401)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">1</span> <span class="Delimiter">(</span>sizeof <span class="Delimiter">'((</span>_ integer<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'sizeof' works on primitives&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">1</span> <span class="Delimiter">(</span>sizeof <span class="Delimiter">'((</span>_ integer-address<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'sizeof' works on addresses&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">2</span> <span class="Delimiter">(</span>sizeof <span class="Delimiter">'((</span>_ integer-boolean-pair<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'sizeof' works on and-records&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">3</span> <span class="Delimiter">(</span>sizeof <span class="Delimiter">'((</span>_ integer-point-pair<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'sizeof' works on and-records with and-record fields&quot;</span><span class="Delimiter">))</span>

<span class="CommentedCode">;? (prn 410)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">1</span> <span class="Delimiter">(</span>sizeof <span class="Delimiter">'((</span><span class="Constant">34</span> integer<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'sizeof' works on primitive operands&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">1</span> <span class="Delimiter">(</span>sizeof <span class="Delimiter">'((</span><span class="Constant">34</span> integer-address<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'sizeof' works on address operands&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">2</span> <span class="Delimiter">(</span>sizeof <span class="Delimiter">'((</span><span class="Constant">34</span> integer-boolean-pair<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'sizeof' works on and-record operands&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">3</span> <span class="Delimiter">(</span>sizeof <span class="Delimiter">'((</span><span class="Constant">34</span> integer-point-pair<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'sizeof' works on and-record operands with and-record fields&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">2</span> <span class="Delimiter">(</span>sizeof <span class="Delimiter">'((</span><span class="Constant">34</span> integer-boolean-pair-address<span class="Delimiter">)</span> <span class="Delimiter">(</span>deref<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'sizeof' works on pointers to and-records&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span>= <span class="Global">memory*</span><span class="Constant">.35</span> <span class="Constant">4</span><span class="Delimiter">)</span>  <span class="Comment">; size of array</span>
<span class="Delimiter">(</span>= <span class="Global">memory*</span><span class="Constant">.34</span> <span class="Constant">35</span><span class="Delimiter">)</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;sizeof&quot; &quot;array-len&quot;)))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">9</span> <span class="Delimiter">(</span>sizeof <span class="Delimiter">'((</span><span class="Constant">34</span> integer-boolean-pair-array-address<span class="Delimiter">)</span> <span class="Delimiter">(</span>deref<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'sizeof' works on pointers to arrays&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="CommentedCode">;? (prn 420)</span>
<span class="Delimiter">(</span>= <span class="Global">memory*</span><span class="Constant">.4</span> <span class="Constant">23</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">24</span> <span class="Delimiter">(</span>sizeof <span class="Delimiter">'((</span><span class="Constant">4</span> integer-array<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'sizeof' reads array lengths from memory&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span>= <span class="Global">memory*</span><span class="Constant">.3</span> <span class="Constant">4</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">24</span> <span class="Delimiter">(</span>sizeof <span class="Delimiter">'((</span><span class="Constant">3</span> integer-array-address<span class="Delimiter">)</span> <span class="Delimiter">(</span>deref<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'sizeof' handles pointers to arrays&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span>= <span class="Global">memory*</span><span class="Constant">.15</span> <span class="Constant">34</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">routine*</span> make-routine!foo<span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">24</span> <span class="Delimiter">(</span>sizeof <span class="Delimiter">'((</span><span class="Constant">4</span> integer-array<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'sizeof' reads array lengths from memory inside routines&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span>= rep.routine*!call-stack.0!default-space <span class="Constant">10</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">memory*</span><span class="Constant">.10</span> <span class="Constant">5</span><span class="Delimiter">)</span>  <span class="Comment">; bounds check for default-space</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">35</span> <span class="Delimiter">(</span>sizeof <span class="Delimiter">'((</span><span class="Constant">4</span> integer-array<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'sizeof' reads array lengths from memory using default-space&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span>= <span class="Global">memory*</span><span class="Constant">.35</span> <span class="Constant">4</span><span class="Delimiter">)</span>  <span class="Comment">; size of array</span>
<span class="Delimiter">(</span>= <span class="Global">memory*</span><span class="Constant">.15</span> <span class="Constant">35</span><span class="Delimiter">)</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;sizeof&quot;)))</span>
<span class="Delimiter">(</span>aif rep.routine*!error <span class="Delimiter">(</span>prn <span class="Constant">&quot;error - &quot;</span> it<span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">9</span> <span class="Delimiter">(</span>sizeof <span class="Delimiter">'((</span><span class="Constant">4</span> integer-boolean-pair-array-address<span class="Delimiter">)</span> <span class="Delimiter">(</span>deref<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'sizeof' works on pointers to arrays using default-space&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (quit)</span>

<span class="Comment">; m</span>
<span class="Delimiter">(</span>prn <span class="Constant">&quot;== m&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">4</span> <span class="Delimiter">(</span>m <span class="Delimiter">'((</span><span class="MuConstant">4</span> literal<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'm' avoids reading memory for literals&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">4</span> <span class="Delimiter">(</span>m <span class="Delimiter">'((</span><span class="MuConstant">4</span> offset<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'm' avoids reading memory for offsets&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span>= <span class="Global">memory*</span><span class="Constant">.4</span> <span class="Constant">34</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">34</span> <span class="Delimiter">(</span>m <span class="Delimiter">'((</span><span class="Constant">4</span> integer<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'm' reads memory for simple types&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span>= <span class="Global">memory*</span><span class="Constant">.3</span> <span class="Constant">4</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">34</span> <span class="Delimiter">(</span>m <span class="Delimiter">'((</span><span class="Constant">3</span> integer-address<span class="Delimiter">)</span> <span class="Delimiter">(</span>deref<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'm' redirects addresses&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span>= <span class="Global">memory*</span><span class="Constant">.2</span> <span class="Constant">3</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">34</span> <span class="Delimiter">(</span>m <span class="Delimiter">'((</span><span class="Constant">2</span> integer-address-address<span class="Delimiter">)</span> <span class="Delimiter">(</span>deref<span class="Delimiter">)</span> <span class="Delimiter">(</span>deref<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'm' multiply redirects addresses&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>annotate <span class="Delimiter">'</span>record <span class="Delimiter">'(</span><span class="Constant">34</span> nil<span class="Delimiter">))</span> <span class="Delimiter">(</span>m <span class="Delimiter">'((</span><span class="Constant">4</span> integer-boolean-pair<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'm' supports compound records&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span>= <span class="Global">memory*</span><span class="Constant">.5</span> <span class="Constant">35</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">memory*</span><span class="Constant">.6</span> <span class="Constant">36</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>annotate <span class="Delimiter">'</span>record <span class="Delimiter">'(</span><span class="Constant">34</span> <span class="Constant">35</span> <span class="Constant">36</span><span class="Delimiter">))</span> <span class="Delimiter">(</span>m <span class="Delimiter">'((</span><span class="Constant">4</span> integer-point-pair<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'm' supports records with compound fields&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>annotate <span class="Delimiter">'</span>record <span class="Delimiter">'(</span><span class="Constant">34</span> <span class="Constant">35</span> <span class="Constant">36</span><span class="Delimiter">))</span> <span class="Delimiter">(</span>m <span class="Delimiter">'((</span><span class="Constant">3</span> integer-point-pair-address<span class="Delimiter">)</span> <span class="Delimiter">(</span>deref<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'm' supports indirect access to records&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span>= <span class="Global">memory*</span><span class="Constant">.4</span> <span class="Constant">2</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>annotate <span class="Delimiter">'</span>record <span class="Delimiter">'(</span><span class="Constant">2</span> <span class="Constant">35</span> <span class="Constant">36</span><span class="Delimiter">))</span> <span class="Delimiter">(</span>m <span class="Delimiter">'((</span><span class="Constant">4</span> integer-array<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'm' supports access to arrays&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Delimiter">(</span>annotate <span class="Delimiter">'</span>record <span class="Delimiter">'(</span><span class="Constant">2</span> <span class="Constant">35</span> <span class="Constant">36</span><span class="Delimiter">))</span> <span class="Delimiter">(</span>m <span class="Delimiter">'((</span><span class="Constant">3</span> integer-array-address<span class="Delimiter">)</span> <span class="Delimiter">(</span>deref<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'm' supports indirect access to arrays&quot;</span><span class="Delimiter">))</span>

<span class="Delimiter">(</span>= <span class="Global">routine*</span> make-routine!foo<span class="Delimiter">)</span>
<span class="Delimiter">(</span>= <span class="Global">memory*</span><span class="Constant">.10</span> <span class="Constant">5</span><span class="Delimiter">)</span>  <span class="Comment">; fake array</span>
<span class="Delimiter">(</span>= <span class="Global">memory*</span><span class="Constant">.12</span> <span class="Constant">34</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>= rep.routine*!globals <span class="Constant">10</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~iso <span class="Constant">34</span> <span class="Delimiter">(</span>m <span class="Delimiter">'((</span><span class="Constant">1</span> integer<span class="Delimiter">)</span> <span class="Delimiter">(</span>space global<span class="Delimiter">))))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'm' supports access to per-routine globals&quot;</span><span class="Delimiter">))</span>

<span class="Comment">; setm</span>
<span class="Delimiter">(</span>prn <span class="Constant">&quot;== setm&quot;</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>
<span class="Delimiter">(</span>setm <span class="Delimiter">'((</span><span class="Constant">4</span> integer<span class="Delimiter">))</span> <span class="Constant">34</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">34</span> <span class="Global">memory*</span><span class="Constant">.4</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'setm' writes primitives to memory&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span>setm <span class="Delimiter">'((</span><span class="Constant">3</span> integer-address<span class="Delimiter">))</span> <span class="Constant">4</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">4</span> <span class="Global">memory*</span><span class="Constant">.3</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'setm' writes addresses to memory&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span>setm <span class="Delimiter">'((</span><span class="Constant">3</span> integer-address<span class="Delimiter">)</span> <span class="Delimiter">(</span>deref<span class="Delimiter">))</span> <span class="Constant">35</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">35</span> <span class="Global">memory*</span><span class="Constant">.4</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'setm' redirects writes&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span>= <span class="Global">memory*</span><span class="Constant">.2</span> <span class="Constant">3</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>setm <span class="Delimiter">'((</span><span class="Constant">2</span> integer-address-address<span class="Delimiter">)</span> <span class="Delimiter">(</span>deref<span class="Delimiter">)</span> <span class="Delimiter">(</span>deref<span class="Delimiter">))</span> <span class="Constant">36</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~is <span class="Constant">36</span> <span class="Global">memory*</span><span class="Constant">.4</span><span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'setm' multiply redirects writes&quot;</span><span class="Delimiter">))</span>
<span class="CommentedCode">;? (prn 505)</span>
<span class="Delimiter">(</span>setm <span class="Delimiter">'((</span><span class="Constant">4</span> integer-integer-pair<span class="Delimiter">))</span> <span class="Delimiter">(</span>annotate <span class="Delimiter">'</span>record <span class="Delimiter">'(</span><span class="Constant">23</span> <span class="Constant">24</span><span class="Delimiter">)))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~memory-contains <span class="Constant">4</span> <span class="Delimiter">'(</span><span class="Constant">23</span> <span class="Constant">24</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'setm' writes compound records&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span>assert <span class="Delimiter">(</span>is <span class="Global">memory*</span><span class="Constant">.7</span> nil<span class="Delimiter">))</span>
<span class="CommentedCode">;? (prn 506)</span>
<span class="Delimiter">(</span>setm <span class="Delimiter">'((</span><span class="Constant">7</span> integer-point-pair<span class="Delimiter">))</span> <span class="Delimiter">(</span>annotate <span class="Delimiter">'</span>record <span class="Delimiter">'(</span><span class="Constant">23</span> <span class="Constant">24</span> <span class="Constant">25</span><span class="Delimiter">)))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~memory-contains <span class="Constant">7</span> <span class="Delimiter">'(</span><span class="Constant">23</span> <span class="Constant">24</span> <span class="Constant">25</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'setm' writes records with compound fields&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span>= <span class="Global">routine*</span> make-routine!foo<span class="Delimiter">)</span>
<span class="Delimiter">(</span>setm <span class="Delimiter">'((</span><span class="Constant">4</span> integer-point-pair<span class="Delimiter">))</span> <span class="Delimiter">(</span>annotate <span class="Delimiter">'</span>record <span class="Delimiter">'(</span><span class="Constant">33</span> <span class="Constant">34</span><span class="Delimiter">)))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~posmatch <span class="Constant">&quot;incorrect size&quot;</span> rep.routine*!error<span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'setm' checks size of target&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span>wipe <span class="Global">routine*</span><span class="Delimiter">)</span>
<span class="Delimiter">(</span>setm <span class="Delimiter">'((</span><span class="Constant">3</span> integer-point-pair-address<span class="Delimiter">)</span> <span class="Delimiter">(</span>deref<span class="Delimiter">))</span> <span class="Delimiter">(</span>annotate <span class="Delimiter">'</span>record <span class="Delimiter">'(</span><span class="Constant">43</span> <span class="Constant">44</span> <span class="Constant">45</span><span class="Delimiter">)))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~memory-contains <span class="Constant">4</span> <span class="Delimiter">'(</span><span class="Constant">43</span> <span class="Constant">44</span> <span class="Constant">45</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'setm' supports indirect writes to records&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span>setm <span class="Delimiter">'((</span><span class="Constant">2</span> integer-point-pair-address-address<span class="Delimiter">)</span> <span class="Delimiter">(</span>deref<span class="Delimiter">)</span> <span class="Delimiter">(</span>deref<span class="Delimiter">))</span> <span class="Delimiter">(</span>annotate <span class="Delimiter">'</span>record <span class="Delimiter">'(</span><span class="Constant">53</span> <span class="Constant">54</span> <span class="Constant">55</span><span class="Delimiter">)))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~memory-contains <span class="Constant">4</span> <span class="Delimiter">'(</span><span class="Constant">53</span> <span class="Constant">54</span> <span class="Constant">55</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'setm' supports multiply indirect writes to records&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span>setm <span class="Delimiter">'((</span><span class="Constant">4</span> integer-array<span class="Delimiter">))</span> <span class="Delimiter">(</span>annotate <span class="Delimiter">'</span>record <span class="Delimiter">'(</span><span class="Constant">2</span> <span class="Constant">31</span> <span class="Constant">32</span><span class="Delimiter">)))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~memory-contains <span class="Constant">4</span> <span class="Delimiter">'(</span><span class="Constant">2</span> <span class="Constant">31</span> <span class="Constant">32</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'setm' writes arrays&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span>setm <span class="Delimiter">'((</span><span class="Constant">3</span> integer-array-address<span class="Delimiter">)</span> <span class="Delimiter">(</span>deref<span class="Delimiter">))</span> <span class="Delimiter">(</span>annotate <span class="Delimiter">'</span>record <span class="Delimiter">'(</span><span class="Constant">2</span> <span class="Constant">41</span> <span class="Constant">42</span><span class="Delimiter">)))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~memory-contains <span class="Constant">4</span> <span class="Delimiter">'(</span><span class="Constant">2</span> <span class="Constant">41</span> <span class="Constant">42</span><span class="Delimiter">))</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'setm' supports indirect writes to arrays&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span>= <span class="Global">routine*</span> make-routine!foo<span class="Delimiter">)</span>
<span class="Delimiter">(</span>setm <span class="Delimiter">'((</span><span class="Constant">4</span> integer-array<span class="Delimiter">))</span> <span class="Delimiter">(</span>annotate <span class="Delimiter">'</span>record <span class="Delimiter">'(</span><span class="Constant">2</span> <span class="Constant">31</span> <span class="Constant">32</span> <span class="Constant">33</span><span class="Delimiter">)))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~posmatch <span class="Constant">&quot;invalid array&quot;</span> rep.routine*!error<span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'setm' checks that array written is well-formed&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span>= <span class="Global">routine*</span> make-routine!foo<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn 111)</span>
<span class="CommentedCode">;? (= dump-trace* (obj whitelist '(&quot;sizeof&quot; &quot;setm&quot;)))</span>
<span class="Delimiter">(</span>setm <span class="Delimiter">'((</span><span class="Constant">4</span> integer-boolean-pair-array<span class="Delimiter">))</span> <span class="Delimiter">(</span>annotate <span class="Delimiter">'</span>record <span class="Delimiter">'(</span><span class="Constant">2</span> <span class="Constant">31</span> nil <span class="Constant">32</span> nil <span class="Constant">33</span><span class="Delimiter">)))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>~posmatch <span class="Constant">&quot;invalid array&quot;</span> rep.routine*!error<span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'setm' checks that array of records is well-formed&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span>= <span class="Global">routine*</span> make-routine!foo<span class="Delimiter">)</span>
<span class="CommentedCode">;? (prn 222)</span>
<span class="Delimiter">(</span>setm <span class="Delimiter">'((</span><span class="Constant">4</span> integer-boolean-pair-array<span class="Delimiter">))</span> <span class="Delimiter">(</span>annotate <span class="Delimiter">'</span>record <span class="Delimiter">'(</span><span class="Constant">2</span> <span class="Constant">31</span> nil <span class="Constant">32</span> nil<span class="Delimiter">)))</span>
<span class="Delimiter">(</span><span class="Normal">if</span> <span class="Delimiter">(</span>posmatch <span class="Constant">&quot;invalid array&quot;</span> rep.routine*!error<span class="Delimiter">)</span>
  <span class="Delimiter">(</span>prn <span class="Constant">&quot;F - 'setm' checks that array of records is well-formed - 2&quot;</span><span class="Delimiter">))</span>
<span class="Delimiter">(</span>wipe <span class="Global">routine*</span><span class="Delimiter">)</span>

<span class="Delimiter">(</span>reset<span class="Delimiter">)</span>  <span class="Comment">; end file with this to persist the trace for the final test</span>
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
